{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | #ws.workers> 0 && #w.~workers=1 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{={#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}{1}}{>{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{0}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | #ws.workers> 0 && #w.~workers=1","predicate":"inv2","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Update', node=#, value=one)\", \"(type='Move', tree='{#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=0)\", \"(type='Insert', node=var1/Worker, parent=., position=1)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=~)\", \"(type='Delete', node=1)\", \"(type='Delete', node==)\", \"(type='Delete', node=0)\", \"(type='Delete', node=>)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":12,"challenge":"aTwuoJgesSd8hXXEP","time":325587900,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | some ws.workers && one ws.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{one{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | some ws.workers && one ws.workers","predicate":"inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Move', tree='{one{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Delete', node=var0/Workstation)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":5,"challenge":"aTwuoJgesSd8hXXEP","time":89268500,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | some ws.workers && #w.~workers=1 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{={#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}{1}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | some ws.workers && #w.~workers=1","predicate":"inv2","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Update', node=#, value=one)\", \"(type='Move', tree='{#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=0)\", \"(type='Insert', node=var1/Worker, parent=., position=1)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=~)\", \"(type='Delete', node=1)\", \"(type='Delete', node==)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":9,"challenge":"aTwuoJgesSd8hXXEP","time":55353000,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | #ws.workers>2 && #w.~workers=1 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{={#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}{1}}{>{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{2}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | #ws.workers>2 && #w.~workers=1","predicate":"inv2","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Update', node=#, value=one)\", \"(type='Move', tree='{#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=0)\", \"(type='Insert', node=var1/Worker, parent=., position=1)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=~)\", \"(type='Delete', node=1)\", \"(type='Delete', node==)\", \"(type='Delete', node=2)\", \"(type='Delete', node=>)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":12,"challenge":"aTwuoJgesSd8hXXEP","time":61735800,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | some ws.workers && one w.~workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{one{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | some ws.workers && one w.~workers","predicate":"inv2","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Move', tree='{one{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=0)\", \"(type='Insert', node=var1/Worker, parent=., position=1)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=~)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":6,"challenge":"aTwuoJgesSd8hXXEP","time":40796600,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | some ws.workers && one w.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{one{.{var1/Worker}{field/workers{set of{sig/Worker}}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | some ws.workers && one w.workers","predicate":"inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Move', tree='{one{.{var1/Worker}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":5,"challenge":"aTwuoJgesSd8hXXEP","time":38808900,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | some ws.workers && w in ws.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | some ws.workers && w in ws.workers","predicate":"inv2","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Update', node=in, value=one)\", \"(type='Move', tree='{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=var0/Workstation)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":7,"challenge":"aTwuoJgesSd8hXXEP","time":53522200,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | some ws.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all w:Workstation,wor:Worker | some w.workers","predicate":"inv2","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='TreeInsert', tree='{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}', parent=all, position=1)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":8,"challenge":"aTwuoJgesSd8hXXEP","time":224112900,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | #ws.workers>1 && #w.~workers=1 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{AND{={#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}{1}}{>{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{1}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | all w: Worker | #ws.workers>1 && #w.~workers=1","predicate":"inv2","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Update', node=#, value=one)\", \"(type='Move', tree='{#{.{var1/Worker}{~{field/workers{set of{sig/Worker}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=0)\", \"(type='Insert', node=var1/Worker, parent=., position=1)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=~)\", \"(type='Delete', node=1)\", \"(type='Delete', node==)\", \"(type='Delete', node=1)\", \"(type='Delete', node=>)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":12,"challenge":"aTwuoJgesSd8hXXEP","time":39456500,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | all w: Worker | one ws2: Workstation |#ws.workers> 0 && w in ws2.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{one{one of{var2}{sig/Workstation}}{AND{>{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{0}}{in{var1/Worker}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","nextExpr":"all ws : Workstation | some w : Worker | w in ws.workers and (all w2 : Worker | one work : Workstation | w2 in work.workers)","sourceExpr":"all ws: Workstation | all w: Worker | one ws2: Workstation |#ws.workers> 0 && w in ws2.workers","predicate":"inv2","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{AND{all{one of{var2}{sig/Worker}}{one{one of{var3}{sig/Workstation}}{in{var2/Worker}{.{var3/Workstation}{field/workers{set of{sig/Worker}}}}}}}{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=one, value=AND)\", \"(type='Insert', node=all, parent=one, position=0)\", \"(type='Move', tree='{in{var1/Worker}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=one, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Workstation}}', parent=all, position=0)\", \"(type='Update', node=>, value=one)\", \"(type='Move', tree='{>{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{0}}', parent=all, position=1)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Workstation}}', parent=>, position=0)\", \"(type='Update', node=#, value=in)\", \"(type='Update', node=var2/Workstation, value=var0/Workstation)\", \"(type='Insert', node=var2/Worker, parent=#, position=0)\", \"(type='Update', node=var0/Workstation, value=var3/Workstation)\", \"(type='Delete', node=0)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{AND{all{one of{var2}{sig/Worker}}{one{one of{var3}{sig/Workstation}}{in{var2/Worker}{.{var3/Workstation}{field/workers{set of{sig/Worker}}}}}}}{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","totalTED":14,"challenge":"aTwuoJgesSd8hXXEP","time":50513100,"targetExpr":"all ws : Workstation | some w : Worker | w in ws.workers and (all w2 : Worker | one work : Workstation | w2 in work.workers)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | #ws.workers> 0 && one ws.workers.~workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{AND{>{#{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{0}}{one{.{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{~{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","sourceExpr":"all ws: Workstation | #ws.workers> 0 && one ws.workers.~workers","predicate":"inv2","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=>, value=all)\", \"(type='Update', node=., value=some)\", \"(type='Move', tree='{.{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{~{field/workers{set of{sig/Worker}}}}}', parent=AND, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Worker}}', parent=>, position=0)\", \"(type='Update', node=#, value=one)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Delete', node=var0/Workstation)\", \"(type='Delete', node=0)\", \"(type='TreeDelete', tree='{~{field/workers{set of{sig/Worker}}}}')\", \"(type='Delete', node=one)\"]","hint":"Keep going! Instead of using greater than operator ('>') to specify that the left side is greater than the right side, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Workstation}}{AND{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","totalTED":14,"challenge":"aTwuoJgesSd8hXXEP","time":35976300,"targetExpr":"all x: Workstation | some (x.workers) && all y: Worker | one (workers.y)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { all w: Workstation| some p: Worker| p in w.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","nextExpr":"all w : Workstation | some w.workers all w : Worker | (one work : Workstation | w in work.workers)","sourceExpr":"all w : Workstation | some t : Worker | t in w.workers","predicate":"inv2","isNewNode":false,"srcDstTED":16,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{one of{var1}{sig/Workstation}}{in{var0/Worker}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}', parent=AND, position=1)\", \"(type='Update', node=some, value=one)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\", \"(type='Update', node=sig/Worker, value=sig/Workstation)\", \"(type='Update', node=var1/Worker, value=var0/Worker)\", \"(type='Update', node=var0/Workstation, value=var1/Workstation)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{one of{var1}{sig/Workstation}}{in{var0/Worker}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","totalTED":16,"challenge":"aTwuoJgesSd8hXXEP","time":88579800,"targetExpr":"all w : Workstation | some w.workers all w : Worker | (one work : Workstation | w in work.workers)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { all w: Workstation| some p: Worker| p in w.workers and one workers.p } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{AND{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}}","nextExpr":"(all x: Workstation| some w: Worker| w in x.workers) && (all w: Worker| one workers.w)","sourceExpr":"all w: Workstation| some p: Worker| p in w.workers and one workers.p","predicate":"inv2","isNewNode":true,"srcDstTED":9,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Workstation}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Worker}}', parent=all, position=0)\", \"(type='Move', tree='{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Worker}}', parent=some, position=0)\", \"(type='Move', tree='{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=some, position=1)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{one of{var1}{sig/Worker}}{in{var1/Worker}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}","totalTED":9,"challenge":"aTwuoJgesSd8hXXEP","time":41328800,"targetExpr":"(all x: Workstation| some w: Worker| w in x.workers) && (all w: Worker| one workers.w)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation | ws.workers != none && all w: ws.workers | w.workstation = ws } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{AND{!={.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{none}}{all{one of{var1}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{={.{var1/Worker}{field/workstation{set of{sig/Workstation}}}}{var0/Workstation}}}}}","nextExpr":"all w:Workstation | some w.workers all wo:Worker | one workers.wo","sourceExpr":"all ws: Workstation | ws.workers != none && all w: ws.workers | w.workstation = ws","predicate":"inv2","isNewNode":true,"srcDstTED":15,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{all{one of{var1}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{={.{var1/Worker}{field/workstation{set of{sig/Workstation}}}}{var0/Workstation}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Workstation}}', parent=all, position=0)\", \"(type='Update', node=!=, value=some)\", \"(type='Move', tree='{!={.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{none}}', parent=all, position=1)\", \"(type='Update', node==, value=one)\", \"(type='Move', tree='{sig/Worker}', parent=one of, position=1)\", \"(type='Update', node=field/workstation, value=field/workers)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\", \"(type='Delete', node=none)\", \"(type='Delete', node=var0/Workstation)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1/Worker)\", \"(type='Delete', node=var0/Workstation)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}","totalTED":15,"challenge":"aTwuoJgesSd8hXXEP","time":52585100,"targetExpr":"all w:Workstation | some w.workers all wo:Worker | one workers.wo","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | some a:Workstation | w in a.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Worker}}{some{one of{var1}{sig/Workstation}}{in{var0/Worker}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}","nextExpr":"all w : Workstation | some w.workers all w : Worker | (one work : Workstation | w in work.workers)","sourceExpr":"all w : Worker | some ws : Workstation | w in ws.workers","predicate":"inv2","isNewNode":false,"srcDstTED":12,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{one of{var1}{sig/Workstation}}{in{var0/Worker}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Worker}}{some{one of{var1}{sig/Workstation}}{in{var0/Worker}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}', parent=AND, position=1)\", \"(type='Update', node=some, value=one)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{one of{var1}{sig/Workstation}}{in{var0/Worker}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","totalTED":12,"challenge":"aTwuoJgesSd8hXXEP","time":104545200,"targetExpr":"all w : Workstation | some w.workers all w : Worker | (one work : Workstation | w in work.workers)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all a:Worker|(one w:Workstation | a in w.workers) all w:Workstation | some w.workers } pred inv3 { all c:Component | one workstation.c } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{one{.{field/workstation{set of{sig/Workstation}}}{var0/Component}}}}","nextExpr":"all x: Component | one x.workstation","sourceExpr":"all c:Component | one workstation.c","predicate":"inv3","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Component}}{one{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}","operations":"[\"(type='Insert', node=var0/Component, parent=., position=0)\", \"(type='Delete', node=var0/Component)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Component to correctly capture the property you want to specify. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{one{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}","totalTED":2,"challenge":"aTwuoJgesSd8hXXEP","time":111824100,"targetExpr":"all x: Component | one x.workstation","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Component | some Product.parts all c:Material | no Product.parts } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Component}}{some{.{sig/Product}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{sig/Product}{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c : Component | some c.parts all m : Material | no m.parts","sourceExpr":"all p:Component | some Product.parts all c:Material | no Product.parts","predicate":"inv4","isNewNode":true,"srcDstTED":2,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=sig/Product, value=var0/Component)\", \"(type='Update', node=sig/Product, value=var1/Material)\"]","hint":"Near a solution! Instead of using signature of type Product, try using variable of type Component to help satisfy the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}","totalTED":2,"challenge":"aTwuoJgesSd8hXXEP","time":118418900,"targetExpr":"all c : Component | some c.parts all m : Material | no m.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human or w in Robot } pred inv2 { all ws:Workstation | some w:Worker | w in ws.workers and (all wk:Worker | one ws1:Workstation | wk in ws1.workers) } pred inv3 { all c:Component | one ws:Workstation | ws in c.workstation } pred inv4 { all c:Component | some p:Product | p in c.parts and (all m:Material | all p:Product | p not in m.parts) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{sig/Product}}{AND{all{one of{var2}{sig/Material}}{all{one of{var1}{sig/Product}}{!in{var1/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all c: Component | some p : Product | p in c.parts all c: Material | no c.parts","sourceExpr":"all c:Component | some p:Product | p in c.parts and (all m:Material | all p:Product | p not in m.parts)","predicate":"inv4","isNewNode":true,"srcDstTED":19,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{one of{var1}{sig/Product}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}{all{one of{var0}{sig/Material}}{no{.{var0/Material}{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Move', tree='{AND{all{one of{var2}{sig/Material}}{all{one of{var1}{sig/Product}}{!in{var1/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}', parent=root, position=0)\", \"(type='Update', node=in, value=all)\", \"(type='Update', node=all, value=some)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Insert', node=no, parent=in, position=1)\", \"(type='Update', node=var2, value=var0)\", \"(type='Update', node=sig/Material, value=sig/Component)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=var1/Product, value=var0)\", \"(type='Move', tree='{var1/Product}', parent=one of, position=0)\", \"(type='Insert', node=sig/Material, parent=one of, position=1)\", \"(type='Move', tree='{.{var0/Component}{field/parts{set of{sig/Product}}}}', parent=no, position=0)\", \"(type='Update', node=var0/Component, value=var0/Material)\", \"(type='Update', node=var2/Material, value=var0/Component)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Component}}')\", \"(type='TreeDelete', tree='{one of{var1}{sig/Product}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the conjunction operator ('and') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{one of{var1}{sig/Product}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}{all{one of{var0}{sig/Material}}{no{.{var0/Material}{field/parts{set of{sig/Product}}}}}}}","totalTED":19,"challenge":"aTwuoJgesSd8hXXEP","time":61880600,"targetExpr":"all c: Component | some p : Product | p in c.parts all c: Material | no c.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | all m: Material | some c.parts && #m.parts = none } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Material}}{AND{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{none}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"(all c : Component | some c.parts) and (no Material.parts)","sourceExpr":"all c: Component | all m: Material | some c.parts && #m.parts = none","predicate":"inv4","isNewNode":true,"srcDstTED":13,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Update', node=some, value=no)\", \"(type='Move', tree='{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var1/Material}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Update', node=var0/Component, value=sig/Material)\", \"(type='Update', node=var1/Material, value=var0/Component)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Material}}')\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":13,"challenge":"aTwuoJgesSd8hXXEP","time":38880000,"targetExpr":"(all c : Component | some c.parts) and (no Material.parts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component, p: c.parts-(c+Dangerous) | all m: Material | p in c && #m.parts = none } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{-{.{var0/Component}{field/parts{set of{sig/Product}}}}{+{sig/Dangerous}{var0/Component}}}}{all{one of{var2}{sig/Material}}{AND{={#{.{var2/Material}{field/parts{set of{sig/Product}}}}}{none}}{in{var1/Product}{var0/Component}}}}}}","nextExpr":"all c: Component | c.parts != none all m: Material | m.parts = none","sourceExpr":"all c: Component, p: c.parts-(c+Dangerous) | all m: Material | p in c && #m.parts = none","predicate":"inv4","isNewNode":true,"srcDstTED":16,"targetAST":"{AND{all{one of{var0}{sig/Component}}{!={.{var0/Component}{field/parts{set of{sig/Product}}}}{none}}}{all{one of{var1}{sig/Material}}{={.{var1/Material}{field/parts{set of{sig/Product}}}}{none}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Material}}{AND{={#{.{var2/Material}{field/parts{set of{sig/Product}}}}}{none}}{in{var1/Product}{var0/Component}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Update', node=-, value=!=)\", \"(type='Move', tree='{-{.{var0/Component}{field/parts{set of{sig/Product}}}}{+{sig/Dangerous}{var0/Component}}}', parent=all, position=1)\", \"(type='Move', tree='{={#{.{var2/Material}{field/parts{set of{sig/Product}}}}}{none}}', parent=all, position=1)\", \"(type='Update', node=sig/Dangerous, value=none)\", \"(type='Move', tree='{sig/Dangerous}', parent=-, position=1)\", \"(type='Update', node=var2, value=var1)\", \"(type='Move', tree='{.{var2/Material}{field/parts{set of{sig/Product}}}}', parent==, position=0)\", \"(type='Update', node=var2/Material, value=var1/Material)\", \"(type='Delete', node=var0/Component)\", \"(type='Delete', node=+)\", \"(type='Delete', node=#)\", \"(type='TreeDelete', tree='{in{var1/Product}{var0/Component}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{!={.{var0/Component}{field/parts{set of{sig/Product}}}}{none}}}{all{one of{var1}{sig/Material}}{={.{var1/Material}{field/parts{set of{sig/Product}}}}{none}}}}","totalTED":16,"challenge":"aTwuoJgesSd8hXXEP","time":45941400,"targetExpr":"all c: Component | c.parts != none all m: Material | m.parts = none","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | #c.parts>0 && (all m: Material | no m.parts) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{AND{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all c: Component | #c.parts>0 all c :Material | no c.parts","sourceExpr":"all c: Component | #c.parts>0 && (all m: Material | no m.parts)","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{AND{all{one of{var0}{sig/Component}}{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}}{all{one of{var0}{sig/Material}}{no{.{var0/Material}{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Move', tree='{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}', parent=all, position=1)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=var1/Material, value=var0/Material)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}}{all{one of{var0}{sig/Material}}{no{.{var0/Material}{field/parts{set of{sig/Product}}}}}}}","totalTED":5,"challenge":"aTwuoJgesSd8hXXEP","time":40705500,"targetExpr":"all c: Component | #c.parts>0 all c :Material | no c.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts && (all m: Material | #m.parts = none ) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{AND{all{one of{var1}{sig/Material}}{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{none}}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}","nextExpr":"(all c : Component | some c.parts) and (no Material.parts)","sourceExpr":"all c: Component | some c.parts && (all m: Material | #m.parts = none )","predicate":"inv4","isNewNode":true,"srcDstTED":12,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Move', tree='{AND{all{one of{var1}{sig/Material}}{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{none}}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=no)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var1/Material}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=sig/Material, value=sig/Component)\", \"(type='Update', node=var0/Component, value=sig/Material)\", \"(type='Update', node=var1/Material, value=var0/Component)\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Component}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the conjunction operator ('and') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":12,"challenge":"aTwuoJgesSd8hXXEP","time":39088500,"targetExpr":"(all c : Component | some c.parts) and (no Material.parts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human or w in Robot } pred inv2 { all ws:Workstation | some w:Worker | w in ws.workers and (all wk:Worker | one ws1:Workstation | wk in ws1.workers) } pred inv3 { all c:Component | one ws:Workstation | ws in c.workstation } pred inv4 { all c:Component | some p:Product | p in c.parts and (all m:Material | all p1:Product | p1 not in m.parts) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{sig/Product}}{AND{all{one of{var2}{sig/Material}}{all{one of{var3}{sig/Product}}{!in{var3/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"(all c : Component | some c.parts) and (no Material.parts)","sourceExpr":"all c:Component | some p:Product | p in c.parts and (all m:Material | all p1:Product | p1 not in m.parts)","predicate":"inv4","isNewNode":true,"srcDstTED":20,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Move', tree='{AND{all{one of{var2}{sig/Material}}{all{one of{var3}{sig/Product}}{!in{var3/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}', parent=root, position=0)\", \"(type='Move', tree='{all{one of{var3}{sig/Product}}{!in{var3/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}', parent=AND, position=0)\", \"(type='Update', node=in, value=no)\", \"(type='Update', node=!in, value=some)\", \"(type='Update', node=var3, value=var0)\", \"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Update', node=var0/Component, value=sig/Material)\", \"(type='Update', node=var2/Material, value=var0/Component)\", \"(type='Delete', node=var3/Product)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Material}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=var1/Product)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Component}}')\", \"(type='TreeDelete', tree='{one of{var1}{sig/Product}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the conjunction operator ('and') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":20,"challenge":"aTwuoJgesSd8hXXEP","time":39408700,"targetExpr":"(all c : Component | some c.parts) and (no Material.parts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component, m: Material | #c.parts>0 && no m.parts } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Material}}{AND{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"(all c : Component | some c.parts) and (no Material.parts)","sourceExpr":"all c: Component, m: Material| #c.parts >0 and no m.parts","predicate":"inv4","isNewNode":false,"srcDstTED":11,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Update', node=var1/Material, value=sig/Material)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Material}}')\", \"(type='Delete', node=0)\", \"(type='Delete', node=>)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":11,"challenge":"aTwuoJgesSd8hXXEP","time":238096000,"targetExpr":"(all c : Component | some c.parts) and (no Material.parts)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all p: Product, c: Component | p.parts in c && (all m: Material | #m.parts = none) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Product}}{all{one of{var1}{sig/Component}}{AND{all{one of{var2}{sig/Material}}{={#{.{var2/Material}{field/parts{set of{sig/Product}}}}}{none}}}{in{.{var0/Product}{field/parts{set of{sig/Product}}}}{var1/Component}}}}}","nextExpr":"(all c : Component | some c.parts) and (no Material.parts)","sourceExpr":"all p: Product, c: Component | p.parts in c && (all m: Material | #m.parts = none)","predicate":"inv4","isNewNode":true,"srcDstTED":17,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Move', tree='{AND{all{one of{var2}{sig/Material}}{={#{.{var2/Material}{field/parts{set of{sig/Product}}}}}{none}}}{in{.{var0/Product}{field/parts{set of{sig/Product}}}}{var1/Component}}}', parent=root, position=0)\", \"(type='Update', node=in, value=no)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var2/Material}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Update', node=var2, value=var0)\", \"(type='Update', node=sig/Material, value=sig/Component)\", \"(type='Update', node=var0/Product, value=sig/Material)\", \"(type='Update', node=var2/Material, value=var0/Component)\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\", \"(type='Delete', node=var1/Component)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Product}}')\", \"(type='TreeDelete', tree='{one of{var1}{sig/Component}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the conjunction operator ('and') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":17,"challenge":"aTwuoJgesSd8hXXEP","time":35298100,"targetExpr":"(all c : Component | some c.parts) and (no Material.parts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | #c.parts>0 all m: Material | #m.parts = none } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Component}}{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}}{all{one of{var1}{sig/Material}}{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{none}}}}","nextExpr":"all c: Component | #(c.parts) > 0 all m: Material | #(m.parts) = 0","sourceExpr":"all c: Component | #c.parts>0 all m: Material | #m.parts = none","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{AND{all{one of{var0}{sig/Component}}{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}}{all{one of{var1}{sig/Material}}{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{0}}}}","operations":"[\"(type='Update', node=none, value=0)\"]","hint":"One step away from the solution! Instead of using empty set constructor ('none') to specify that a set is empty, try using 0 to help satisfy the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}}{all{one of{var1}{sig/Material}}{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{0}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":34034500,"targetExpr":"all c: Component | #(c.parts) > 0 all m: Material | #(m.parts) = 0","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts && (all m: Material | no m.parts) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{AND{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c: Component | some c.parts all m: Material | no m.parts","sourceExpr":"all x: Component | some (x.parts) && all y: Material | no (y.parts)","predicate":"inv4","isNewNode":false,"srcDstTED":14,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Move', tree='{AND{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}', parent=root, position=0)\", \"(type='Update', node=var1/Material, value=all)\", \"(type='Move', tree='{var1/Material}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Update', node=set of, value=one of)\", \"(type='Move', tree='{set of{sig/Product}}', parent=var1/Material, position=0)\", \"(type='Update', node=one of, value=some)\", \"(type='Move', tree='{one of{var1}{sig/Material}}', parent=var1/Material, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Material}}', parent=all, position=0)\", \"(type='Update', node=all, value=no)\", \"(type='Move', tree='{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}', parent=all, position=1)\", \"(type='Update', node=var0/Component, value=var0)\", \"(type='Move', tree='{var0/Component}', parent=set of, position=0)\", \"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Update', node=sig/Material, value=.)\", \"(type='Update', node=no, value=.)\", \"(type='Update', node=field/parts, value=var0/Component)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=sig/Material, position=0)\", \"(type='Update', node=var1, value=field/parts)\", \"(type='Move', tree='{var1}', parent=sig/Material, position=1)\", \"(type='Update', node=sig/Product, value=var1/Material)\", \"(type='Move', tree='{sig/Product}', parent=no, position=0)\", \"(type='Update', node=., value=field/parts)\", \"(type='Update', node=some, value=set of)\", \"(type='Move', tree='{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}', parent=var1, position=0)\", \"(type='Update', node=field/parts, value=set of)\", \"(type='Update', node=., value=sig/Product)\", \"(type='Update', node=set of, value=sig/Product)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Component}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the conjunction operator ('and') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}","totalTED":14,"challenge":"aTwuoJgesSd8hXXEP","time":57653500,"targetExpr":"all c: Component | some c.parts all m: Material | no m.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | all m: Material | #c.parts>0 && #m.parts = none } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Material}}{AND{={#{.{var1/Material}{field/parts{set of{sig/Product}}}}}{none}}{>{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}{0}}}}}","nextExpr":"(all c : Component | some c.parts) and (no Material.parts)","sourceExpr":"all c: Component | all m: Material | #c.parts>0 && #m.parts = none","predicate":"inv4","isNewNode":true,"srcDstTED":15,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Update', node=#, value=no)\", \"(type='Move', tree='{#{.{var0/Component}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Update', node=#, value=some)\", \"(type='Move', tree='{#{.{var1/Material}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Update', node=var0/Component, value=sig/Material)\", \"(type='Update', node=var1/Material, value=var0/Component)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Material}}')\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\", \"(type='Delete', node=0)\", \"(type='Delete', node=>)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":15,"challenge":"aTwuoJgesSd8hXXEP","time":41775600,"targetExpr":"(all c : Component | some c.parts) and (no Material.parts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w:Workstation,w1:w.workers|w1 =Human +Robot } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{={+{sig/Human}{sig/Robot}}{var1/Worker}}}}","nextExpr":"all ws : Workstation | ws.workers in Human || ws.workers in Robot","sourceExpr":"all w:Workstation,w1:w.workers|w1 =Human +Robot","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","operations":"[\"(type='Update', node=all, value=OR)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=sig/Human, parent=one of, position=2)\", \"(type='Update', node=+, value=.)\", \"(type='Update', node=var1/Worker, value=sig/Robot)\", \"(type='Update', node=sig/Human, value=var0/Workstation)\", \"(type='Insert', node=field/workers, parent=+, position=1)\", \"(type='Insert', node=set of, parent=field/workers, position=0)\", \"(type='Update', node=sig/Robot, value=sig/Worker)\", \"(type='Move', tree='{sig/Robot}', parent=set of, position=0)\", \"(type='Delete', node=var1)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","totalTED":11,"challenge":"aTwuoJgesSd8hXXEP","time":122664200,"targetExpr":"all ws : Workstation | ws.workers in Human || ws.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all a:Worker|(one w:Workstation | a in w.workers) all w:Workstation | some w.workers } pred inv3 { all c:Component | #c.workstation=1 } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { all w:Workstation | Human in w.workers implies Robot not in w.workers } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{=>{in{sig/Human}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{sig/Robot}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}","nextExpr":"all w : Workstation | w.workers in Human or w.workers in Robot","sourceExpr":"all w:Workstation | Human in w.workers implies Robot not in w.workers","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","operations":"[\"(type='Update', node==>, value=OR)\", \"(type='Update', node=!in, value=in)\", \"(type='Insert', node=sig/Human, parent=in, position=2)\", \"(type='Insert', node=sig/Robot, parent=!in, position=2)\", \"(type='Delete', node=sig/Human)\", \"(type='Delete', node=sig/Robot)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","totalTED":6,"challenge":"aTwuoJgesSd8hXXEP","time":64054800,"targetExpr":"all w : Workstation | w.workers in Human or w.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all a:Worker|(one w:Workstation | a in w.workers) all w:Workstation | some w.workers } pred inv3 { all c:Component | #c.workstation=1 } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { all w:Workstation | (Human.workers + Robot.workers) in w } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{in{+{.{sig/Human}{field/workers{set of{sig/Worker}}}}{.{sig/Robot}{field/workers{set of{sig/Worker}}}}}{var0/Workstation}}}","nextExpr":"all ws : Workstation | ws.workers in Human || ws.workers in Robot","sourceExpr":"all w:Workstation | (Human.workers + Robot.workers) in w","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","operations":"[\"(type='Update', node=in, value=OR)\", \"(type='Insert', node=in, parent=in, position=0)\", \"(type='Insert', node=in, parent=in, position=1)\", \"(type='Move', tree='{.{sig/Human}{field/workers{set of{sig/Worker}}}}', parent=in, position=0)\", \"(type='Insert', node=sig/Human, parent=in, position=1)\", \"(type='Move', tree='{.{sig/Robot}{field/workers{set of{sig/Worker}}}}', parent=in, position=0)\", \"(type='Update', node=var0/Workstation, value=sig/Robot)\", \"(type='Move', tree='{var0/Workstation}', parent=in, position=1)\", \"(type='Update', node=sig/Human, value=var0/Workstation)\", \"(type='Update', node=sig/Robot, value=var0/Workstation)\", \"(type='Delete', node=+)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","totalTED":8,"challenge":"aTwuoJgesSd8hXXEP","time":43921900,"targetExpr":"all ws : Workstation | ws.workers in Human || ws.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human or w in Robot } pred inv2 { all ws: Workstation, w: Worker | some ws.workers && one w.~workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | #c.parts>0 all m: Material | #m.parts = 0 } pred inv5 { all h: Human, r:Robot | h.~workers != r.workers } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{!={.{var0/Human}{~{field/workers{set of{sig/Worker}}}}}{.{var1/Robot}{field/workers{set of{sig/Worker}}}}}}}","nextExpr":"all x:Human, y:Robot | no workers.x & workers.y","sourceExpr":"all h: Human, r:Robot | h.~workers != r.workers","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{field/workers{set of{sig/Worker}}}{var0/Human}}{.{field/workers{set of{sig/Worker}}}{var1/Robot}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=!=, value=&)\", \"(type='Move', tree='{!={.{var0/Human}{~{field/workers{set of{sig/Worker}}}}}{.{var1/Robot}{field/workers{set of{sig/Worker}}}}}', parent=no, position=0)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=0)\", \"(type='Insert', node=var0/Human, parent=., position=1)\", \"(type='Insert', node=var1/Robot, parent=., position=2)\", \"(type='Delete', node=var0/Human)\", \"(type='Delete', node=~)\", \"(type='Delete', node=var1/Robot)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{field/workers{set of{sig/Worker}}}{var0/Human}}{.{field/workers{set of{sig/Worker}}}{var1/Robot}}}}}}","totalTED":7,"challenge":"aTwuoJgesSd8hXXEP","time":43172200,"targetExpr":"all x:Human, y:Robot | no workers.x & workers.y","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { (all w: Workstation| some p: Worker| p in w.workers) && (all p: Worker| one workers.p) } pred inv3 { all c: Component| one c.workstation } pred inv4 { (all c: Component| some c.parts) && (all m: Material| no m.parts) } pred inv5 { all w: Workstation| all h: Human| some r: Robot| h in w.workers => r not in w.workers } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Human}}{some{one of{var2}{sig/Robot}}{=>{in{var1/Human}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{var2/Robot}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","nextExpr":"all ws : Workstation, h : Human, r : Robot | h in ws.workers implies r not in ws.workers","sourceExpr":"all w: Workstation| all h: Human| some r: Robot| h in w.workers => r not in w.workers","predicate":"inv5","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Human}}{all{one of{var2}{sig/Robot}}{=>{in{var1/Human}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{var2/Robot}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Human}}{all{one of{var2}{sig/Robot}}{=>{in{var1/Human}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{var2/Robot}{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":33306900,"targetExpr":"all ws : Workstation, h : Human, r : Robot | h in ws.workers implies r not in ws.workers","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human or w in Robot } pred inv2 { all ws:Workstation | some w:Worker | w in ws.workers and (all wk:Worker | one ws1:Workstation | wk in ws1.workers) } pred inv3 { all c:Component | one ws:Workstation | ws in c.workstation } pred inv4 { (all c:Component | some p:Product | p in c.parts) and (all m:Material | all p:Product | p not in m.parts) } pred inv5 { all h:Human, r:Robot, ws:Workstation | h in ws.workers implies r not in ws.workers } pred inv6 { all c1,c2 : Component | c2 in c1.parts implies c1!=c2 } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Component}}{=>{in{var1/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{!={var0/Component}{var1/Component}}}}}","nextExpr":"all c1, c2: Component | c2 in c1.^parts implies c2 != c1","sourceExpr":"all x1,x2 : Component | x2 in x1.parts implies x2 != x1","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Component}}{=>{in{var1/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{!={var0/Component}{var1/Component}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Component}}{=>{in{var1/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{!={var0/Component}{var1/Component}}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":102368400,"targetExpr":"all c1, c2: Component | c2 in c1.^parts implies c2 != c1","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all a:Worker|(one w:Workstation | a in w.workers) all w:Workstation | some w.workers } pred inv3 { all c:Component | #c.workstation=1 } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { all w:Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Component| not c in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{!{in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c: Component | not c in c.^parts","sourceExpr":"all c: Component | not c in c.parts","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{!{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{!{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":49602400,"targetExpr":"all c: Component | not c in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human or w in Robot } pred inv2 { all ws:Workstation | some w:Worker | w in ws.workers and (all wk:Worker | one ws1:Workstation | wk in ws1.workers) } pred inv3 { all c:Component | one ws:Workstation | ws in c.workstation } pred inv4 { (all c:Component | some p:Product | p in c.parts) and (all m:Material | all p:Product | p not in m.parts) } pred inv5 { all h:Human, r:Robot, ws:Workstation | h in ws.workers implies r not in ws.workers } pred inv6 { all c1, c2 : Component | c2 in c1.parts <=> c2!=c1 } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Component}}{<=>{!={var0/Component}{var1/Component}}{in{var1/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all c : Component | c not in c.parts","sourceExpr":"all c,e : Component | e in c.parts iff e!=c","predicate":"inv6","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=<=>, value=!in)\", \"(type='Move', tree='{<=>{!={var0/Component}{var1/Component}}{in{var1/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}', parent=all, position=1)\", \"(type='Move', tree='{var0/Component}', parent=<=>, position=0)\", \"(type='Move', tree='{.{var0/Component}{field/parts{set of{sig/Product}}}}', parent=<=>, position=1)\", \"(type='Delete', node=var1/Component)\", \"(type='Delete', node=!=)\", \"(type='Delete', node=var1/Component)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Component}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","totalTED":10,"challenge":"aTwuoJgesSd8hXXEP","time":49671000,"targetExpr":"all c: Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human or w in Robot } pred inv2 { all ws:Workstation | some w:Worker | w in ws.workers and (all wk:Worker | one ws1:Workstation | wk in ws1.workers) } pred inv3 { all c:Component | one ws:Workstation | ws in c.workstation } pred inv4 { (all c:Component | some p:Product | p in c.parts) and (all m:Material | all p:Product | p not in m.parts) } pred inv5 { all h:Human, r:Robot, ws:Workstation | h in ws.workers implies r not in ws.workers } pred inv6 { all c1,c2 : Component | c2 in c1.parts and c1!=c2 } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Component}}{AND{!={var0/Component}{var1/Component}}{in{var1/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all c:Component, p:Product | not c in c.^parts","sourceExpr":"all c:Component, c1:Component | c1 in c.parts and c!=c1","predicate":"inv6","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Product}}{!{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=!)\", \"(type='Update', node=sig/Component, value=sig/Product)\", \"(type='Update', node=var1/Component, value=var0/Component)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\", \"(type='TreeDelete', tree='{!={var0/Component}{var1/Component}}')\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using negation operator ('!') to specify that the expression is false.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Product}}{!{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}}}","totalTED":7,"challenge":"aTwuoJgesSd8hXXEP","time":84954200,"targetExpr":"all c:Component, p:Product | not c in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies c not in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Component}}{!in{var0/Product}{.{var0/Product}{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all p : Product | p in Component implies p not in p.^parts","sourceExpr":"all p : Product | p in Component implies p not in p.parts","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Component}}{!in{var0/Product}{.{var0/Product}{^{field/parts{set of{sig/Product}}}}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Component}}{!in{var0/Product}{.{var0/Product}{^{field/parts{set of{sig/Product}}}}}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":47974900,"targetExpr":"all p : Product | p in Component implies p not in p.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all a:Worker|(one w:Workstation | a in w.workers) all w:Workstation | some w.workers } pred inv3 { all c:Component | #c.workstation=1 } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { all w:Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Component| c not in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all c : Component | c not in c.^parts","sourceExpr":"all c : Component | c not in c.parts","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":43273700,"targetExpr":"all c : Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Component}}{!{in{var0/Product}{.{var0/Product}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all p : Product | p in Component implies p not in p.^parts","sourceExpr":"all c:Product | c in Component implies not c in c.parts","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Component}}{!in{var0/Product}{.{var0/Product}{^{field/parts{set of{sig/Product}}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{var0/Product}{.{var0/Product}{field/parts{set of{sig/Product}}}}}', parent==>, position=1)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\", \"(type='Delete', node=!)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Component}}{!in{var0/Product}{.{var0/Product}{^{field/parts{set of{sig/Product}}}}}}}}","totalTED":3,"challenge":"aTwuoJgesSd8hXXEP","time":74912400,"targetExpr":"all p : Product | p in Component implies p not in p.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.^parts } pred inv7 { all c:Component | some p:c.parts | p in Dangerous implies c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","nextExpr":"all c: Component | some p: c.^parts | p in Dangerous implies c in Dangerous","sourceExpr":"all c: Component | some p: c.parts | p in Dangerous implies c in Dangerous","predicate":"inv7","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"Near a solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":2,"challenge":"aTwuoJgesSd8hXXEP","time":107450500,"targetExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { (all w: Workstation| some p: Worker| p in w.workers) && (all p: Worker| one workers.p) } pred inv3 { all c: Component| one c.workstation } pred inv4 { (all c: Component| some c.parts) && (all m: Material| no m.parts) } pred inv5 { all w: Workstation| all h: Human| all r: Robot| h in w.workers => r not in w.workers } pred inv6 { all c: Component| c not in c.^(parts) } pred inv7 { all c: Component| some d: c.parts| d in Dangerous => c.parts in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}}}","nextExpr":"all c: Component | all x: c.parts | x in Dangerous => c in Dangerous","sourceExpr":"all c: Component| some d: c.parts| d in Dangerous => c.parts in Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{var0/Component}', parent=in, position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":5,"challenge":"aTwuoJgesSd8hXXEP","time":105712300,"targetExpr":"all c: Component | all x: c.parts | x in Dangerous => c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.^parts } pred inv7 { all c:Component | some p:c.^parts | Dangerous in p implies Dangerous in c } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{sig/Dangerous}{var1/Product}}{in{sig/Dangerous}{var0/Component}}}}}","nextExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","sourceExpr":"all c:Component | some p:c.^parts | Dangerous in p implies Dangerous in c","predicate":"inv7","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=var1/Product, parent=in, position=0)\", \"(type='Insert', node=var0/Component, parent=in, position=0)\", \"(type='Delete', node=var1/Product)\", \"(type='Delete', node=var0/Component)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":5,"challenge":"aTwuoJgesSd8hXXEP","time":34377500,"targetExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.^parts } pred inv7 { all c:Component | some p:c.^parts | Dangerous in p implies c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{sig/Dangerous}{var1/Product}}{in{var0/Component}{sig/Dangerous}}}}}","nextExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","sourceExpr":"all c:Component | some p:c.^parts | Dangerous in p implies c in Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=var1/Product, parent=in, position=0)\", \"(type='Delete', node=var1/Product)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":3,"challenge":"aTwuoJgesSd8hXXEP","time":35381200,"targetExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.^parts } pred inv7 { all c:Component | some p:c.^parts | Dangerous in p implies some (c & Dangerous & Component) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{sig/Dangerous}{var1/Product}}{some{&{&{sig/Dangerous}{var0/Component}}{sig/Component}}}}}}","nextExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","sourceExpr":"all c:Component | some p:c.^parts | Dangerous in p implies some (c & Dangerous & Component)","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{&{sig/Dangerous}{var0/Component}}{sig/Component}}', parent==>, position=1)\", \"(type='Insert', node=var1/Product, parent=in, position=0)\", \"(type='Move', tree='{var0/Component}', parent=&, position=0)\", \"(type='Update', node=sig/Component, value=sig/Dangerous)\", \"(type='Delete', node=var1/Product)\", \"(type='Delete', node=sig/Dangerous)\", \"(type='Delete', node=&)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":8,"challenge":"aTwuoJgesSd8hXXEP","time":36893600,"targetExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w: Workstation | some w.workers all w: Worker | (one work : Workstation | w in work.workers) } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all c: Material | no c.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c: Component | not c in c.^parts } pred inv7 { all c: Component | Dangerous in c.^parts implies some (c & Dangerous & Component) } pred inv8 { all c: Component & Dangerous | all x : c.workstation | no (x.workers & Human) } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{=>{in{sig/Dangerous}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{some{&{&{sig/Dangerous}{var0/Component}}{sig/Component}}}}}","nextExpr":"all c : Component | Dangerous in c.^parts implies c in Dangerous","sourceExpr":"all c: Component | Dangerous in c.^parts implies some (c & Dangerous & Component)","predicate":"inv7","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","operations":"[\"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{&{sig/Dangerous}{var0/Component}}{sig/Component}}', parent==>, position=1)\", \"(type='Move', tree='{var0/Component}', parent=&, position=0)\", \"(type='Update', node=sig/Component, value=sig/Dangerous)\", \"(type='Delete', node=sig/Dangerous)\", \"(type='Delete', node=&)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using intersection operator ('&') to find the common elements between two sets, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Component}}{=>{in{sig/Dangerous}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{in{var0/Component}{sig/Dangerous}}}}","totalTED":9,"challenge":"aTwuoJgesSd8hXXEP","time":55831400,"targetExpr":"all x: Component | some (x.^parts & Dangerous) implies x in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.^parts } pred inv7 { all c:Component | some p:c.^parts | p in Dangerous implies c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","nextExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","sourceExpr":"all c: Component | some p: c.^parts | p in Dangerous implies c in Dangerous","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}{=>{in{var1/Product}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":1,"challenge":"aTwuoJgesSd8hXXEP","time":46993800,"targetExpr":"all c:Component| all p: c.^parts| p in Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human or w in Robot } pred inv2 { all ws:Workstation | some w:Worker | w in ws.workers and (all wk:Worker | one ws1:Workstation | wk in ws1.workers) } pred inv3 { all c:Component | one ws:Workstation | ws in c.workstation } pred inv4 { (all c:Component | some p:Product | p in c.parts) and (all m:Material | all p:Product | p not in m.parts) } pred inv5 { all h:Human, r:Robot, ws:Workstation | h in ws.workers implies r not in ws.workers } pred inv6 { all c:Component | c not in c.^(parts) } pred inv7 { all p:Product, c:Component | p in c.parts and p in Dangerous implies c in Dangerous } pred inv8 { all d:Dangerous, h:Human, ws:Workstation | ws in d.workstation implies ws not in h.workstation } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Dangerous}}{all{one of{var1}{sig/Human}}{all{one of{var2}{sig/Workstation}}{=>{in{var2/Workstation}{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}}{!in{var2/Workstation}{.{var1/Human}{field/workstation{set of{sig/Workstation}}}}}}}}}","nextExpr":"all c:Component, h:Human, ws:Workstation | c in Dangerous and ws in c.workstation implies (h not in ws.workers)","sourceExpr":"all d:Dangerous, h:Human, ws:Workstation | ws in d.workstation implies ws not in h.workstation","predicate":"inv8","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Human}}{all{one of{var2}{sig/Workstation}}{=>{AND{in{var0/Component}{sig/Dangerous}}{in{var2/Workstation}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}{!in{var1/Human}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","operations":"[\"(type='Update', node=sig/Dangerous, value=sig/Component)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Component}{sig/Dangerous}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var2/Workstation}{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Workstation, value=var1/Human)\", \"(type='Update', node=var1/Human, value=var2/Workstation)\", \"(type='Update', node=field/workstation, value=field/workers)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\"]","hint":"Keep going! Instead of using signature of type Dangerous, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Human}}{all{one of{var2}{sig/Workstation}}{=>{AND{in{var0/Component}{sig/Dangerous}}{in{var2/Workstation}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}{!in{var1/Human}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","totalTED":10,"challenge":"aTwuoJgesSd8hXXEP","time":114575000,"targetExpr":"all c:Component, h:Human, ws:Workstation | c in Dangerous and ws in c.workstation implies (h not in ws.workers)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all a:Worker|(one w:Workstation | a in w.workers) all w:Workstation | some w.workers } pred inv3 { all c:Component | #c.workstation=1 } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { all w:Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Component| not c in c.^parts } pred inv7 { all c:Component | all p:c.parts| p in Dangerous implies c in Dangerous } pred inv8 { all c:Component|all w:c.workstation |c in Dangerous implies Human not in w.workers } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}{=>{in{var0/Component}{sig/Dangerous}}{!in{sig/Human}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all c: Component| all x : c.workstation | c in Dangerous => no (x.workers & Human)","sourceExpr":"all c:Component|all w:c.workstation |c in Dangerous implies Human not in w.workers","predicate":"inv8","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}{=>{in{var0/Component}{sig/Dangerous}}{no{&{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}}","operations":"[\"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{sig/Human}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=no, position=0)\", \"(type='Insert', node=sig/Human, parent=!in, position=2)\", \"(type='Delete', node=sig/Human)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}{=>{in{var0/Component}{sig/Dangerous}}{no{&{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}}","totalTED":4,"challenge":"aTwuoJgesSd8hXXEP","time":39879700,"targetExpr":"all c: Component| all x : c.workstation | c in Dangerous => no (x.workers & Human)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Workstation | some w.workers all w:Worker | one workers.w } pred inv3 { all c:Component | one c.workstation } pred inv4 { all p:Product | p in Component implies some p.parts all p:Product | p in Material implies no p.parts } pred inv5 { all w: Workstation | no (w.workers & Robot) or no (w.workers & Human) } pred inv6 { all c:Product | c in Component implies not c in c.^parts } pred inv7 { all c:Component, p:c.parts | p in Dangerous implies c in Dangerous } pred inv8 { all c:Product | c in Dangerous implies no (c.workers & Human) } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Product}}{=>{in{var0/Product}{sig/Dangerous}}{no{&{.{var0/Product}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}","nextExpr":"all c : Component | c in Dangerous => no (c.workstation.workers & Human)","sourceExpr":"all c:Product | c in Dangerous implies no (c.workers & Human)","predicate":"inv8","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{sig/Dangerous}}{no{&{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}","operations":"[\"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Move', tree='{var0/Product}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using signature of type Product, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{sig/Dangerous}}{no{&{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}","totalTED":7,"challenge":"aTwuoJgesSd8hXXEP","time":35623800,"targetExpr":"all c : Component | c in Dangerous => no (c.workstation.workers & Human)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { (all w: Workstation| some p: Worker| p in w.workers) && (all p: Worker| one workers.p) } pred inv3 { all c: Component| one c.workstation } pred inv4 { (all c: Component| some c.parts) && (all m: Material| no m.parts) } pred inv5 { all w: Workstation| all h: Human| all r: Robot| h in w.workers => r not in w.workers } pred inv6 { all c: Component| c not in c.^(parts) } pred inv7 { all c: Component| all d: c.parts| d in Dangerous => c in Dangerous } pred inv8 { all c: Component & Dangerous| all s: c.workstation| no (s.workers & Human) } pred inv9 { all w: Workstation| one w.^(succ) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{one{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all w : Workstation - end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w : Workstation | one w.^succ","predicate":"inv9","isNewNode":false,"srcDstTED":18,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Workstation}}{one{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}', parent=AND, position=1)\", \"(type='TreeInsert', tree='{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}', parent=AND, position=2)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=-, position=0)\", \"(type='Insert', node=sig/end, parent=-, position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":18,"challenge":"aTwuoJgesSd8hXXEP","time":125533200,"targetExpr":"all w : Workstation - end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { (all w: Workstation| some p: Worker| p in w.workers) && (all p: Worker| one workers.p) } pred inv3 { all c: Component| one c.workstation } pred inv4 { (all c: Component| some c.parts) && (all m: Material| no m.parts) } pred inv5 { all w: Workstation| all h: Human| all r: Robot| h in w.workers => r not in w.workers } pred inv6 { all c: Component| c not in c.^(parts) } pred inv7 { all c: Component| all d: c.parts| d in Dangerous => c in Dangerous } pred inv8 { all c: Component & Dangerous| all s: c.workstation| no (s.workers & Human) } pred inv9 { all w, wb: Workstation|(wb in begin and w!=wb) implies w in wb.^(succ) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Workstation}}{=>{AND{!={var0/Workstation}{var1/Workstation}}{in{var1/Workstation}{sig/begin}}}{in{var0/Workstation}{.{var1/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}}}","nextExpr":"all w,wb:Workstation | (wb in begin and wb!=w) implies w in wb.^(succ) all w: Workstation | w not in w.^(succ) all w: Workstation | w not in end implies one w.succ","sourceExpr":"all w,wb:Workstation | (wb in begin and wb!=w) implies w in wb.^(succ)","predicate":"inv9","isNewNode":false,"srcDstTED":27,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Workstation}}{=>{AND{!={var0/Workstation}{var1/Workstation}}{in{var1/Workstation}{sig/begin}}}{in{var0/Workstation}{.{var1/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}}}{all{one of{var0}{sig/Workstation}}{!in{var0/Workstation}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}{all{one of{var0}{sig/Workstation}}{=>{!in{var0/Workstation}{sig/end}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Workstation}}{=>{AND{!={var0/Workstation}{var1/Workstation}}{in{var1/Workstation}{sig/begin}}}{in{var0/Workstation}{.{var1/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Workstation}}{!in{var0/Workstation}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}', parent=AND, position=1)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Workstation}}{=>{!in{var0/Workstation}{sig/end}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}}', parent=AND, position=2)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Workstation}}{=>{AND{!={var0/Workstation}{var1/Workstation}}{in{var1/Workstation}{sig/begin}}}{in{var0/Workstation}{.{var1/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}}}{all{one of{var0}{sig/Workstation}}{!in{var0/Workstation}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}{all{one of{var0}{sig/Workstation}}{=>{!in{var0/Workstation}{sig/end}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}}}","totalTED":27,"challenge":"aTwuoJgesSd8hXXEP","time":54795600,"targetExpr":"all w,wb:Workstation | (wb in begin and wb!=w) implies w in wb.^(succ) all w: Workstation | w not in w.^(succ) all w: Workstation | w not in end implies one w.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker| w in Human or w in Robot } pred inv2 { (all w: Workstation| some p: Worker| p in w.workers) && (all p: Worker| one workers.p) } pred inv3 { all c: Component| one c.workstation } pred inv4 { (all c: Component| some c.parts) && (all m: Material| no m.parts) } pred inv5 { all w: Workstation| all h: Human| all r: Robot| h in w.workers => r not in w.workers } pred inv6 { all c: Component| c not in c.^(parts) } pred inv7 { all c: Component| all d: c.parts| d in Dangerous => c in Dangerous } pred inv8 { all c: Component & Dangerous| all s: c.workstation| no (s.workers & Human) } pred inv9 { all w: Workstation| one w.*(succ) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{one{.{var0/Workstation}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all w : Workstation - end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w: Workstation| one w.*(succ)","predicate":"inv9","isNewNode":true,"srcDstTED":18,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Workstation}}{one{.{var0/Workstation}{*{field/succ{set of{sig/Workstation}}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}', parent=AND, position=1)\", \"(type='TreeInsert', tree='{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}', parent=AND, position=2)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=-, position=0)\", \"(type='Insert', node=sig/end, parent=-, position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":18,"challenge":"aTwuoJgesSd8hXXEP","time":72243800,"targetExpr":"all w : Workstation - end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w : univ | w in (Human + Robot) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{univ}}{in{var0/univ}{+{sig/Human}{sig/Robot}}}}","nextExpr":"all w:Worker | w in (Human + Robot)","sourceExpr":"all w : univ | w in (Human + Robot)","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Worker}}{in{var0/Worker}{+{sig/Human}{sig/Robot}}}}","operations":"[\"(type='Update', node=univ, value=sig/Worker)\", \"(type='Update', node=var0/univ, value=var0/Worker)\"]","hint":"Near a solution! Instead of using universal quantifier ('univ') to specify that all elements in a set satisfy a condition, try using signature of type Worker to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Worker}}{in{var0/Worker}{+{sig/Human}{sig/Robot}}}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":110143000,"targetExpr":"all w:Worker | w in (Human + Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (c.^parts & Component).workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in (c.^parts & Component).workstation.^succ","predicate":"inv10","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='TreeDelete', tree='{^{field/parts{set of{sig/Product}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":12,"challenge":"bNCCf9FMRZoxqobfX","time":117701200,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (c.parts & Component).workstation.*succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in (c.parts & Component).workstation.*succ","predicate":"inv10","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=*, value=^)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":12,"challenge":"bNCCf9FMRZoxqobfX","time":43268300,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in c.parts.workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component | all p: c.parts | c.workstation in p.workstation.^succ","sourceExpr":"all c: Component | c.workstation in c.parts.workstation.^succ","predicate":"inv10","isNewNode":false,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{-{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Material}}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Update', node=in, value=all)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Update', node=., value=in)\", \"(type='Insert', node=var1, parent=one of, position=0)\", \"(type='Move', tree='{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}', parent=one of, position=1)\", \"(type='Move', tree='{.{var0/Component}{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=field/workstation, value=field/parts)\", \"(type='Update', node=field/parts, value=field/workstation)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Move', tree='{^{field/succ{set of{sig/Workstation}}}}', parent=., position=1)\", \"(type='Insert', node=var1/Product, parent=., position=0)\", \"(type='Move', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Update', node=sig/Workstation, value=sig/Product)\", \"(type='Update', node=sig/Product, value=sig/Workstation)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}}","totalTED":14,"challenge":"bNCCf9FMRZoxqobfX","time":100313900,"targetExpr":"all c : Component, p : c.parts-Material | c.workstation in p.workstation.^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | (p.parts & Component).workstation in ~succ.(p.workstation) }","sourceAST":"{all{one of{var0}{sig/Product}}{in{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{~{field/succ{set of{sig/Workstation}}}}{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}}}}","nextExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","sourceExpr":"all p:Product | (p.parts & Component).workstation in ~succ.(p.workstation)","predicate":"inv10","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Move', tree='{.{var0/Product}{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Update', node=~, value=^)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Instead of using signature of type Product, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":37367100,"targetExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (c.parts & Component).workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c : Component | c.workstation in (c.parts & Component).workstation.^succ","predicate":"inv10","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":64361600,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all c: Component | c.^parts in end }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/end}}}","nextExpr":"all c:Component | c.^parts.workstation in ^succ.(c.workstation)","sourceExpr":"all c: Component | c.^parts in end","predicate":"inv10","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='TreeInsert', tree='{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='Move', tree='{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}', parent=., position=0)\", \"(type='Insert', node=field/workstation, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/workstation, position=0)\", \"(type='Update', node=sig/end, value=sig/Workstation)\", \"(type='Move', tree='{sig/end}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":14,"challenge":"bNCCf9FMRZoxqobfX","time":34467100,"targetExpr":"all c:Component | c.^parts.workstation in ^succ.(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | (c.workstation) in c.parts.workstation.*succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | (c.workstation) in c.parts.workstation.*succ","predicate":"inv10","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=*, value=^)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":36079300,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in Component.parts.workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{.{sig/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in Component.parts.workstation.^succ","predicate":"inv10","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Update', node=sig/Component, value=var0/Component)\", \"(type='Move', tree='{sig/Component}', parent=., position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":36741200,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | (p.workstation) in ((p.parts & Component).workstation).*succ }","sourceAST":"{all{one of{var0}{sig/Product}}{in{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all x : Component | no (x.parts & Component).workstation & (x.workstation).*succ","sourceExpr":"all p:Product | (p.workstation) in ((p.parts & Component).workstation).*succ","predicate":"inv10","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Component}}{no{&{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Update', node=in, value=no)\", \"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Update', node=., value=&)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='TreeInsert', tree='{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}', parent=., position=0)\", \"(type='Move', tree='{*{field/succ{set of{sig/Workstation}}}}', parent=., position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='TreeDelete', tree='{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}')\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{one of{var0}{sig/Component}}{no{&{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","totalTED":15,"challenge":"bNCCf9FMRZoxqobfX","time":37348500,"targetExpr":"all x : Component | no (x.parts & Component).workstation & (x.workstation).*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | (p.workstation) in ((p.parts & Component).workstation).^succ }","sourceAST":"{all{one of{var0}{sig/Product}}{in{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all p:Product | (p.workstation) in ((p.parts & Component).workstation).^succ","predicate":"inv10","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Insert', node=^, parent=., position=0)\", \"(type='Insert', node=var0/Component, parent=., position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Move', tree='{var0/Product}', parent=., position=0)\", \"(type='Insert', node=field/parts, parent=^, position=0)\", \"(type='Insert', node=set of, parent=field/parts, position=0)\", \"(type='Update', node=var0/Product, value=sig/Product)\", \"(type='Move', tree='{var0/Product}', parent=set of, position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Instead of using signature of type Product, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":14,"challenge":"bNCCf9FMRZoxqobfX","time":61629900,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | all p:c.parts | p in Material or c.workstation in p.workstation.succ }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{OR{in{var1/Product}{sig/Material}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{field/succ{set of{sig/Workstation}}}}}}}}","nextExpr":"all c : Component, p : c.parts | p in Component => p.workstation not in c.workstation.*succ","sourceExpr":"all c:Component | all p:c.parts | p in Material or c.workstation in p.workstation.succ","predicate":"inv10","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{=>{in{var1/Product}{sig/Component}}{!in{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}}","operations":"[\"(type='Update', node=OR, value==>)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Material, value=sig/Component)\", \"(type='Update', node=var0/Component, value=var1/Product)\", \"(type='Insert', node=*, parent=., position=1)\", \"(type='Update', node=var1/Product, value=var0/Component)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=*, position=0)\"]","hint":"Keep going! Instead of using disjunction operator ('or') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{=>{in{var1/Product}{sig/Component}}{!in{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":34775200,"targetExpr":"all c : Component, p : c.parts | p in Component => p.workstation not in c.workstation.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (Product.^parts & Component).workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{sig/Product}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in (Product.^parts & Component).workstation.^succ","predicate":"inv10","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Update', node=sig/Product, value=var0/Component)\", \"(type='Move', tree='{sig/Product}', parent=., position=0)\", \"(type='TreeDelete', tree='{^{field/parts{set of{sig/Product}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":13,"challenge":"bNCCf9FMRZoxqobfX","time":40573000,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all c : Component | c.^parts not in Material }","sourceAST":"{all{one of{var0}{sig/Component}}{!in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Material}}}","nextExpr":"all c:Component | c.^parts.workstation in ^succ.(c.workstation)","sourceExpr":"all c : Component | c.^parts not in Material","predicate":"inv10","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=in, parent=all, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Material}}', parent=in, position=0)\", \"(type='TreeInsert', tree='{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='Insert', node=field/workstation, parent=!in, position=1)\", \"(type='Insert', node=set of, parent=field/workstation, position=0)\", \"(type='Update', node=sig/Material, value=sig/Workstation)\", \"(type='Move', tree='{sig/Material}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":15,"challenge":"bNCCf9FMRZoxqobfX","time":36596000,"targetExpr":"all c:Component | c.^parts.workstation in ^succ.(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | no (p.parts & Component).workstation }","sourceAST":"{all{one of{var0}{sig/Product}}{no{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}}}","nextExpr":"all x : Component | no (x.parts & Component).workstation & (x.workstation).*succ","sourceExpr":"all p:Product | no (p.parts & Component).workstation","predicate":"inv10","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Component}}{no{&{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Insert', node=&, parent=no, position=0)\", \"(type='Move', tree='{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}', parent=&, position=0)\", \"(type='TreeInsert', tree='{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}', parent=&, position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\"]","hint":"Keep going! Instead of using signature of type Product, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{no{&{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","totalTED":13,"challenge":"bNCCf9FMRZoxqobfX","time":38646200,"targetExpr":"all x : Component | no (x.parts & Component).workstation & (x.workstation).*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | no p.parts }","sourceAST":"{all{one of{var0}{sig/Product}}{no{.{var0/Product}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","sourceExpr":"all p:Product | no p.parts","predicate":"inv10","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=in, parent=all, position=1)\", \"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Update', node=no, value=.)\", \"(type='Move', tree='{no{.{var0/Product}{field/parts{set of{sig/Product}}}}}', parent=in, position=0)\", \"(type='TreeInsert', tree='{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='TreeInsert', tree='{field/workstation{set of{sig/Workstation}}}', parent=no, position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":17,"challenge":"bNCCf9FMRZoxqobfX","time":38932300,"targetExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in Component.parts.workstation.*succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{.{sig/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in Component.parts.workstation.*succ","predicate":"inv10","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=*, value=^)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Update', node=sig/Component, value=var0/Component)\", \"(type='Move', tree='{sig/Component}', parent=., position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":37887500,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (c.^parts & Component).workstation.^succ || no (c.^parts & Component).workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{OR{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}{no{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}}","nextExpr":"all c : Component | (c.parts & Component).workstation in c.workstation.^(~succ)","sourceExpr":"all c:Component | c.workstation in (c.^parts & Component).workstation.^succ || no (c.^parts & Component).workstation.^succ","predicate":"inv10","isNewNode":true,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{~{field/succ{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Update', node=OR, value=in)\", \"(type='Move', tree='{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}', parent=OR, position=0)\", \"(type='Move', tree='{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}', parent=OR, position=1)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='Insert', node=~, parent=^, position=0)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=., position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=~, position=0)\", \"(type='Delete', node=^)\", \"(type='TreeDelete', tree='{^{field/parts{set of{sig/Product}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\", \"(type='TreeDelete', tree='{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}')\", \"(type='TreeDelete', tree='{^{field/succ{set of{sig/Workstation}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using disjunction operator ('or') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{~{field/succ{set of{sig/Workstation}}}}}}}}","totalTED":22,"challenge":"bNCCf9FMRZoxqobfX","time":56286500,"targetExpr":"all c : Component | (c.parts & Component).workstation in c.workstation.^(~succ)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | workstation.c in c.parts.workstation.*succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{field/workstation{set of{sig/Workstation}}}{var0/Component}}{.{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | workstation.c in c.parts.workstation.*succ","predicate":"inv10","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{.{field/workstation{set of{sig/Workstation}}}{var0/Component}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Update', node=*, value=^)\", \"(type='Insert', node=^, parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='Update', node=field/workstation, value=field/parts)\", \"(type='Move', tree='{field/workstation{set of{sig/Workstation}}}', parent=^, position=0)\", \"(type='Update', node=sig/Workstation, value=sig/Product)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":12,"challenge":"bNCCf9FMRZoxqobfX","time":39821200,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (c.^parts & Component).workstation.*succ || no (c.^parts & Component).workstation.*succ }","sourceAST":"{all{one of{var0}{sig/Component}}{OR{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","nextExpr":"all x : Component | no (x.parts & Component).workstation & (x.workstation).*succ","sourceExpr":"all c:Component | c.workstation in (c.^parts & Component).workstation.*succ || no (c.^parts & Component).workstation.*succ","predicate":"inv10","isNewNode":true,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Component}}{no{&{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=OR, value=&)\", \"(type='Move', tree='{OR{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}', parent=no, position=0)\", \"(type='Move', tree='{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}', parent=OR, position=0)\", \"(type='Move', tree='{.{.{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}', parent=OR, position=1)\", \"(type='Move', tree='{var0/Component}', parent=., position=0)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=., position=1)\", \"(type='Delete', node=^)\", \"(type='TreeDelete', tree='{^{field/parts{set of{sig/Product}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\", \"(type='TreeDelete', tree='{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}')\", \"(type='TreeDelete', tree='{*{field/succ{set of{sig/Workstation}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Component}}{no{&{.{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{*{field/succ{set of{sig/Workstation}}}}}}}}","totalTED":22,"challenge":"bNCCf9FMRZoxqobfX","time":43241700,"targetExpr":"all x : Component | no (x.parts & Component).workstation & (x.workstation).*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in Product.parts.workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{.{sig/Product}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in Product.parts.workstation.^succ","predicate":"inv10","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Update', node=sig/Product, value=var0/Component)\", \"(type='Move', tree='{sig/Product}', parent=., position=0)\", \"(type='TreeDelete', tree='{field/parts{set of{sig/Product}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":51708700,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all c:Component | c.workstation in (Product.*parts & Component).workstation.^succ }","sourceAST":"{all{one of{var0}{sig/Component}}{in{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{.{.{&{.{sig/Product}{*{field/parts{set of{sig/Product}}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","sourceExpr":"all c:Component | c.workstation in (Product.*parts & Component).workstation.^succ","predicate":"inv10","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{^{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Component}', parent=., position=1)\", \"(type='Update', node=sig/Product, value=var0/Component)\", \"(type='Move', tree='{sig/Product}', parent=., position=0)\", \"(type='TreeDelete', tree='{*{field/parts{set of{sig/Product}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{^{field/parts{set of{sig/Product}}}}{var0/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":13,"challenge":"bNCCf9FMRZoxqobfX","time":38407600,"targetExpr":"all c: Component |(^parts.c).workstation in (c.workstation).^succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c: Component | c not in c.^(parts) } pred inv7 { all c: Component | c in Dangerous <=> some p: c.parts | p in Dangerous } pred inv8 { all c: Component, ws: c.workstation | c in Dangerous implies no w: ws.workers | w in Human } pred inv9 { } pred inv10 { all c: Component | all p: c.parts | p in c.*(parts - prev) }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{var1/Product}{.{var0/Component}{*{-{field/parts{set of{sig/Product}}}{field{~{field{next}}}}}}}}}}","nextExpr":"all c : Component, p : c.parts | p.workstation in ^succ.(c.workstation)","sourceExpr":"all c: Component | all p: c.parts | p in c.*(parts - prev)","predicate":"inv10","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Update', node=-, value=.)\", \"(type='Move', tree='{-{field/parts{set of{sig/Product}}}{field{~{field{next}}}}}', parent=in, position=1)\", \"(type='Move', tree='{var1/Product}', parent=., position=0)\", \"(type='Insert', node=field/workstation, parent=., position=1)\", \"(type='Insert', node=^, parent=-, position=0)\", \"(type='Update', node=field, value=.)\", \"(type='Insert', node=set of, parent=field/workstation, position=0)\", \"(type='Update', node=field/parts, value=field/succ)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\", \"(type='Insert', node=var0/Component, parent=field, position=0)\", \"(type='Update', node=~, value=field/workstation)\", \"(type='Update', node=var0/Component, value=sig/Workstation)\", \"(type='Move', tree='{var0/Component}', parent=set of, position=0)\", \"(type='Update', node=field, value=set of)\", \"(type='Update', node=sig/Product, value=sig/Workstation)\", \"(type='Update', node=next, value=sig/Workstation)\", \"(type='Delete', node=*)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{.{var1/Product}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}}","totalTED":15,"challenge":"bNCCf9FMRZoxqobfX","time":61465600,"targetExpr":"all c : Component, p : c.parts | p.workstation in ^succ.(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all c: Component | c.^parts not in end }","sourceAST":"{all{one of{var0}{sig/Component}}{!in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/end}}}","nextExpr":"all c:Component | c.^parts.workstation in ^succ.(c.workstation)","sourceExpr":"all c: Component | c.^parts not in end","predicate":"inv10","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Insert', node=in, parent=all, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/end}}', parent=in, position=0)\", \"(type='TreeInsert', tree='{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='Insert', node=field/workstation, parent=!in, position=1)\", \"(type='Insert', node=set of, parent=field/workstation, position=0)\", \"(type='Update', node=sig/end, value=sig/Workstation)\", \"(type='Move', tree='{sig/end}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":15,"challenge":"bNCCf9FMRZoxqobfX","time":59885100,"targetExpr":"all c:Component | c.^parts.workstation in ^succ.(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | (p.parts & Component).workstation in ~succ.p.workstation }","sourceAST":"{all{one of{var0}{sig/Product}}{in{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{.{~{field/succ{set of{sig/Workstation}}}}{var0/Product}}{field/workstation{set of{sig/Workstation}}}}}}","nextExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","sourceExpr":"all p:Product | (p.parts & Component).workstation in ~succ.p.workstation","predicate":"inv10","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Move', tree='{.{var0/Product}{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Update', node=~, value=^)\", \"(type='Move', tree='{~{field/succ{set of{sig/Workstation}}}}', parent=., position=0)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Move', tree='{var0/Product}', parent=., position=0)\", \"(type='Move', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using signature of type Product, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":53835500,"targetExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | (p.parts & Component).workstation in ^~succ.(p.workstation) }","sourceAST":"{all{one of{var0}{sig/Product}}{in{.{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}{field/workstation{set of{sig/Workstation}}}}{.{^{~{field/succ{set of{sig/Workstation}}}}}{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}}}}","nextExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","sourceExpr":"all p:Product | (p.parts & Component).workstation in ^~succ.(p.workstation)","predicate":"inv10","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Move', tree='{.{var0/Product}{field/parts{set of{sig/Product}}}}', parent=., position=0)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=^, position=0)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=&)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using signature of type Product, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":37044000,"targetExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ } pred inv10 { all p:Product | no p.parts & Component }","sourceAST":"{all{one of{var0}{sig/Product}}{no{&{.{var0/Product}{field/parts{set of{sig/Product}}}}{sig/Component}}}}","nextExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","sourceExpr":"all p:Product | no p.parts & Component","predicate":"inv10","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Update', node=sig/Product, value=sig/Component)\", \"(type='Update', node=&, value=.)\", \"(type='TreeInsert', tree='{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}', parent=no, position=1)\", \"(type='Insert', node=field/workstation, parent=&, position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\", \"(type='Insert', node=set of, parent=field/workstation, position=0)\", \"(type='Update', node=sig/Component, value=sig/Workstation)\", \"(type='Move', tree='{sig/Component}', parent=set of, position=0)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Component}}{in{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/workstation{set of{sig/Workstation}}}}{.{^{field/succ{set of{sig/Workstation}}}}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}}}","totalTED":17,"challenge":"bNCCf9FMRZoxqobfX","time":43727800,"targetExpr":"all c : Component | c.parts.workstation in (^succ).(c.workstation)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/workers{set of{sig/Worker}}}{one->{sig/Workstation}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"workers in Workstation one -> Worker","predicate":"inv2","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=one->, value=one->some)\"]","hint":"One step away from the solution! Instead of using one->, try using one->some to help satisfy the required property.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":99135900,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { workers in Workstation one -> one Worker } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/workers{set of{sig/Worker}}}{one->one{sig/Workstation}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"workers in Workstation one -> one Worker","predicate":"inv2","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=one->one, value=one->some)\"]","hint":"One step away from the solution! Instead of using one->one, try using one->some to help satisfy the required property.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":77560700,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { all w: Worker | one w.workers all ws: Workstation | all w1, w2: ws.workers | w1 = w2 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Worker}}{one{.{var0/Worker}{field/workers{set of{sig/Worker}}}}}}{all{one of{var1}{sig/Workstation}}{all{one of{var2}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}{all{one of{var3}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}{={var2/Worker}{var3/Worker}}}}}}","nextExpr":"all w: Workstation | some w.workers all w: Workstation, wo: Worker | one workers.wo","sourceExpr":"all w: Worker | one w.workers all ws: Workstation | all w1, w2: ws.workers | w1 = w2","predicate":"inv2","isNewNode":true,"srcDstTED":17,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}}","operations":"[\"(type='Update', node=one, value=some)\", \"(type='Update', node=sig/Worker, value=sig/Workstation)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=one of, value=one)\", \"(type='Move', tree='{one of{var3}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Update', node=var0/Worker, value=var0/Workstation)\", \"(type='Update', node=var2, value=var1)\", \"(type='Move', tree='{sig/Worker}', parent=one of, position=1)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Delete', node=var1/Workstation)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var3)\", \"(type='Delete', node=var1/Workstation)\", \"(type='TreeDelete', tree='{={var2/Worker}{var3/Worker}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}}","totalTED":17,"challenge":"bNCCf9FMRZoxqobfX","time":89630800,"targetExpr":"all w: Workstation | some w.workers all w: Workstation, wo: Worker | one workers.wo","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in (Human + Robot) } pred inv2 { all s:Workstation | some s.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}","nextExpr":"all w : Workstation | some w.workers all w : Worker | one workers.w","sourceExpr":"all w : Workstation | some w.workers","predicate":"inv2","isNewNode":false,"srcDstTED":11,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":68180600,"targetExpr":"all w : Workstation | some w.workers all w : Worker | one workers.w","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { lone workers.Worker and some Workstation.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{lone{.{field/workers{set of{sig/Worker}}}{sig/Worker}}}{some{.{sig/Workstation}{field/workers{set of{sig/Worker}}}}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"some Workstation.workers lone workers.Worker","predicate":"inv2","isNewNode":false,"srcDstTED":8,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Update', node=., value=one->some)\", \"(type='Move', tree='{.{sig/Workstation}{field/workers{set of{sig/Worker}}}}', parent=AND, position=1)\", \"(type='Move', tree='{sig/Worker}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node=.)\", \"(type='Delete', node=lone)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":73174100,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":true}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = (Human + Robot) } pred inv2 { (Workstation = Worker.workers) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{sig/Worker}{field/workers{set of{sig/Worker}}}}{sig/Workstation}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = Worker.workers)","predicate":"inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent==, position=0)\", \"(type='Insert', node=one->some, parent==, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=one->some, position=0)\", \"(type='Insert', node=sig/Worker, parent=one->some, position=1)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":5,"challenge":"bNCCf9FMRZoxqobfX","time":65731400,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { (Workstation = workers.Worker) and (Worker = Workstation.workers) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{={.{field/workers{set of{sig/Worker}}}{sig/Worker}}{sig/Workstation}}{={.{sig/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = workers.Worker) and (Worker = Workstation.workers)","predicate":"inv2","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Update', node=., value=one->some)\", \"(type='Move', tree='{.{sig/Workstation}{field/workers{set of{sig/Worker}}}}', parent=AND, position=1)\", \"(type='Move', tree='{sig/Worker}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Workstation)\", \"(type='Delete', node==)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":36454400,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { all w: Worker | one w.succ all ws: Workstation | all w1, w2: ws.workers | w1 = w2 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Worker}}{one{.{var0/Worker}{field/succ{set of{sig/Workstation}}}}}}{all{one of{var1}{sig/Workstation}}{all{one of{var2}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}{all{one of{var3}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}{={var2/Worker}{var3/Worker}}}}}}","nextExpr":"all w: Workstation | some w.workers all w: Workstation, wo: Worker | one workers.wo","sourceExpr":"all w: Worker | one w.succ all ws: Workstation | all w1, w2: ws.workers | w1 = w2","predicate":"inv2","isNewNode":true,"srcDstTED":19,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}}","operations":"[\"(type='Update', node=one, value=some)\", \"(type='Update', node=sig/Worker, value=sig/Workstation)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=one of, value=one)\", \"(type='Move', tree='{one of{var3}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=all, position=1)\", \"(type='Update', node=var0/Worker, value=var0/Workstation)\", \"(type='Update', node=field/succ, value=field/workers)\", \"(type='Update', node=var2, value=var1)\", \"(type='Move', tree='{sig/Worker}', parent=one of, position=1)\", \"(type='Insert', node=var1/Worker, parent=., position=2)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\", \"(type='Delete', node=var1/Workstation)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var3)\", \"(type='Delete', node=var1/Workstation)\", \"(type='TreeDelete', tree='{={var2/Worker}{var3/Worker}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Workstation}}{all{one of{var1}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var1/Worker}}}}}}","totalTED":19,"challenge":"bNCCf9FMRZoxqobfX","time":40319000,"targetExpr":"all w: Workstation | some w.workers all w: Workstation, wo: Worker | one workers.wo","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { some workers.Worker and some Workstation.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{some{.{field/workers{set of{sig/Worker}}}{sig/Worker}}}{some{.{sig/Workstation}{field/workers{set of{sig/Worker}}}}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"some workers.Worker and some Workstation.workers","predicate":"inv2","isNewNode":true,"srcDstTED":8,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Update', node=., value=one->some)\", \"(type='Move', tree='{.{sig/Workstation}{field/workers{set of{sig/Worker}}}}', parent=AND, position=1)\", \"(type='Move', tree='{sig/Worker}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node=.)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":35551300,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = (Human + Robot) } pred inv2 { Workstation = Workstation.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{sig/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Workstation}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"Workstation = Workstation.workers","predicate":"inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent==, position=0)\", \"(type='Insert', node=one->some, parent==, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=one->some, position=0)\", \"(type='Insert', node=sig/Worker, parent=one->some, position=1)\", \"(type='Delete', node=sig/Workstation)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":5,"challenge":"bNCCf9FMRZoxqobfX","time":40654200,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { some workers.Worker and lone Workstation.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{lone{.{sig/Workstation}{field/workers{set of{sig/Worker}}}}}{some{.{field/workers{set of{sig/Worker}}}{sig/Worker}}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"some workers.Worker and lone Workstation.workers","predicate":"inv2","isNewNode":true,"srcDstTED":9,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Update', node=., value=one->some)\", \"(type='Move', tree='{.{field/workers{set of{sig/Worker}}}{sig/Worker}}', parent=AND, position=1)\", \"(type='Update', node=sig/Worker, value=sig/Workstation)\", \"(type='Move', tree='{sig/Worker}', parent=., position=0)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=sig/Workstation)\", \"(type='Delete', node=.)\", \"(type='Delete', node=lone)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":9,"challenge":"bNCCf9FMRZoxqobfX","time":35814700,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { (Workstation = workers.Worker) and (Worker = Worker.~workers) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{={.{field/workers{set of{sig/Worker}}}{sig/Worker}}{sig/Workstation}}{={.{sig/Worker}{~{field/workers{set of{sig/Worker}}}}}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = workers.Worker) and (Worker = Worker.~workers)","predicate":"inv2","isNewNode":true,"srcDstTED":12,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Insert', node=one->some, parent=AND, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=one->some, position=0)\", \"(type='Move', tree='{sig/Worker}', parent=one->some, position=1)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node=.)\", \"(type='Delete', node==)\", \"(type='TreeDelete', tree='{~{field/workers{set of{sig/Worker}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":12,"challenge":"bNCCf9FMRZoxqobfX","time":36399500,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = (Human + Robot) } pred inv2 { (Workstation = workers.Worker) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{field/workers{set of{sig/Worker}}}{sig/Worker}}{sig/Workstation}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = workers.Worker)","predicate":"inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=., value=in)\", \"(type='Move', tree='{.{field/workers{set of{sig/Worker}}}{sig/Worker}}', parent=root, position=0)\", \"(type='Insert', node=one->some, parent=., position=1)\", \"(type='Insert', node=sig/Workstation, parent=one->some, position=0)\", \"(type='Move', tree='{sig/Worker}', parent=one->some, position=1)\", \"(type='Delete', node=sig/Workstation)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":5,"challenge":"bNCCf9FMRZoxqobfX","time":36836800,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in (Human + Robot) } pred inv2 { workers in Workstation some -> one Worker } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/workers{set of{sig/Worker}}}{some->one{sig/Workstation}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"workers in Workstation some -> one Worker","predicate":"inv2","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=some->one, value=one->some)\"]","hint":"One step away from the solution! Instead of using some->one, try using one->some to help satisfy the required property.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":52310900,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = (Human + Robot) } pred inv2 { some workers and some Worker.(~workers) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{some{field/workers{set of{sig/Worker}}}}{some{.{sig/Worker}{~{field/workers{set of{sig/Worker}}}}}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"some workers and some Worker.(~workers)","predicate":"inv2","isNewNode":true,"srcDstTED":8,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Update', node=., value=one->some)\", \"(type='Move', tree='{.{sig/Worker}{~{field/workers{set of{sig/Worker}}}}}', parent=AND, position=1)\", \"(type='Update', node=sig/Worker, value=sig/Workstation)\", \"(type='Move', tree='{sig/Worker}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/workers)\", \"(type='Delete', node=~)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":40134200,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = (Human + Robot) } pred inv2 { (Workstation = workers.Worker) and (Worker = workers.Workstation) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{={.{field/workers{set of{sig/Worker}}}{sig/Worker}}{sig/Workstation}}{={.{field/workers{set of{sig/Worker}}}{sig/Workstation}}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = workers.Worker) and (Worker = workers.Workstation)","predicate":"inv2","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Update', node==, value=one->some)\", \"(type='Move', tree='{sig/Workstation}', parent==, position=0)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Workstation)\", \"(type='Delete', node==)\", \"(type='TreeDelete', tree='{field/workers{set of{sig/Worker}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":48418200,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { (Workstation = workers.Workstation) and (Worker = Worker.~workers) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{={.{field/workers{set of{sig/Worker}}}{sig/Workstation}}{sig/Workstation}}{={.{sig/Worker}{~{field/workers{set of{sig/Worker}}}}}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = workers.Workstation) and (Worker = Worker.~workers)","predicate":"inv2","isNewNode":true,"srcDstTED":12,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=AND, position=0)\", \"(type='Insert', node=one->some, parent=AND, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=one->some, position=0)\", \"(type='Move', tree='{sig/Worker}', parent=one->some, position=1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Workstation)\", \"(type='Delete', node==)\", \"(type='TreeDelete', tree='{~{field/workers{set of{sig/Worker}}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Worker)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":12,"challenge":"bNCCf9FMRZoxqobfX","time":35317400,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { all w: Worker | one w.succ } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Worker}}{one{.{var0/Worker}{field/succ{set of{sig/Workstation}}}}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"all w: Worker | one w.succ","predicate":"inv2","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=all, value=in)\", \"(type='Insert', node=field/workers, parent=all, position=0)\", \"(type='Update', node=set of, value=one->some)\", \"(type='Move', tree='{set of{sig/Workstation}}', parent=all, position=1)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var0}{sig/Worker}}', parent=field/workers, position=0)\", \"(type='Insert', node=sig/Worker, parent=set of, position=1)\", \"(type='Delete', node=var0)\", \"(type='Delete', node=var0/Worker)\", \"(type='Delete', node=field/succ)\", \"(type='Delete', node=.)\", \"(type='Delete', node=one)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":35081500,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { some workers.Worker } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{.{field/workers{set of{sig/Worker}}}{sig/Worker}}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"some workers.Worker","predicate":"inv2","isNewNode":true,"srcDstTED":4,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node=., value=in)\", \"(type='Move', tree='{.{field/workers{set of{sig/Worker}}}{sig/Worker}}', parent=root, position=0)\", \"(type='Insert', node=one->some, parent=., position=1)\", \"(type='Insert', node=sig/Workstation, parent=one->some, position=0)\", \"(type='Move', tree='{sig/Worker}', parent=one->some, position=1)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":4,"challenge":"bNCCf9FMRZoxqobfX","time":32760100,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w } pred inv3 { workstation in Component -> one Workstation } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}","nextExpr":"all w : Workstation | some w.workers all w : Worker | one workers.w","sourceExpr":"all w:Worker | one workers.w","predicate":"inv2","isNewNode":false,"srcDstTED":11,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":54934900,"targetExpr":"all w : Workstation | some w.workers all w : Worker | one workers.w","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w : Worker | one workers.w and all w: Workstation | some w.workers } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Worker}}{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","nextExpr":"all w : Workstation | some w.workers all w : Worker | one workers.w","sourceExpr":"all w : Worker | one workers.w and all w: Workstation | some w.workers","predicate":"inv2","isNewNode":true,"srcDstTED":8,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","operations":"[\"(type='Move', tree='{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}', parent=root, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Worker}}', parent=all, position=0)\", \"(type='Move', tree='{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Worker}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the conjunction operator ('and') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{some{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}}}{all{one of{var0}{sig/Worker}}{one{.{field/workers{set of{sig/Worker}}}{var0/Worker}}}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":39641600,"targetExpr":"all w : Workstation | some w.workers all w : Worker | one workers.w","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = (Human + Robot) } pred inv2 { (Workstation = workers.Workstation) } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{field/workers{set of{sig/Worker}}}{sig/Workstation}}{sig/Workstation}}","nextExpr":"workers in Workstation one -> some Worker","sourceExpr":"(Workstation = workers.Workstation)","predicate":"inv2","isNewNode":true,"srcDstTED":4,"targetAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent==, position=0)\", \"(type='Insert', node=one->some, parent==, position=1)\", \"(type='Move', tree='{sig/Workstation}', parent=one->some, position=0)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\", \"(type='Move', tree='{sig/Workstation}', parent=one->some, position=1)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/workers{set of{sig/Worker}}}{one->some{sig/Workstation}{sig/Worker}}}","totalTED":4,"challenge":"bNCCf9FMRZoxqobfX","time":35328600,"targetExpr":"workers in Workstation one -> some Worker","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in (Human + Robot) } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> some Workstation } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/workstation{set of{sig/Workstation}}}{->some{sig/Component}{sig/Workstation}}}","nextExpr":"workstation in Component set -> one Workstation","sourceExpr":"workstation in Component -> some Workstation","predicate":"inv3","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/workstation{set of{sig/Workstation}}}{->one{sig/Component}{sig/Workstation}}}","operations":"[\"(type='Update', node=->some, value=->one)\"]","hint":"One step away from the solution! Instead of using ->some, try using ->one to help satisfy the required property.","nextAST":"{in{field/workstation{set of{sig/Workstation}}}{->one{sig/Component}{sig/Workstation}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":95775500,"targetExpr":"workstation in Component set -> one Workstation","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in (Human + Robot) } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component some -> one Workstation } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/workstation{set of{sig/Workstation}}}{some->one{sig/Component}{sig/Workstation}}}","nextExpr":"workstation in Component set -> one Workstation","sourceExpr":"workstation in Component some -> one Workstation","predicate":"inv3","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/workstation{set of{sig/Workstation}}}{->one{sig/Component}{sig/Workstation}}}","operations":"[\"(type='Update', node=some->one, value=->one)\"]","hint":"One step away from the solution! Instead of using some->one, try using ->one to help satisfy the required property.","nextAST":"{in{field/workstation{set of{sig/Workstation}}}{->one{sig/Component}{sig/Workstation}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":42348400,"targetExpr":"workstation in Component set -> one Workstation","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in (Human + Robot) } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component some -> some Workstation } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/workstation{set of{sig/Workstation}}}{some->some{sig/Component}{sig/Workstation}}}","nextExpr":"workstation in Component -> one Workstation","sourceExpr":"workstation in Component some -> some Workstation","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/workstation{set of{sig/Workstation}}}{->one{sig/Component}{sig/Workstation}}}","operations":"[\"(type='Update', node=some->some, value=->one)\"]","hint":"One step away from the solution! Instead of using some->some, try using ->one to help satisfy the required property.","nextAST":"{in{field/workstation{set of{sig/Workstation}}}{->one{sig/Component}{sig/Workstation}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":76637100,"targetExpr":"workstation in Component -> one Workstation","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component, m: Material | c.parts != none and m.parts = none } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Material}}{AND{!={.{var0/Component}{field/parts{set of{sig/Product}}}}{none}}{={.{var1/Material}{field/parts{set of{sig/Product}}}}{none}}}}}","nextExpr":"(all c:Component | some p:Product | p in c.parts) and (all m: Material | no p: Product | p in m.parts)","sourceExpr":"all c:Component, m:Material | (c.parts != none) and (m.parts = none)","predicate":"inv4","isNewNode":false,"srcDstTED":21,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{one of{var1}{sig/Product}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}{all{one of{var2}{sig/Material}}{no{one of{var1}{sig/Product}}{in{var1/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Material}}', parent=some, position=0)\", \"(type='Insert', node=in, parent=some, position=1)\", \"(type='Update', node=none, value=var2)\", \"(type='Move', tree='{none}', parent=one of, position=0)\", \"(type='Insert', node=sig/Material, parent=one of, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Product}}', parent=no, position=0)\", \"(type='Update', node==, value=in)\", \"(type='Move', tree='{={.{var1/Material}{field/parts{set of{sig/Product}}}}{none}}', parent=no, position=1)\", \"(type='Update', node=sig/Material, value=sig/Product)\", \"(type='Insert', node=var1/Product, parent=in, position=0)\", \"(type='Move', tree='{.{var0/Component}{field/parts{set of{sig/Product}}}}', parent=in, position=1)\", \"(type='Insert', node=var1/Product, parent==, position=0)\", \"(type='Update', node=var1/Material, value=var2/Material)\", \"(type='Delete', node=none)\", \"(type='Delete', node=!=)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{one of{var1}{sig/Product}}{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}}{all{one of{var2}{sig/Material}}{no{one of{var1}{sig/Product}}{in{var1/Product}{.{var2/Material}{field/parts{set of{sig/Product}}}}}}}}","totalTED":21,"challenge":"bNCCf9FMRZoxqobfX","time":106025900,"targetExpr":"(all c:Component | some p:Product | p in c.parts) and (all m: Material | no p: Product | p in m.parts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts in Component -> Product } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/parts{set of{sig/Product}}}{->{sig/Component}{sig/Product}}}","nextExpr":"parts in Component -> some Product","sourceExpr":"parts in Component -> set Product","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}","operations":"[\"(type='Update', node=->, value=->some)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using ->some to help satisfy the required property.","nextAST":"{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":66041000,"targetExpr":"parts in Component -> some Product","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product in Component } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{.{field/parts{set of{sig/Product}}}{sig/Product}}{sig/Component}}","nextExpr":"Component = parts.Product","sourceExpr":"parts.Product in Component","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{={.{field/parts{set of{sig/Product}}}{sig/Product}}{sig/Component}}","operations":"[\"(type='Update', node=in, value==)\"]","hint":"One step away from the solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{={.{field/parts{set of{sig/Product}}}{sig/Product}}{sig/Component}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":82272400,"targetExpr":"Component = parts.Product","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component, m:Material | some p:Product | c->p in parts and m->p not in parts } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Material}}{some{one of{var2}{sig/Product}}{AND{!in{->{var1/Material}{var2/Product}}{field/parts{set of{sig/Product}}}}{in{->{var0/Component}{var2/Product}}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all c:Component | some c.parts no Material.parts","sourceExpr":"all c:Component, m:Material | some p:Product | c->p in parts and m->p not in parts","predicate":"inv4","isNewNode":true,"srcDstTED":21,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{->{var0/Component}{var2/Product}}{field/parts{set of{sig/Product}}}}', parent=no, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{->{var1/Material}{var2/Product}}{field/parts{set of{sig/Product}}}}', parent=some, position=0)\", \"(type='Update', node=var0/Component, value=sig/Material)\", \"(type='Move', tree='{var0/Component}', parent=in, position=0)\", \"(type='Update', node=var1/Material, value=var0/Component)\", \"(type='Move', tree='{var1/Material}', parent=!in, position=0)\", \"(type='Delete', node=var2/Product)\", \"(type='Delete', node=->)\", \"(type='Delete', node=var2/Product)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Material}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/Product}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":21,"challenge":"bNCCf9FMRZoxqobfX","time":72124400,"targetExpr":"all c:Component | some c.parts no Material.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { parts in Component -> some Product parts in Material -> lone Product } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}{in{field/parts{set of{sig/Product}}}{->lone{sig/Material}{sig/Product}}}}","nextExpr":"parts in Component -> some Product no Material.parts","sourceExpr":"parts in Component -> some Product parts in Material -> lone Product","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{AND{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Insert', node=no, parent=AND, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{field/parts{set of{sig/Product}}}{->lone{sig/Material}{sig/Product}}}', parent=no, position=0)\", \"(type='Insert', node=sig/Material, parent=in, position=0)\", \"(type='TreeDelete', tree='{->lone{sig/Material}{sig/Product}}')\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{AND{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":57548200,"targetExpr":"parts in Component -> some Product no Material.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component, m:Material, p:Product | c->p in parts and m->p not in parts } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Material}}{all{one of{var2}{sig/Product}}{AND{!in{->{var1/Material}{var2/Product}}{field/parts{set of{sig/Product}}}}{in{->{var0/Component}{var2/Product}}{field/parts{set of{sig/Product}}}}}}}}","nextExpr":"all c:Component | some c.parts no Material.parts","sourceExpr":"all c:Component, m:Material, p:Product | c->p in parts and m->p not in parts","predicate":"inv4","isNewNode":true,"srcDstTED":21,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{->{var0/Component}{var2/Product}}{field/parts{set of{sig/Product}}}}', parent=no, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{->{var1/Material}{var2/Product}}{field/parts{set of{sig/Product}}}}', parent=some, position=0)\", \"(type='Update', node=var0/Component, value=sig/Material)\", \"(type='Move', tree='{var0/Component}', parent=in, position=0)\", \"(type='Update', node=var1/Material, value=var0/Component)\", \"(type='Move', tree='{var1/Material}', parent=!in, position=0)\", \"(type='Delete', node=var2/Product)\", \"(type='Delete', node=->)\", \"(type='Delete', node=var2/Product)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Material}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/Product}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":21,"challenge":"bNCCf9FMRZoxqobfX","time":37698900,"targetExpr":"all c:Component | some c.parts no Material.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { (no Material.parts) and (Component = Component.parts) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{={.{sig/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","nextExpr":"parts in Component -> some Product no Material.parts","sourceExpr":"(no Material.parts) and (Component = Component.parts)","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{AND{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent==, position=0)\", \"(type='Insert', node=->some, parent==, position=1)\", \"(type='Move', tree='{sig/Component}', parent=->some, position=0)\", \"(type='Insert', node=sig/Product, parent=->some, position=1)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{AND{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}}","totalTED":5,"challenge":"bNCCf9FMRZoxqobfX","time":42304300,"targetExpr":"parts in Component -> some Product no Material.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w : Worker | one workers.w all w: Workstation | some w.workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { no parts.Material and some parts.Component } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{no{.{field/parts{set of{sig/Product}}}{sig/Material}}}{some{.{field/parts{set of{sig/Product}}}{sig/Component}}}}","nextExpr":"Component in parts.Product and Material.parts = none","sourceExpr":"no parts.Material and some parts.Component","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","operations":"[\"(type='Update', node=no, value==)\", \"(type='Update', node=some, value=in)\", \"(type='Insert', node=none, parent=no, position=1)\", \"(type='Insert', node=sig/Component, parent=some, position=0)\", \"(type='Insert', node=sig/Material, parent=., position=0)\", \"(type='Update', node=sig/Component, value=sig/Product)\", \"(type='Delete', node=sig/Material)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":34658400,"targetExpr":"Component in parts.Product and Material.parts = none","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w : Worker | one workers.w all w: Workstation | some w.workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { no Material.~parts and some parts.Component } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{no{.{sig/Material}{~{field/parts{set of{sig/Product}}}}}}{some{.{field/parts{set of{sig/Product}}}{sig/Component}}}}","nextExpr":"Component in parts.Product and Material.parts = none","sourceExpr":"no Material.~parts and some parts.Component","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","operations":"[\"(type='Update', node=no, value==)\", \"(type='Update', node=some, value=in)\", \"(type='Insert', node=none, parent=no, position=1)\", \"(type='Insert', node=sig/Component, parent=some, position=0)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=., position=1)\", \"(type='Update', node=sig/Component, value=sig/Product)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":34183500,"targetExpr":"Component in parts.Product and Material.parts = none","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { no parts.Material and (Component = parts.Component) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{={.{field/parts{set of{sig/Product}}}{sig/Component}}{sig/Component}}{no{.{field/parts{set of{sig/Product}}}{sig/Material}}}}","nextExpr":"Component in parts.Product and Material.parts = none","sourceExpr":"no parts.Material and (Component = parts.Component)","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Update', node=sig/Component, value=none)\", \"(type='Insert', node=sig/Component, parent=no, position=0)\", \"(type='Insert', node=sig/Material, parent=., position=0)\", \"(type='Update', node=sig/Material, value=sig/Product)\", \"(type='Delete', node=sig/Component)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":31818500,"targetExpr":"Component in parts.Product and Material.parts = none","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { parts in Component -> some Product parts not in Material -> Product } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{!in{field/parts{set of{sig/Product}}}{->{sig/Material}{sig/Product}}}{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}}","nextExpr":"parts in Component -> some Product","sourceExpr":"parts in Component -> some Product parts not in Material -> Product","predicate":"inv4","isNewNode":true,"srcDstTED":8,"targetAST":"{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}","operations":"[\"(type='Move', tree='{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}', parent=root, position=0)\", \"(type='TreeDelete', tree='{!in{field/parts{set of{sig/Product}}}{->{sig/Material}{sig/Product}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{in{field/parts{set of{sig/Product}}}{->some{sig/Component}{sig/Product}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":32402300,"targetExpr":"parts in Component -> some Product","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all c : Component | some c.parts all m : Material | no m.parts","sourceExpr":"all c: Component | some c.parts","predicate":"inv4","isNewNode":false,"srcDstTED":11,"targetAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Component}}{some{.{var0/Component}{field/parts{set of{sig/Product}}}}}}{all{one of{var1}{sig/Material}}{no{.{var1/Material}{field/parts{set of{sig/Product}}}}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":63250400,"targetExpr":"all c : Component | some c.parts all m : Material | no m.parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w : Worker | one workers.w all w: Workstation | some w.workers } pred inv3 { all c: Component | one c.workstation } pred inv4 { no Material.parts and some parts.Component } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{no{.{sig/Material}{field/parts{set of{sig/Product}}}}}{some{.{field/parts{set of{sig/Product}}}{sig/Component}}}}","nextExpr":"Component in parts.Product and Material.parts = none","sourceExpr":"no Material.parts and some parts.Component","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","operations":"[\"(type='Update', node=no, value==)\", \"(type='Update', node=some, value=in)\", \"(type='Insert', node=none, parent=no, position=1)\", \"(type='Insert', node=sig/Component, parent=some, position=0)\", \"(type='Update', node=sig/Component, value=sig/Product)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{AND{={.{sig/Material}{field/parts{set of{sig/Product}}}}{none}}{in{sig/Component}{.{field/parts{set of{sig/Product}}}{sig/Product}}}}","totalTED":5,"challenge":"bNCCf9FMRZoxqobfX","time":33867400,"targetExpr":"Component in parts.Product and Material.parts = none","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { no workers.Human - workers.Robot } pred inv6 { all c: Component | c not in c.parts } pred inv7 { all c: Component | c in Dangerous <=> some p: c.parts | p in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{-{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","nextExpr":"no (workers.Human & workers.Robot)","sourceExpr":"no workers.Human - workers.Robot","predicate":"inv5","isNewNode":true,"srcDstTED":1,"targetAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","operations":"[\"(type='Update', node=-, value=&)\"]","hint":"One step away from the solution! Instead of using difference operator ('-') to remove elements from a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":85806700,"targetExpr":"no (workers.Human & workers.Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { Workstation = workers.Human + workers.Robot } pred inv6 { all c: Component | c not in c.parts } pred inv7 { all c: Component | c in Dangerous <=> some p: c.parts | p in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={+{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}{sig/Workstation}}","nextExpr":"no (workers.Human & workers.Robot)","sourceExpr":"Workstation = workers.Human + workers.Robot","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","operations":"[\"(type='Update', node==, value=no)\", \"(type='Update', node=+, value=&)\", \"(type='Delete', node=sig/Workstation)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","totalTED":3,"challenge":"bNCCf9FMRZoxqobfX","time":60429000,"targetExpr":"no (workers.Human & workers.Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { all disj h, r: Worker | no w: Workstation | h in w.workers and r in w.workers } pred inv6 { all c: Component | c not in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{disj}{one of{var0}{sig/Worker}}{all{disj}{one of{var1}{sig/Worker}}{no{one of{var2}{sig/Workstation}}{AND{in{var0/Worker}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}{in{var1/Worker}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","nextExpr":"all h: Human | all r: Robot | all ws: Workstation | h in ws.workers implies r not in ws.workers","sourceExpr":"all disj h, r: Worker | no w: Workstation | h in w.workers and r in w.workers","predicate":"inv5","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{all{one of{var2}{sig/Workstation}}{=>{in{var0/Human}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{var1/Robot}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","operations":"[\"(type='Update', node=sig/Worker, value=sig/Human)\", \"(type='Update', node=no, value=all)\", \"(type='Update', node=sig/Worker, value=sig/Robot)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=var0/Worker, value=var0/Human)\", \"(type='Update', node=var1/Worker, value=var1/Robot)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! Instead of using signature of type Worker, try using signature of type Human to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{all{one of{var2}{sig/Workstation}}{=>{in{var0/Human}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{var1/Robot}{.{var2/Workstation}{field/workers{set of{sig/Worker}}}}}}}}}","totalTED":9,"challenge":"bNCCf9FMRZoxqobfX","time":43913900,"targetExpr":"all h: Human | all r: Robot | all ws: Workstation | h in ws.workers implies r not in ws.workers","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { all c: Component | c.parts != none all m: Material| no m.parts } pred inv5 { workers.Worker not in Human + Robot } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!in{.{field/workers{set of{sig/Worker}}}{sig/Worker}}{+{sig/Human}{sig/Robot}}}","nextExpr":"no (workers.Human & workers.Robot)","sourceExpr":"workers.Worker not in Human + Robot","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","operations":"[\"(type='Insert', node=no, parent=root, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{field/workers{set of{sig/Worker}}}{sig/Worker}}{+{sig/Human}{sig/Robot}}}', parent=no, position=0)\", \"(type='Update', node=+, value=.)\", \"(type='Update', node=sig/Worker, value=sig/Human)\", \"(type='Insert', node=field/workers, parent=+, position=0)\", \"(type='Insert', node=set of, parent=field/workers, position=0)\", \"(type='Update', node=sig/Human, value=sig/Worker)\", \"(type='Move', tree='{sig/Human}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":45293900,"targetExpr":"no (workers.Human & workers.Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | c.parts != none all m: Material | m.parts = none } pred inv5 { no disj w1, w2: Human + Robot | w1.workers & w2.workers != none } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{disj}{one of{var0}{+{sig/Human}{sig/Robot}}}{no{disj}{one of{var1}{+{sig/Human}{sig/Robot}}}{!={&{.{var0/Human->Robot}{field/workers{set of{sig/Worker}}}}{.{var1/Human->Robot}{field/workers{set of{sig/Worker}}}}}{none}}}}","nextExpr":"all h : Human | all r : Robot | no (workers.h & workers.r)","sourceExpr":"no disj w1, w2: Human + Robot | w1.workers & w2.workers != none","predicate":"inv5","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{field/workers{set of{sig/Worker}}}{var0/Human}}{.{field/workers{set of{sig/Worker}}}{var1/Robot}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=no, value=all)\", \"(type='Move', tree='{sig/Human}', parent=one of, position=1)\", \"(type='Update', node=!=, value=no)\", \"(type='Move', tree='{sig/Robot}', parent=one of, position=1)\", \"(type='Insert', node=var0/Human, parent=., position=2)\", \"(type='Insert', node=var1/Robot, parent=., position=2)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=sig/Robot)\", \"(type='Delete', node=+)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=sig/Human)\", \"(type='Delete', node=+)\", \"(type='Delete', node=var0/Human->Robot)\", \"(type='Delete', node=var1/Human->Robot)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{field/workers{set of{sig/Worker}}}{var0/Human}}{.{field/workers{set of{sig/Worker}}}{var1/Robot}}}}}}","totalTED":14,"challenge":"bNCCf9FMRZoxqobfX","time":63973400,"targetExpr":"all h : Human | all r : Robot | no (workers.h & workers.r)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { all c: Component | c.parts != none all m: Material| no m.parts } pred inv5 { Human + Robot not in workers.Worker } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!in{+{sig/Human}{sig/Robot}}{.{field/workers{set of{sig/Worker}}}{sig/Worker}}}","nextExpr":"no (workers . Human & workers . Robot)","sourceExpr":"Human + Robot not in workers.Worker","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","operations":"[\"(type='Insert', node=no, parent=root, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{+{sig/Human}{sig/Robot}}{.{field/workers{set of{sig/Worker}}}{sig/Worker}}}', parent=no, position=0)\", \"(type='Update', node=+, value=.)\", \"(type='TreeInsert', tree='{field/workers{set of{sig/Worker}}}', parent=+, position=0)\", \"(type='Update', node=sig/Worker, value=sig/Robot)\", \"(type='Delete', node=sig/Robot)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":39506500,"targetExpr":"no (workers . Human & workers . Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { all c: Component | c.parts != none all m: Material| no m.parts } pred inv5 { workers.Workstation not in Human & Robot } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!in{.{field/workers{set of{sig/Worker}}}{sig/Workstation}}{&{sig/Human}{sig/Robot}}}","nextExpr":"no (workers.Human & workers.Robot)","sourceExpr":"workers.Workstation not in Human & Robot","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","operations":"[\"(type='Insert', node=no, parent=root, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{field/workers{set of{sig/Worker}}}{sig/Workstation}}{&{sig/Human}{sig/Robot}}}', parent=no, position=0)\", \"(type='Update', node=&, value=.)\", \"(type='Update', node=sig/Workstation, value=sig/Human)\", \"(type='Insert', node=field/workers, parent=&, position=0)\", \"(type='Insert', node=set of, parent=field/workers, position=0)\", \"(type='Update', node=sig/Human, value=sig/Worker)\", \"(type='Move', tree='{sig/Human}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":35200100,"targetExpr":"no (workers.Human & workers.Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | c.parts != none all m: Material | m.parts = none } pred inv5 { all h: Human, r: Robot | no h.workers & r.workers } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{var0/Human}{field/workers{set of{sig/Worker}}}}{.{var1/Robot}{field/workers{set of{sig/Worker}}}}}}}}","nextExpr":"all h : Human | all r : Robot | no (workers.h & workers.r)","sourceExpr":"all h: Human, r: Robot | no h.workers & r.workers","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{field/workers{set of{sig/Worker}}}{var0/Human}}{.{field/workers{set of{sig/Worker}}}{var1/Robot}}}}}}","operations":"[\"(type='Insert', node=var0/Human, parent=., position=2)\", \"(type='Insert', node=var1/Robot, parent=., position=2)\", \"(type='Delete', node=var0/Human)\", \"(type='Delete', node=var1/Robot)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider using a variable of type Human to correctly capture the property you want to specify. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Human}}{all{one of{var1}{sig/Robot}}{no{&{.{field/workers{set of{sig/Worker}}}{var0/Human}}{.{field/workers{set of{sig/Worker}}}{var1/Robot}}}}}}","totalTED":4,"challenge":"bNCCf9FMRZoxqobfX","time":35238800,"targetExpr":"all h : Human | all r : Robot | no (workers.h & workers.r)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { all w:Workstation | w.workers in Human + Robot } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Workstation}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{+{sig/Human}{sig/Robot}}}}","nextExpr":"all w: Workstation | w.workers in Human or w.workers in Robot","sourceExpr":"all w:Workstation | w.workers in Human + Robot","predicate":"inv5","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","operations":"[\"(type='Update', node=in, value=OR)\", \"(type='Insert', node=in, parent=in, position=0)\", \"(type='Insert', node=in, parent=in, position=1)\", \"(type='Move', tree='{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}', parent=in, position=0)\", \"(type='Move', tree='{sig/Human}', parent=in, position=1)\", \"(type='TreeInsert', tree='{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}', parent=in, position=0)\", \"(type='Move', tree='{sig/Robot}', parent=in, position=1)\", \"(type='Delete', node=+)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Workstation}}{OR{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Human}}{in{.{var0/Workstation}{field/workers{set of{sig/Worker}}}}{sig/Robot}}}}","totalTED":9,"challenge":"bNCCf9FMRZoxqobfX","time":37042800,"targetExpr":"all w: Workstation | w.workers in Human or w.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { all c: Component | c.parts != none all m: Material| no m.parts } pred inv5 { workers.Worker not in Human & Robot } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!in{.{field/workers{set of{sig/Worker}}}{sig/Worker}}{&{sig/Human}{sig/Robot}}}","nextExpr":"no (workers.Human & workers.Robot)","sourceExpr":"workers.Worker not in Human & Robot","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","operations":"[\"(type='Insert', node=no, parent=root, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{field/workers{set of{sig/Worker}}}{sig/Worker}}{&{sig/Human}{sig/Robot}}}', parent=no, position=0)\", \"(type='Update', node=&, value=.)\", \"(type='Update', node=sig/Worker, value=sig/Human)\", \"(type='Insert', node=field/workers, parent=&, position=0)\", \"(type='Insert', node=set of, parent=field/workers, position=0)\", \"(type='Update', node=sig/Human, value=sig/Worker)\", \"(type='Move', tree='{sig/Human}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{no{&{.{field/workers{set of{sig/Worker}}}{sig/Human}}{.{field/workers{set of{sig/Worker}}}{sig/Robot}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":33070800,"targetExpr":"no (workers.Human & workers.Robot)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { not iden in ^parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!{in{iden}{^{field/parts{set of{sig/Product}}}}}}","nextExpr":"no (^parts & iden)","sourceExpr":"not iden in ^parts","predicate":"inv6","isNewNode":true,"srcDstTED":4,"targetAST":"{no{&{^{field/parts{set of{sig/Product}}}}{iden}}}","operations":"[\"(type='Update', node=!, value=no)\", \"(type='Update', node=in, value=&)\", \"(type='Insert', node=iden, parent=in, position=2)\", \"(type='Delete', node=iden)\"]","hint":"Keep going! Instead of using negation operator ('!') to specify that the expression is false, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{no{&{^{field/parts{set of{sig/Product}}}}{iden}}}","totalTED":4,"challenge":"bNCCf9FMRZoxqobfX","time":107255800,"targetExpr":"no (^parts & iden)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { } pred inv6 { some c:Component | no (c.parts & Component) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Component}}{no{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Component}}}}","nextExpr":"all c1:Component | no c1 & c1.^parts","sourceExpr":"some c:Component | no (c.parts & Component)","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Component}}{no{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{var0/Component}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Component, value=var0/Component)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{no{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{var0/Component}}}}","totalTED":3,"challenge":"bNCCf9FMRZoxqobfX","time":39863500,"targetExpr":"all c1:Component | no c1 & c1.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c:Component | c not in c.*parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{*{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c : Component | c not in c.^parts","sourceExpr":"all c : Component | c not in c.*parts","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=*, value=^)\"]","hint":"One step away from the solution! Instead of using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation, try using transitive closure operator ('^') to get the transitive closure of a relation.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":88346300,"targetExpr":"all c : Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c:Component | c not in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all c : Component | c not in c.^parts","sourceExpr":"all c: Component | c not in c.parts","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":45053400,"targetExpr":"all c : Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { } pred inv6 { some c:Component | c not in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","nextExpr":"no c:Component | c not in c.parts","sourceExpr":"some c:Component | c not in c.parts","predicate":"inv6","isNewNode":false,"srcDstTED":3,"targetAST":"{no{one of{var0}{sig/Component}}{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=some, value=no)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{no{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","totalTED":3,"challenge":"bNCCf9FMRZoxqobfX","time":45089300,"targetExpr":"no c : Component | c in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { some c:Component | c not in c.^parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c:Component | c not in c.^parts","sourceExpr":"some c:Component | c not in c.^parts","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":33147700,"targetExpr":"all c:Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { } pred inv6 { some c:Component | no (c.parts & c) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Component}}{no{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{var0/Component}}}}","nextExpr":"all c1:Component | no c1 & c1.^parts","sourceExpr":"some c: Component | no (c.parts & c)","predicate":"inv6","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Component}}{no{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{var0/Component}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{no{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{var0/Component}}}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":72892900,"targetExpr":"all c1:Component | no c1 & c1.^parts","createdShorterPath":true}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c:Component | c not in c.parts and c not in c.parts.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{AND{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{!in{var0/Component}{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c : Component | c not in c.^parts","sourceExpr":"all c:Component | c not in c.parts and c not in c.parts.parts","predicate":"inv6","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Move', tree='{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\", \"(type='TreeDelete', tree='{!in{var0/Component}{.{.{var0/Component}{field/parts{set of{sig/Product}}}}{field/parts{set of{sig/Product}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the exclusion operator ('!in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":13,"challenge":"bNCCf9FMRZoxqobfX","time":34941000,"targetExpr":"all c : Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { some c:Component | c not in c.*parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{*{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all c : Component | c not in c.^parts","sourceExpr":"some c:Component | c not in c.*parts","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=*, value=^)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":34167600,"targetExpr":"all c : Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { Component not in Component.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!in{sig/Component}{.{sig/Component}{field/parts{set of{sig/Product}}}}}","nextExpr":"all c : Component | c not in c.parts","sourceExpr":"Component not in Component.parts","predicate":"inv6","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Component}}', parent=all, position=0)\", \"(type='Move', tree='{!in{sig/Component}{.{sig/Component}{field/parts{set of{sig/Product}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Component, value=var0/Component)\", \"(type='Update', node=sig/Component, value=var0/Component)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Component\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":48960300,"targetExpr":"all c : Component | c not in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { } pred inv6 { no c: Component | c in c.parts } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{one of{var0}{sig/Component}}{in{var0/Component}{.{var0/Component}{field/parts{set of{sig/Product}}}}}}","nextExpr":"no c : Component | c in c.^parts","sourceExpr":"no c:Component | c in c.parts","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{no{one of{var0}{sig/Component}}{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{no{one of{var0}{sig/Component}}{in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":47992200,"targetExpr":"no c : Component | c in c.^parts","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c: Component | c not in c.^(parts) } pred inv7 { all c: Component | c in Dangerous <=> some p: c.parts | p in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{<=>{in{var0/Component}{sig/Dangerous}}{some{one of{var1}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{var1/Product}{sig/Dangerous}}}}}","nextExpr":"all c:Component, d:Dangerous | d in c.parts => c in Dangerous","sourceExpr":"all c: Component | c in Dangerous <=> some p: c.parts | p in Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Dangerous}}{=>{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=<=>, value=all)\", \"(type='Update', node=in, value=one of)\", \"(type='Update', node=some, value==>)\", \"(type='Update', node=var0/Component, value=var1)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node=var1, value=var1/Product)\", \"(type='Update', node=var1/Product, value=var0/Component)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Dangerous}}{=>{in{var1/Product}{.{var0/Component}{field/parts{set of{sig/Product}}}}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":113708500,"targetExpr":"all c:Component, d:Dangerous | d in c.parts => c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { Dangerous.parts = Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{sig/Dangerous}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}","nextExpr":"parts.Dangerous in Dangerous","sourceExpr":"Dangerous.parts = Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=sig/Dangerous, parent=., position=2)\", \"(type='Delete', node=sig/Dangerous)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}","totalTED":3,"challenge":"bNCCf9FMRZoxqobfX","time":41158100,"targetExpr":"parts.Dangerous in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { all c : Component | c.^parts in Dangerous => c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{=>{in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}","nextExpr":"all c: Component | (some Dangerous & c.^parts) implies (c in Dangerous)","sourceExpr":"all c : Component | c.^parts in Dangerous implies c in Dangerous","predicate":"inv7","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=0)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":98516600,"targetExpr":"all c: Component | (some Dangerous & c.^parts) implies (c in Dangerous)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { all c : Component | c.^parts in Dangerous iff c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{<=>{in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}","nextExpr":"all c:Component | some c.^parts & Dangerous => c in Dangerous","sourceExpr":"all c : Component | c.^parts in Dangerous iff c in Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=some, parent=<=>, position=0)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","totalTED":3,"challenge":"bNCCf9FMRZoxqobfX","time":34498900,"targetExpr":"all c:Component | some c.^parts & Dangerous => c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | c not in c.^parts } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{!in{var0/Component}{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}}}","nextExpr":"all d : Dangerous | d.^(~parts) in Dangerous","sourceExpr":"all c:Component | c not in c.^parts","predicate":"inv7","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Dangerous}}{in{.{var0/Product}{^{~{field/parts{set of{sig/Product}}}}}}{sig/Dangerous}}}","operations":"[\"(type='Update', node=!in, value=in)\", \"(type='Update', node=sig/Component, value=sig/Dangerous)\", \"(type='Insert', node=sig/Dangerous, parent=!in, position=2)\", \"(type='Update', node=var0/Component, value=var0/Product)\", \"(type='Insert', node=~, parent=^, position=0)\", \"(type='Move', tree='{field/parts{set of{sig/Product}}}', parent=~, position=0)\", \"(type='Delete', node=var0/Component)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Dangerous}}{in{.{var0/Product}{^{~{field/parts{set of{sig/Product}}}}}}{sig/Dangerous}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":33286200,"targetExpr":"all d : Dangerous | d.^(~parts) in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | c.parts in Dangerous implies c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{=>{in{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}","nextExpr":"all c : Component | some c.parts & Dangerous implies c in Dangerous","sourceExpr":"all c: Component | c.parts in Dangerous implies c in Dangerous","predicate":"inv7","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=0)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":55155200,"targetExpr":"all c : Component | some c.parts & Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous = Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}","nextExpr":"parts.Dangerous in Dangerous","sourceExpr":"parts.Dangerous = Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":1,"targetAST":"{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}","operations":"[\"(type='Update', node==, value=in)\"]","hint":"One step away from the solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":32049700,"targetExpr":"parts.Dangerous in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w:Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { workstation in Component -> one Workstation } pred inv4 { all c: Component | c.parts != none all m: Material| no m.parts } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | some c.^parts & Dangerous iff c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{<=>{in{var0/Component}{sig/Dangerous}}{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}}}","nextExpr":"all c: Component | some (Dangerous & c.^parts) => c in Dangerous","sourceExpr":"all c : Component | (some c.^parts & Dangerous) iff (c in Dangerous)","predicate":"inv7","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='TreeInsert', tree='{in{var0/Component}{sig/Dangerous}}', parent=<=>, position=2)\", \"(type='TreeDelete', tree='{in{var0/Component}{sig/Dangerous}}')\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Component}}{=>{some{&{.{var0/Component}{^{field/parts{set of{sig/Product}}}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":51543800,"targetExpr":"all c: Component | some (Dangerous & c.^parts) => c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all d:Dangerous | some d.parts } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Dangerous}}{some{.{var0/Product}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all d : Dangerous | parts.d in Dangerous","sourceExpr":"all d:Dangerous | some d.parts","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Dangerous}}{in{.{field/parts{set of{sig/Product}}}{var0/Product}}{sig/Dangerous}}}","operations":"[\"(type='Update', node=some, value=in)\", \"(type='Insert', node=sig/Dangerous, parent=some, position=1)\", \"(type='Insert', node=var0/Product, parent=., position=2)\", \"(type='Delete', node=var0/Product)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Dangerous}}{in{.{field/parts{set of{sig/Product}}}{var0/Product}}{sig/Dangerous}}}","totalTED":4,"challenge":"bNCCf9FMRZoxqobfX","time":31773300,"targetExpr":"all d : Dangerous | parts.d in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { no iden & ^parts } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{&{^{field/parts{set of{sig/Product}}}}{iden}}}","nextExpr":"^parts.Dangerous in Dangerous","sourceExpr":"no iden & ^parts","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{in{.{^{field/parts{set of{sig/Product}}}}{sig/Dangerous}}{sig/Dangerous}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Update', node=&, value=.)\", \"(type='Insert', node=sig/Dangerous, parent=no, position=1)\", \"(type='Update', node=iden, value=sig/Dangerous)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{.{^{field/parts{set of{sig/Product}}}}{sig/Dangerous}}{sig/Dangerous}}","totalTED":4,"challenge":"bNCCf9FMRZoxqobfX","time":38447500,"targetExpr":"^parts.Dangerous in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all d1, d2:Dangerous | d1->d2 in parts } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Dangerous}}{all{one of{var1}{sig/Dangerous}}{in{->{var0/Product}{var1/Product}}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all c:Component | all d:Dangerous | c->d in parts implies c in Dangerous","sourceExpr":"all d1, d2:Dangerous | d1->d2 in parts","predicate":"inv7","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Dangerous}}{=>{in{->{var0/Component}{var1/Product}}{field/parts{set of{sig/Product}}}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=sig/Dangerous, value=sig/Component)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{in{->{var0/Product}{var1/Product}}{field/parts{set of{sig/Product}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Component}{sig/Dangerous}}', parent==>, position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\"]","hint":"Keep going! Instead of using signature of type Dangerous, try using signature of type Component to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Dangerous}}{=>{in{->{var0/Component}{var1/Product}}{field/parts{set of{sig/Product}}}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":6,"challenge":"bNCCf9FMRZoxqobfX","time":36615300,"targetExpr":"all c:Component | all d:Dangerous | c->d in parts implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all d:Dangerous | some d1: Dangerous | d->d1 in parts } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Dangerous}}{some{one of{var1}{sig/Dangerous}}{in{->{var0/Product}{var1/Product}}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all c:Component | all d:Dangerous | c->d in parts implies c in Dangerous","sourceExpr":"all d:Dangerous | some d1: Dangerous | d->d1 in parts","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Dangerous}}{=>{in{->{var0/Component}{var1/Product}}{field/parts{set of{sig/Product}}}}{in{var0/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Dangerous, value=sig/Component)\", \"(type='Insert', node==>, parent=some, position=1)\", \"(type='Move', tree='{in{->{var0/Product}{var1/Product}}{field/parts{set of{sig/Product}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Component}{sig/Dangerous}}', parent==>, position=1)\", \"(type='Update', node=var0/Product, value=var0/Component)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Dangerous}}{=>{in{->{var0/Component}{var1/Product}}{field/parts{set of{sig/Product}}}}{in{var0/Component}{sig/Dangerous}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":35694700,"targetExpr":"all c:Component | all d:Dangerous | c->d in parts implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all d2:Dangerous | some d1:Dangerous | d1->d2 in parts } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Dangerous}}{some{one of{var1}{sig/Dangerous}}{in{->{var1/Product}{var0/Product}}{field/parts{set of{sig/Product}}}}}}","nextExpr":"all d : Dangerous | all c : Component | c->d in parts implies c in Dangerous","sourceExpr":"all d2:Dangerous | some d1:Dangerous | d1->d2 in parts","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Dangerous}}{all{one of{var1}{sig/Component}}{=>{in{->{var1/Component}{var0/Product}}{field/parts{set of{sig/Product}}}}{in{var1/Component}{sig/Dangerous}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node==>, parent=some, position=1)\", \"(type='Update', node=sig/Dangerous, value=sig/Component)\", \"(type='Move', tree='{in{->{var1/Product}{var0/Product}}{field/parts{set of{sig/Product}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{in{var1/Component}{sig/Dangerous}}', parent==>, position=1)\", \"(type='Update', node=var1/Product, value=var1/Component)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Dangerous}}{all{one of{var1}{sig/Component}}{=>{in{->{var1/Component}{var0/Product}}{field/parts{set of{sig/Product}}}}{in{var1/Component}{sig/Dangerous}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":38610100,"targetExpr":"all d : Dangerous | all c : Component | c->d in parts implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { parts.Dangerous in Dangerous all c : Component | parts.c in Dangerous => c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Component}}{=>{in{.{field/parts{set of{sig/Product}}}{var0/Component}}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}}","nextExpr":"all c : Component | c in parts.Dangerous implies c in Dangerous","sourceExpr":"parts.Dangerous in Dangerous all c : Component | parts.c in Dangerous => c in Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/Component}}{=>{in{.{field/parts{set of{sig/Product}}}{var0/Component}}{sig/Dangerous}}{in{var0/Component}{sig/Dangerous}}}}', parent=root, position=0)\", \"(type='Insert', node=var0/Component, parent=in, position=0)\", \"(type='Update', node=var0/Component, value=sig/Dangerous)\", \"(type='Delete', node=sig/Dangerous)\", \"(type='TreeDelete', tree='{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}}{in{var0/Component}{sig/Dangerous}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":44648300,"targetExpr":"all c : Component | c in parts.Dangerous implies c in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { parts.Dangerous in Dangerous all c : Component | some c.parts & Dangerous <=> c in Dangerous } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Component}}{<=>{in{var0/Component}{sig/Dangerous}}{some{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}}}{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}}","nextExpr":"all x : Component | no x.parts & Dangerous or x in Dangerous","sourceExpr":"parts.Dangerous in Dangerous all c : Component | some c.parts & Dangerous <=> c in Dangerous","predicate":"inv7","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Component}}{OR{in{var0/Component}{sig/Dangerous}}{no{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/Component}}{<=>{in{var0/Component}{sig/Dangerous}}{some{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}}}', parent=root, position=0)\", \"(type='Update', node=<=>, value=OR)\", \"(type='Update', node=some, value=no)\", \"(type='TreeDelete', tree='{in{.{field/parts{set of{sig/Product}}}{sig/Dangerous}}{sig/Dangerous}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Component}}{OR{in{var0/Component}{sig/Dangerous}}{no{&{.{var0/Component}{field/parts{set of{sig/Product}}}}{sig/Dangerous}}}}}","totalTED":10,"challenge":"bNCCf9FMRZoxqobfX","time":42341500,"targetExpr":"all x : Component | no x.parts & Dangerous or x in Dangerous","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c: Component | c not in c.^(parts) } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { all c: Dangerous | no w: Human | w.workers & c.workstation != none } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Dangerous}}{no{one of{var1}{sig/Human}}{!={&{.{var1/Human}{field/workers{set of{sig/Worker}}}}{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}}{none}}}}","nextExpr":"all d : Dangerous, h : Human | h not in (d.workstation).workers","sourceExpr":"all c: Dangerous | no w: Human | w.workers & c.workstation != none","predicate":"inv8","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Dangerous}}{all{one of{var1}{sig/Human}}{!in{var1/Human}{.{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=!=, value=!in)\", \"(type='Move', tree='{var1/Human}', parent=!=, position=0)\", \"(type='Insert', node=., parent=!=, position=1)\", \"(type='Move', tree='{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}', parent=., position=0)\", \"(type='Insert', node=field/workers, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/workers, position=0)\", \"(type='Update', node=none, value=sig/Worker)\", \"(type='Move', tree='{none}', parent=set of, position=0)\", \"(type='TreeDelete', tree='{field/workers{set of{sig/Worker}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Dangerous}}{all{one of{var1}{sig/Human}}{!in{var1/Human}{.{.{var0/Product}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}}}}","totalTED":11,"challenge":"bNCCf9FMRZoxqobfX","time":113678300,"targetExpr":"all d : Dangerous, h : Human | h not in (d.workstation).workers","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | some (c.parts & Dangerous) implies c in Dangerous } pred inv8 { all c:Component, ws:Workstation | c in Dangerous implies no w:ws.workers | w in Human } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Workstation}}{=>{in{var0/Component}{sig/Dangerous}}{no{one of{var2}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}{in{var2/Worker}{sig/Human}}}}}}","nextExpr":"all c:Component, h:Human | c in Dangerous => h not in c.workstation.workers","sourceExpr":"all c:Component, ws:Workstation | c in Dangerous implies no w:ws.workers | w in Human","predicate":"inv8","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Human}}{=>{in{var0/Component}{sig/Dangerous}}{!in{var1/Human}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}}}}}","operations":"[\"(type='Update', node=sig/Workstation, value=sig/Human)\", \"(type='Update', node=one of, value=!in)\", \"(type='Move', tree='{one of{var2}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}', parent==>, position=1)\", \"(type='Update', node=var2, value=var1/Human)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=var1/Workstation, value=var0/Component)\", \"(type='Move', tree='{var1/Workstation}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{in{var2/Worker}{sig/Human}}')\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using signature of type Workstation, try using signature of type Human to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Human}}{=>{in{var0/Component}{sig/Dangerous}}{!in{var1/Human}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}}}}}","totalTED":12,"challenge":"bNCCf9FMRZoxqobfX","time":59861900,"targetExpr":"all c:Component, h:Human | c in Dangerous => h not in c.workstation.workers","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { all w: Worker | w in Human + Robot } pred inv2 { workers in Workstation one -> some Worker } pred inv3 { all c: Component | one c.workstation } pred inv4 { all c: Component | some c.parts all m: Material | m.parts = none } pred inv5 { no workers.Human & workers.Robot } pred inv6 { all c: Component | c not in c.^(parts) } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { all c: Component | c in Dangerous implies no workers.Human } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{sig/Dangerous}}{no{.{field/workers{set of{sig/Worker}}}{sig/Human}}}}}","nextExpr":"all c: Component | c in Dangerous => no (c.workstation.workers & Human)","sourceExpr":"all c: Component | c in Dangerous implies no workers.Human","predicate":"inv8","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{sig/Dangerous}}{no{&{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}","operations":"[\"(type='Update', node=., value=&)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}', parent=., position=0)\", \"(type='Move', tree='{field/workers{set of{sig/Worker}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Component}}{=>{in{var0/Component}{sig/Dangerous}}{no{&{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Human}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":36767800,"targetExpr":"all c: Component | c in Dangerous => no (c.workstation.workers & Human)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { all c:Component,ws:c.workstation | c in Dangerous implies no w: ws.workers | w not in Human } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}}{=>{in{var0/Component}{sig/Dangerous}}{no{one of{var2}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}{!in{var2/Worker}{sig/Human}}}}}}","nextExpr":"all c : Component | all w : Worker | (c in Dangerous and w in c.workstation.workers) implies w not in Human","sourceExpr":"all c:Component,ws:c.workstation | c in Dangerous implies no w: ws.workers | w not in Human","predicate":"inv8","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Worker}}{=>{AND{in{var0/Component}{sig/Dangerous}}{in{var1/Worker}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}}}{!in{var1/Worker}{sig/Human}}}}}","operations":"[\"(type='Update', node=var0/Component, value=sig/Worker)\", \"(type='Move', tree='{var0/Component}', parent=one of, position=1)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{!in{var2/Worker}{sig/Human}}', parent==>, position=1)\", \"(type='Move', tree='{in{var0/Component}{sig/Dangerous}}', parent=AND, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{.{var1/Workstation}{field/workers{set of{sig/Worker}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Worker, value=var1/Worker)\", \"(type='Update', node=var2, value=var1/Worker)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=var1/Workstation, value=var0/Component)\", \"(type='Move', tree='{var1/Workstation}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/workstation{set of{sig/Workstation}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using variable of type Component, try using signature of type Worker to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Component}}{all{one of{var1}{sig/Worker}}{=>{AND{in{var0/Component}{sig/Dangerous}}{in{var1/Worker}{.{.{var0/Component}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}}}{!in{var1/Worker}{sig/Human}}}}}","totalTED":15,"challenge":"bNCCf9FMRZoxqobfX","time":42301700,"targetExpr":"all c : Component | all w : Worker | (c in Dangerous and w in c.workstation.workers) implies w not in Human","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { (Workstation.workstation).workers in Robot } pred inv9 { } pred inv10 { }","sourceAST":"{in{.{.{sig/Workstation}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","nextExpr":"Dangerous.workstation.workers in Robot","sourceExpr":"(Workstation.workstation).workers in Robot","predicate":"inv8","isNewNode":true,"srcDstTED":1,"targetAST":"{in{.{.{sig/Dangerous}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","operations":"[\"(type='Update', node=sig/Workstation, value=sig/Dangerous)\"]","hint":"One step away from the solution! Instead of using signature of type Workstation, try using signature of type Dangerous to help satisfy the required property.","nextAST":"{in{.{.{sig/Dangerous}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":35012000,"targetExpr":"Dangerous.workstation.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { ~workers.((~workstation).Component) in Robot } pred inv9 { } pred inv10 { }","sourceAST":"{in{.{~{field/workers{set of{sig/Worker}}}}{.{~{field/workstation{set of{sig/Workstation}}}}{sig/Component}}}{sig/Robot}}","nextExpr":"Dangerous.workstation.workers in Robot","sourceExpr":"~workers.((~workstation).Component) in Robot","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{.{sig/Dangerous}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","operations":"[\"(type='Update', node=~, value=.)\", \"(type='Update', node=field/workstation, value=field/workers)\", \"(type='Move', tree='{field/workstation{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Insert', node=sig/Dangerous, parent=~, position=0)\", \"(type='Update', node=field/workers, value=field/workstation)\", \"(type='Update', node=sig/Workstation, value=sig/Worker)\", \"(type='Update', node=sig/Worker, value=sig/Workstation)\", \"(type='Delete', node=~)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using transpose operator ('~') to transpose a relation, try using dot join operator ('.') to perform a relational join between sets or relations.","nextAST":"{in{.{.{sig/Dangerous}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","totalTED":9,"challenge":"bNCCf9FMRZoxqobfX","time":35472800,"targetExpr":"Dangerous.workstation.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { (workstation.Component).workers in Robot } pred inv9 { } pred inv10 { }","sourceAST":"{in{.{.{field/workstation{set of{sig/Workstation}}}{sig/Component}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","nextExpr":"Dangerous.workstation.workers in Robot","sourceExpr":"(workstation.Component).workers in Robot","predicate":"inv8","isNewNode":true,"srcDstTED":2,"targetAST":"{in{.{.{sig/Dangerous}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","operations":"[\"(type='Insert', node=sig/Dangerous, parent=., position=0)\", \"(type='Delete', node=sig/Component)\"]","hint":"Near a solution! Consider adding a signature of type Dangerous to help satisfy the required property. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{in{.{.{sig/Dangerous}{field/workstation{set of{sig/Workstation}}}}{field/workers{set of{sig/Worker}}}}{sig/Robot}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":31198900,"targetExpr":"Dangerous.workstation.workers in Robot","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { parts.Dangerous in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { no iden & ^succ } pred inv10 { }","sourceAST":"{no{&{^{field/succ{set of{sig/Workstation}}}}{iden}}}","nextExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","sourceExpr":"no ^succ & iden","predicate":"inv9","isNewNode":false,"srcDstTED":20,"targetAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=&, value=AND)\", \"(type='Move', tree='{&{^{field/succ{set of{sig/Workstation}}}}{iden}}', parent=root, position=0)\", \"(type='Update', node=^, value=in)\", \"(type='Insert', node=in, parent=&, position=1)\", \"(type='TreeInsert', tree='{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}', parent=&, position=2)\", \"(type='TreeInsert', tree='{lone->lone{sig/Workstation}{sig/Workstation}}', parent=^, position=1)\", \"(type='Update', node=iden, value=sig/Workstation)\", \"(type='Move', tree='{iden}', parent=in, position=0)\", \"(type='TreeInsert', tree='{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using intersection operator ('&') to find the common elements between two sets, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":20,"challenge":"bNCCf9FMRZoxqobfX","time":190247800,"targetExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","createdShorterPath":true}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { all c:Component,ws:c.workstation | c in Dangerous implies no w: ws.workers | w in Human all c:Dangerous,ws:c.workstation | no w: ws.workers | w in Human all c:Dangerous,ws:c.workstation,w: ws.workers | w not in Human all c:Dangerous | no c.workstation.workers & Human no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","nextExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w:Workstation-end | one w.succ no end.succ","predicate":"inv9","isNewNode":false,"srcDstTED":8,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='TreeInsert', tree='{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":8,"challenge":"bNCCf9FMRZoxqobfX","time":64374200,"targetExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { begin.*succ = end } pred inv10 { }","sourceAST":"{={.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}{sig/end}}","nextExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","sourceExpr":"begin.*succ = end","predicate":"inv9","isNewNode":true,"srcDstTED":15,"targetAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node==, value=AND)\", \"(type='TreeInsert', tree='{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}', parent==, position=0)\", \"(type='Insert', node=in, parent==, position=1)\", \"(type='Insert', node=no, parent==, position=2)\", \"(type='Insert', node=sig/Workstation, parent=in, position=0)\", \"(type='Move', tree='{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='Insert', node=., parent=no, position=0)\", \"(type='Move', tree='{sig/end}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":15,"challenge":"bNCCf9FMRZoxqobfX","time":92372900,"targetExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { begin.succ = end } pred inv10 { }","sourceAST":"{={.{sig/begin}{field/succ{set of{sig/Workstation}}}}{sig/end}}","nextExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","sourceExpr":"begin.succ = end","predicate":"inv9","isNewNode":true,"srcDstTED":16,"targetAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node==, value=AND)\", \"(type='TreeInsert', tree='{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}', parent==, position=0)\", \"(type='Insert', node=in, parent==, position=1)\", \"(type='Insert', node=no, parent==, position=2)\", \"(type='Insert', node=sig/Workstation, parent=in, position=0)\", \"(type='Move', tree='{.{sig/begin}{field/succ{set of{sig/Workstation}}}}', parent=in, position=1)\", \"(type='Insert', node=., parent=no, position=0)\", \"(type='Insert', node=*, parent=., position=1)\", \"(type='Move', tree='{sig/end}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=*, position=0)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":16,"challenge":"bNCCf9FMRZoxqobfX","time":69067200,"targetExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { no Worker - Robot - Human } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { Component = parts.Product } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ end in begin.*succ } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/end}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","nextExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w:Workstation-end | one w.succ no end.succ end in begin.*succ","predicate":"inv9","isNewNode":true,"srcDstTED":1,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=sig/end, value=sig/Workstation)\"]","hint":"One step away from the solution! Instead of using signature of type end, try using signature of type Workstation to help satisfy the required property.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":1,"challenge":"bNCCf9FMRZoxqobfX","time":34553200,"targetExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | some (c.parts & Dangerous) implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation - end | one w.succ no end.succ some begin.*succ } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}{some{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w:Workstation - end | one w.succ no end.succ some begin.*succ","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Update', node=some, value=no)\", \"(type='Insert', node=sig/Workstation, parent=no, position=0)\", \"(type='Update', node=sig/end, value=sig/begin)\", \"(type='Insert', node=*, parent=., position=1)\", \"(type='Update', node=sig/begin, value=sig/end)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=*, position=0)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":50567900,"targetExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | some (c.parts & Dangerous) implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all b:begin, e:end | end in b.^succ and b != e } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/begin}}{all{one of{var1}{sig/end}}{AND{!={var0/Workstation}{var1/Workstation}}{in{sig/end}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}}}","nextExpr":"Workstation in begin.*succ no end.^succ all w : Workstation | lone w.succ","sourceExpr":"all b:begin, e:end | end in b.^succ and b != e","predicate":"inv9","isNewNode":true,"srcDstTED":22,"targetAST":"{AND{all{one of{var0}{sig/Workstation}}{lone{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{^{field/succ{set of{sig/Workstation}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Insert', node=in, parent=all, position=1)\", \"(type='Update', node=in, value=no)\", \"(type='Move', tree='{in{sig/end}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}', parent=all, position=2)\", \"(type='Move', tree='{one of{var0}{sig/begin}}', parent=all, position=0)\", \"(type='Insert', node=lone, parent=all, position=1)\", \"(type='Insert', node=sig/Workstation, parent=in, position=0)\", \"(type='Update', node=!=, value=.)\", \"(type='Move', tree='{!={var0/Workstation}{var1/Workstation}}', parent=in, position=1)\", \"(type='Update', node=sig/begin, value=sig/Workstation)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var1}{sig/end}}', parent=lone, position=0)\", \"(type='Update', node=var0/Workstation, value=sig/begin)\", \"(type='Insert', node=*, parent=!=, position=1)\", \"(type='Update', node=var0/Workstation, value=sig/end)\", \"(type='Update', node=var1, value=var0/Workstation)\", \"(type='Insert', node=field/succ, parent=one of, position=1)\", \"(type='Insert', node=field/succ, parent=*, position=0)\", \"(type='Insert', node=set of, parent=field/succ, position=0)\", \"(type='Insert', node=set of, parent=field/succ, position=0)\", \"(type='Update', node=sig/end, value=sig/Workstation)\", \"(type='Move', tree='{sig/end}', parent=set of, position=0)\", \"(type='Update', node=var1/Workstation, value=sig/Workstation)\", \"(type='Move', tree='{var1/Workstation}', parent=set of, position=0)\", \"(type='Delete', node=sig/end)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Workstation}}{lone{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{^{field/succ{set of{sig/Workstation}}}}}}}","totalTED":22,"challenge":"bNCCf9FMRZoxqobfX","time":41880700,"targetExpr":"Workstation in begin.*succ no end.^succ all w : Workstation | lone w.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { all c:Component,ws:c.workstation | c in Dangerous implies no w: ws.workers | w in Human all c:Dangerous,ws:c.workstation | no w: ws.workers | w in Human all c:Dangerous,ws:c.workstation,w: ws.workers | w not in Human all c:Dangerous | no c.workstation.workers & Human no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation-end | one w.succ no end.succ end in begin.^succ } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/end}{.{sig/begin}{^{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","nextExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w:Workstation-end | one w.succ no end.succ end in begin.^succ","predicate":"inv9","isNewNode":true,"srcDstTED":2,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=sig/end, value=sig/Workstation)\", \"(type='Update', node=^, value=*)\"]","hint":"Near a solution! Instead of using signature of type end, try using signature of type Workstation to help satisfy the required property.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":2,"challenge":"bNCCf9FMRZoxqobfX","time":50382700,"targetExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { begin.succ in end } pred inv10 { }","sourceAST":"{in{.{sig/begin}{field/succ{set of{sig/Workstation}}}}{sig/end}}","nextExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","sourceExpr":"begin.succ in end","predicate":"inv9","isNewNode":true,"srcDstTED":16,"targetAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=in, value=AND)\", \"(type='TreeInsert', tree='{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}', parent=in, position=0)\", \"(type='Insert', node=in, parent=in, position=1)\", \"(type='Insert', node=no, parent=in, position=2)\", \"(type='Insert', node=sig/Workstation, parent=in, position=0)\", \"(type='Move', tree='{.{sig/begin}{field/succ{set of{sig/Workstation}}}}', parent=in, position=1)\", \"(type='Insert', node=., parent=no, position=0)\", \"(type='Insert', node=*, parent=., position=1)\", \"(type='Move', tree='{sig/end}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=*, position=0)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":16,"challenge":"bNCCf9FMRZoxqobfX","time":37343900,"targetExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker in Human + Robot } pred inv2 { all w:Worker | one w.~workers all w:Workstation | some w.workers } pred inv3 { all c:Component | one c.workstation } pred inv4 { parts.Product = Component } pred inv5 { no workers.Human & workers.Robot } pred inv6 { no iden & ^parts } pred inv7 { all c:Component | some c.parts & Dangerous implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { begin.^succ = end } pred inv10 { }","sourceAST":"{={.{sig/begin}{^{field/succ{set of{sig/Workstation}}}}}{sig/end}}","nextExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","sourceExpr":"begin.^succ = end","predicate":"inv9","isNewNode":false,"srcDstTED":16,"targetAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node==, value=AND)\", \"(type='TreeInsert', tree='{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}', parent==, position=0)\", \"(type='Insert', node=in, parent==, position=1)\", \"(type='Insert', node=no, parent==, position=2)\", \"(type='Insert', node=sig/Workstation, parent=in, position=0)\", \"(type='Move', tree='{.{sig/begin}{^{field/succ{set of{sig/Workstation}}}}}', parent=in, position=1)\", \"(type='Insert', node=., parent=no, position=0)\", \"(type='Update', node=^, value=*)\", \"(type='Move', tree='{sig/end}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":16,"challenge":"bNCCf9FMRZoxqobfX","time":78809400,"targetExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | some (c.parts & Dangerous) implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all w:Workstation - end | one w.succ no end.succ some begin.^succ } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}{some{.{sig/begin}{^{field/succ{set of{sig/Workstation}}}}}}}","nextExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","sourceExpr":"all w:Workstation - end | one w.succ no end.succ some begin.^succ","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Update', node=some, value=no)\", \"(type='Insert', node=sig/Workstation, parent=no, position=0)\", \"(type='Update', node=sig/end, value=sig/begin)\", \"(type='Insert', node=*, parent=., position=1)\", \"(type='Update', node=sig/begin, value=sig/end)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=., position=1)\", \"(type='Move', tree='{field/succ{set of{sig/Workstation}}}', parent=*, position=0)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{AND{all{one of{var0}{-{sig/Workstation}{sig/end}}}{one{.{var0/Workstation}{field/succ{set of{sig/Workstation}}}}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":7,"challenge":"bNCCf9FMRZoxqobfX","time":43887400,"targetExpr":"all w:Workstation-end | one w.succ no end.succ Workstation in begin.*succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig Workstation { workers : set Worker, succ : set Workstation } one sig begin, end in Workstation {} sig Worker {} sig Human, Robot extends Worker {} abstract sig Product { parts : set Product } sig Material extends Product {} sig Component extends Product { workstation : set Workstation } sig Dangerous in Product {} pred inv1 { Worker = Human + Robot } pred inv2 { all w:Worker | one workers.w Workstation = workers.Worker } pred inv3 { all c:Component | one c.workstation } pred inv4 { all c:Component | some c.parts all m:Material | no m.parts } pred inv5 { no (workers.Human & workers.Robot) } pred inv6 { all c:Component | c not in c.^parts } pred inv7 { all c:Component | some (c.parts & Dangerous) implies c in Dangerous } pred inv8 { no Dangerous.workstation.workers & Human } pred inv9 { all b:begin, e:end | end in b.^succ } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/begin}}{all{one of{var1}{sig/end}}{in{sig/end}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}}}","nextExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","sourceExpr":"all b:begin, e:end | end in b.^succ","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=in, parent=all, position=0)\", \"(type='Move', tree='{in{sig/end}{.{var0/Workstation}{^{field/succ{set of{sig/Workstation}}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}', parent=all, position=2)\", \"(type='Insert', node=field/succ, parent=in, position=0)\", \"(type='Update', node=one of, value=lone->lone)\", \"(type='Move', tree='{one of{var1}{sig/end}}', parent=in, position=1)\", \"(type='Update', node=sig/end, value=sig/Workstation)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var0}{sig/begin}}', parent=field/succ, position=0)\", \"(type='Update', node=var1, value=sig/Workstation)\", \"(type='Update', node=sig/end, value=sig/Workstation)\", \"(type='Update', node=var0/Workstation, value=sig/begin)\", \"(type='Update', node=^, value=*)\", \"(type='Update', node=var0, value=sig/Workstation)\", \"(type='Delete', node=sig/begin)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{field/succ{set of{sig/Workstation}}}{lone->lone{sig/Workstation}{sig/Workstation}}}{in{sig/Workstation}{.{sig/begin}{*{field/succ{set of{sig/Workstation}}}}}}{no{.{sig/end}{field/succ{set of{sig/Workstation}}}}}}","totalTED":19,"challenge":"bNCCf9FMRZoxqobfX","time":41191799,"targetExpr":"succ in Workstation lone -> lone Workstation Workstation in begin.*succ no end.succ","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | all u:User | (p in u.posts) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p: Photo, u: one User | p in u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=all, value=one)\"]","hint":"One step away from the solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":176904400,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo|all u:User|#(~posts[p])<=1 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{<={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}}}","nextExpr":"all x: Photo | #(x.~posts) = 1","sourceExpr":"all p:Photo|all u:User|#(~posts[p])<=1","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}}","operations":"[\"(type='Update', node=<=, value==)\", \"(type='Move', tree='{<={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{one of{var1}{sig/User}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using <=, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/Photo}}{={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":122616900,"targetExpr":"all x: Photo | #(x.~posts) = 1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | some u:User | u -> p in posts } pred inv2 { no u:User | u->u in follows } pred inv3 { all u1:User,p:Photo | u1 -> p in sees implies (some u2:User | u2 -> p in posts and u1 -> u2 in follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all p : Photo | one u : User | u->p in posts","sourceExpr":"all x : Photo | some y : User | y->x in posts","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Update', node=some, value=one)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":119815800,"targetExpr":"all p : Photo | one u : User | u->p in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u: User | all p: Photo | some p.~posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{some{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}}}}","nextExpr":"all p: Photo | one p.~posts","sourceExpr":"one u: User | all p: Photo | some p.~posts","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var1}{sig/Photo}}{some{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=one)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=var1/Photo, value=var0/Photo)\", \"(type='TreeDelete', tree='{one of{var0}{sig/User}}')\", \"(type='Delete', node=one)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":42246800,"targetExpr":"all p: Photo | one p.~posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo, u:User | u->p in posts implies one u } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{one{var1/User}}}}}","nextExpr":"all x : Photo | one y : User | y -> x in posts","sourceExpr":"all p:Photo, u:User | u->p in posts implies one u","predicate":"inv1","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Move', tree='{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{one{var1/User}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":38160400,"targetExpr":"all x : Photo | one y : User | y -> x in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | some u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p: Photo | some u : User | p in u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=some, value=one)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":114538800,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1, u2: User, p1 : Photo | u1->p1 in posts and u2->p1 in posts implies u1=u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"all u1,u2:User | all p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all x : Photo | some y: User | y->x in posts","sourceExpr":"all x,y : User, p : Photo | (x->p in posts and y->p in posts) implies x = y","predicate":"inv1","isNewNode":false,"srcDstTED":16,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}{all{one of{var3}{sig/Photo}}{some{one of{var4}{sig/User}}{in{->{var4/User}{var3/Photo}}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{all{one of{var3}{sig/Photo}}{some{one of{var4}{sig/User}}{in{->{var4/User}{var3/Photo}}{field/posts{set of{sig/Photo}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}{all{one of{var3}{sig/Photo}}{some{one of{var4}{sig/User}}{in{->{var4/User}{var3/Photo}}{field/posts{set of{sig/Photo}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":121932801,"targetExpr":"all u1,u2:User | all p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all x : Photo | some y: User | y->x in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo,u1,u2:User | p in u1.posts and p in u2.posts implies u1=u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}{={var1/User}{var2/User}}}}}}","nextExpr":"all p : Photo | p in User.posts all p : Photo | all user1,user2 : User | (p in user1.posts and p in user2.posts) implies user1=user2","sourceExpr":"all x : Photo | all y, z : User | x in y.posts and x in z.posts implies y = z","predicate":"inv1","isNewNode":false,"srcDstTED":12,"targetAST":"{AND{all{one of{var0}{sig/Photo}}{in{var0/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}{={var1/User}{var2/User}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Photo}}{in{var0/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}{={var1/User}{var2/User}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Photo}}{in{var0/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}{={var1/User}{var2/User}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":94159600,"targetExpr":"all p : Photo | p in User.posts all p : Photo | all user1,user2 : User | (p in user1.posts and p in user2.posts) implies user1=user2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User lone -> one Photo } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/posts{set of{sig/Photo}}}{lone->one{sig/User}{sig/Photo}}}","nextExpr":"posts in User one -> set Photo","sourceExpr":"posts in User lone -> one Photo","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","operations":"[\"(type='Update', node=lone->one, value=one->)\"]","hint":"One step away from the solution! Instead of using lone->one, try using one-> to help satisfy the required property.","nextAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":40800899,"targetExpr":"posts in User one -> set Photo","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts.~posts in iden } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{.{field/posts{set of{sig/Photo}}}{~{field/posts{set of{sig/Photo}}}}}{iden}}","nextExpr":"posts.~posts in iden and Photo in User.posts","sourceExpr":"posts.~posts in iden","predicate":"inv1","isNewNode":false,"srcDstTED":8,"targetAST":"{AND{in{.{field/posts{set of{sig/Photo}}}{~{field/posts{set of{sig/Photo}}}}}{iden}}{in{sig/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{in{.{field/posts{set of{sig/Photo}}}{~{field/posts{set of{sig/Photo}}}}}{iden}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{sig/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{in{.{field/posts{set of{sig/Photo}}}{~{field/posts{set of{sig/Photo}}}}}{iden}}{in{sig/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":131085800,"targetExpr":"posts.~posts in iden and Photo in User.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | all u : User | p = u.posts } pred inv2 { all u : User | u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u : User, a : Ad | a in u.posts => u.posts in Ad } pred inv5 { all i : Influencer, u : User | u!=i => i in u.follows } pred inv6 { all i : Influencer, d : Day | d in i.posts.date } pred inv7 { all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested } pred inv8 { all a : Ad, u : User | a in u.sees => a in u.follows.posts or a in u.suggested.posts }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{={.{var1/User}{field/posts{set of{sig/Photo}}}}{var0/Photo}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p : Photo | all u : User | p = u.posts","predicate":"inv1","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var0/Photo, parent==, position=0)\", \"(type='Delete', node=var0/Photo)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":51519100,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u:User|some u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{some{.{var0/User}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"one u: User | some u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=some, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/User)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":104863800,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { ~posts.~posts in iden } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{.{~{field/posts{set of{sig/Photo}}}}{~{field/posts{set of{sig/Photo}}}}}{iden}}","nextExpr":"~posts in Photo set -> one User","sourceExpr":"~posts.~posts in iden","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{in{~{field/posts{set of{sig/Photo}}}}{->one{sig/Photo}{sig/User}}}","operations":"[\"(type='Move', tree='{~{field/posts{set of{sig/Photo}}}}', parent=in, position=0)\", \"(type='Update', node=set of, value=->one)\", \"(type='Move', tree='{set of{sig/Photo}}', parent=in, position=1)\", \"(type='Insert', node=sig/User, parent=set of, position=1)\", \"(type='Delete', node=field/posts)\", \"(type='Delete', node=~)\", \"(type='Delete', node=.)\", \"(type='Delete', node=iden)\"]","hint":"Keep going! It seems like the transpose operator ('~') is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{in{~{field/posts{set of{sig/Photo}}}}{->one{sig/Photo}{sig/User}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":39986801,"targetExpr":"~posts in Photo set -> one User","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | lone u:User | p in u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{lone{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p:Photo | lone u:User | p in u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=lone, value=one)\"]","hint":"One step away from the solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":91896500,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u: User| u in u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{in{var0/User}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"one u: User| u in u.posts","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=in, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=var0/User)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":43029500,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u: User | one p: Photo | u.posts in p } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Photo}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Photo}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all u: User | one p: Photo | u.posts in p","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Insert', node=var0/Photo, parent=in, position=0)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Delete', node=var1/Photo)\"]","hint":"Keep going! Instead of using signature of type User, try using signature of type Photo to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":36721801,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1, u2: User, p1 : Photo | (u1->p1 in posts or u1->p1 in sees) and u2->p1 in posts implies u1=u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{OR{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","sourceExpr":"all u1, u2: User, p1 : Photo | (u1->p1 in posts or u1->p1 in sees) and u2->p1 in posts implies u1=u2","predicate":"inv1","isNewNode":true,"srcDstTED":19,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{OR{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}', parent=AND, position=1)\", \"(type='Update', node=all, value==>)\", \"(type='Insert', node=some, parent=all, position=0)\", \"(type='Move', tree='{={var0/User}{var1/User}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Photo}}', parent=some, position=0)\", \"(type='Move', tree='{AND{OR{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}', parent=some, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='TreeDelete', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}')\", \"(type='Delete', node=OR)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","totalTED":19,"challenge":"dkZH6HJNQNLLDX6Aj","time":74743300,"targetExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u:User|u.posts in Photo } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Photo}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all u: User | u.posts in Photo","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=in, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=sig/Photo)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":110366900,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo |all u: User| p in (one u.posts) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{in{var0/Photo}{one of{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all x:Photo | all y:User | x in (one y.posts)","predicate":"inv1","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Move', tree='{.{var1/User}{field/posts{set of{sig/Photo}}}}', parent=in, position=1)\", \"(type='Delete', node=one of)\"]","hint":"Near a solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":123042500,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User.posts | p = u } pred inv2 { all u : User | u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u : User, a : Ad | a in u.posts => u.posts in Ad } pred inv5 { all i : Influencer, u : User | u!=i => i in u.follows } pred inv6 { all i : Influencer, d : Day | d in i.posts.date } pred inv7 { all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested } pred inv8 { all a : Ad, u : User | a in u.sees => a in u.follows.posts or a in u.suggested.posts }","sourceAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{.{sig/User}{field/posts{set of{sig/Photo}}}}}{={var0/Photo}{var1/Photo}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all p : Photo | one u : User.posts | p = u","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Move', tree='{.{sig/User}{field/posts{set of{sig/Photo}}}}', parent=one, position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='TreeDelete', tree='{={var0/Photo}{var1/Photo}}')\"]","hint":"Keep going! It seems like the dot join operator ('.') is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":36783901,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> one Photo } pred inv2 { all u:User | u not in u.follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/posts{set of{sig/Photo}}}{one->one{sig/User}{sig/Photo}}}","nextExpr":"posts in User one -> set Photo","sourceExpr":"posts in User one -> one Photo","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","operations":"[\"(type='Update', node=one->one, value=one->)\"]","hint":"One step away from the solution! Instead of using one->one, try using one-> to help satisfy the required property.","nextAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":37748700,"targetExpr":"posts in User one -> set Photo","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { Photo in User.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{sig/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"Photo in User.posts","predicate":"inv1","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=in, value=all)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Insert', node=one, parent=in, position=1)\", \"(type='Insert', node=var0, parent=one of, position=0)\", \"(type='Move', tree='{sig/Photo}', parent=one of, position=1)\", \"(type='Move', tree='{.{sig/User}{field/posts{set of{sig/Photo}}}}', parent=one, position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=sig/User)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":126769599,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | p in User.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{in{var0/Photo}{.{sig/User}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all p:Photo | p in User.posts","predicate":"inv1","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=in, value=one)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/Photo)\", \"(type='Delete', node=sig/User)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":127697199,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1, u2: User, p1 : Photo | p1->u1 in posts and p1->u2 in posts implies u1=u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var2/Photo}{var0/User}}{field/posts{set of{sig/Photo}}}}{in{->{var2/Photo}{var1/User}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"all x,y : User, p : Photo | (x->p in posts and y->p in posts) implies x = y","sourceExpr":"all x,y: User | all p: Photo | p->x in posts and p->y in posts implies y=x","predicate":"inv1","isNewNode":false,"srcDstTED":20,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}{all{one of{var3}{sig/Photo}}{some{one of{var4}{sig/User}}{in{->{var4/User}{var3/Photo}}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Insert', node=var0/User, parent=->, position=0)\", \"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the arrow operator ('->') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":101046301,"targetExpr":"all u1,u2:User | all p:Photo | (u1->p in posts and u2->p in posts) implies u1=u2 all x:Photo | some y:User | y->x in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo|all u:User|some p.~posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{some{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}}","nextExpr":"all img : Photo | one u : User | u in img.~(posts)","sourceExpr":"all p:Photo|all u:User|some p.~posts","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var1/User}{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Update', node=some, value=in)\", \"(type='Insert', node=var1/User, parent=some, position=0)\"]","hint":"Near a solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var1/User}{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":40264500,"targetExpr":"all img : Photo | one u : User | u in img.~(posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p = u.posts } pred inv2 { all u : User | u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u : User, a : Ad | a in u.posts => u.posts in Ad } pred inv5 { all i : Influencer, u : User | u!=i => i in u.follows } pred inv6 { all i : Influencer, d : Day | d in i.posts.date } pred inv7 { all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested } pred inv8 { all a : Ad, u : User | a in u.sees => a in u.follows.posts or a in u.suggested.posts }","sourceAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{={.{var1/User}{field/posts{set of{sig/Photo}}}}{var0/Photo}}}}","nextExpr":"all x : Photo | one y : User | y -> x in posts","sourceExpr":"all p:Photo | one u:User | u.posts = p","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Update', node=., value=in)\", \"(type='Move', tree='{.{var1/User}{field/posts{set of{sig/Photo}}}}', parent=one, position=1)\", \"(type='Insert', node=->, parent=., position=0)\", \"(type='Move', tree='{var1/User}', parent=->, position=0)\", \"(type='Insert', node=var0/Photo, parent=->, position=1)\", \"(type='Delete', node=var0/Photo)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":117913099,"targetExpr":"all x : Photo | one y : User | y -> x in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo|#(p.~posts)<=1 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{<={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}}","nextExpr":"all x: Photo | #(x.~posts) = 1","sourceExpr":"all p:Photo|#(p.~posts)<=1","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}}","operations":"[\"(type='Update', node=<=, value==)\"]","hint":"One step away from the solution! Instead of using <=, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/Photo}}{={#{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}{1}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":32228699,"targetExpr":"all x: Photo | #(x.~posts) = 1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo, u1, u2 : User | u1 -> p in posts and u2 -> p in posts => u1 = u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var1/User}{var2/User}}}}}}","nextExpr":"all p:Photo, u1,u2:User | u1->p in posts and u2->p in posts => u1 = u2 all p:Photo | some u:User | u->p in posts","sourceExpr":"all p : Photo | all u, v : User | u->p in posts and v->p in posts implies u=v","predicate":"inv1","isNewNode":false,"srcDstTED":16,"targetAST":"{AND{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var1/User}{var2/User}}}}}}{all{one of{var0}{sig/Photo}}{some{one of{var3}{sig/User}}{in{->{var3/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var1/User}{var2/User}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Photo}}{some{one of{var3}{sig/User}}{in{->{var3/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var1/User}{var2/User}}}}}}{all{one of{var0}{sig/Photo}}{some{one of{var3}{sig/User}}{in{->{var3/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":111048901,"targetExpr":"all p:Photo, u1,u2:User | u1->p in posts and u2->p in posts => u1 = u2 all p:Photo | some u:User | u->p in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User.posts | p = p } pred inv2 { all u : User | u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u : User, a : Ad | a in u.posts => u.posts in Ad } pred inv5 { all i : Influencer, u : User | u!=i => i in u.follows } pred inv6 { all i : Influencer, d : Day | d in i.posts.date } pred inv7 { all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested } pred inv8 { all a : Ad, u : User | a in u.sees => a in u.follows.posts or a in u.suggested.posts }","sourceAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{.{sig/User}{field/posts{set of{sig/Photo}}}}}{={var0/Photo}{var0/Photo}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all p : Photo | one u : User.posts | p = p","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Move', tree='{.{sig/User}{field/posts{set of{sig/Photo}}}}', parent=one, position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='TreeDelete', tree='{={var0/Photo}{var0/Photo}}')\"]","hint":"Keep going! It seems like the dot join operator ('.') is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":40476700,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1, u2: User, p1 : Photo | (u1->p1 in posts or u1->p1 in sees) and (u2->p1 in posts or u2->p1 in sees) implies u1=u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{OR{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{OR{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","sourceExpr":"all u1, u2: User, p1 : Photo | (u1->p1 in posts or u1->p1 in sees) and (u2->p1 in posts or u2->p1 in sees) implies u1=u2","predicate":"inv1","isNewNode":true,"srcDstTED":27,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{OR{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{OR{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}', parent=AND, position=1)\", \"(type='Update', node=all, value==>)\", \"(type='Insert', node=some, parent=all, position=0)\", \"(type='Move', tree='{={var0/User}{var1/User}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Photo}}', parent=some, position=0)\", \"(type='Move', tree='{AND{OR{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{OR{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}}', parent=some, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='TreeDelete', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}')\", \"(type='Delete', node=OR)\", \"(type='TreeDelete', tree='{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}')\", \"(type='Delete', node=OR)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","totalTED":27,"challenge":"dkZH6HJNQNLLDX6Aj","time":99943100,"targetExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u: User | all p: Photo | p in u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"one u:User| all p:Photo | p in u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=all, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=var1/Photo, value=var0/Photo)\", \"(type='Update', node=var0/User, value=var1/User)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":129064500,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | some posts.p } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{some{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all x : Photo | some posts.x","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=some, value=one)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":92527500,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u:User|#(u.posts)=1 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{={#{.{var0/User}{field/posts{set of{sig/Photo}}}}}{1}}}","nextExpr":"all p:Photo | #posts.p=1","sourceExpr":"all u:User|#(u.posts)=1","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Photo}}{={#{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}{1}}}","operations":"[\"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/User)\"]","hint":"Near a solution! Instead of using signature of type User, try using signature of type Photo to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{={#{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}{1}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":63623000,"targetExpr":"all p:Photo | #posts.p=1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo-Ad | lone posts.p } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{lone{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all p : Photo-Ad | lone posts.p","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=lone, value=one)\", \"(type='Move', tree='{sig/Photo}', parent=one of, position=1)\", \"(type='Delete', node=sig/Ad)\", \"(type='Delete', node=-)\"]","hint":"Near a solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":40956001,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { ~posts.posts in iden } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{.{~{field/posts{set of{sig/Photo}}}}{field/posts{set of{sig/Photo}}}}{iden}}","nextExpr":"~posts in Photo set -> one User","sourceExpr":"~posts.posts in iden","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{in{~{field/posts{set of{sig/Photo}}}}{->one{sig/Photo}{sig/User}}}","operations":"[\"(type='Move', tree='{~{field/posts{set of{sig/Photo}}}}', parent=in, position=0)\", \"(type='Update', node=set of, value=->one)\", \"(type='Move', tree='{set of{sig/Photo}}', parent=in, position=1)\", \"(type='Insert', node=sig/User, parent=set of, position=1)\", \"(type='Delete', node=field/posts)\", \"(type='Delete', node=.)\", \"(type='Delete', node=iden)\"]","hint":"Keep going! It seems like the transpose operator ('~') is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{in{~{field/posts{set of{sig/Photo}}}}{->one{sig/Photo}{sig/User}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":156388500,"targetExpr":"~posts in Photo set -> one User","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1, u2: User, p1 : Photo | p1->u1 in posts and (u2->p1 in posts or u2->p1 in sees) implies u1=u2 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{OR{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{in{->{var2/Photo}{var0/User}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","sourceExpr":"all u1, u2: User, p1 : Photo | p1->u1 in posts and (u2->p1 in posts or u2->p1 in sees) implies u1=u2","predicate":"inv1","isNewNode":true,"srcDstTED":20,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Insert', node=in, parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/User}}', parent=all, position=0)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=in, position=0)\", \"(type='Update', node==, value=some->)\", \"(type='Move', tree='{={var0/User}{var1/User}}', parent=in, position=1)\", \"(type='Move', tree='{one of{var1}{sig/User}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Update', node=var1/User, value=sig/Photo)\", \"(type='Insert', node=some, parent==>, position=0)\", \"(type='Update', node=->, value==)\", \"(type='Move', tree='{->{var2/Photo}{var0/User}}', parent==>, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Photo}}', parent=some, position=0)\", \"(type='Update', node=OR, value=AND)\", \"(type='Move', tree='{OR{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}', parent=some, position=1)\", \"(type='Insert', node=var1/User, parent=->, position=2)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=var2/Photo)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node==>)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":81817500,"targetExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User -> Photo } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/posts{set of{sig/Photo}}}{->{sig/User}{sig/Photo}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"posts in (User -> Photo)","predicate":"inv1","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Photo}}', parent=all, position=0)\", \"(type='Insert', node=one, parent=all, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{field/posts{set of{sig/Photo}}}{->{sig/User}{sig/Photo}}}', parent=one, position=0)\", \"(type='Update', node=sig/User, value=var0/Photo)\", \"(type='Move', tree='{sig/User}', parent=in, position=1)\", \"(type='Delete', node=sig/Photo)\", \"(type='Delete', node=->)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Photo\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":96085501,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo|one u: User| u in u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var1/User}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p : Photo | one u : User | u in u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=var1/User, value=var0/Photo)\"]","hint":"One step away from the solution! Instead of using variable of type User, try using variable of type Photo to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":127370899,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { Photo+Ad = User.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{={+{sig/Ad}{sig/Photo}}{.{sig/User}{field/posts{set of{sig/Photo}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"User.posts = Photo + Ad","predicate":"inv1","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node==, value=all)\", \"(type='Update', node=+, value=one of)\", \"(type='Insert', node=one, parent==, position=1)\", \"(type='Update', node=sig/Ad, value=var0)\", \"(type='Move', tree='{.{sig/User}{field/posts{set of{sig/Photo}}}}', parent=one, position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=sig/User)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":117903601,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | lone posts.p } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{lone{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all p : Photo | lone posts.p","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=lone, value=one)\"]","hint":"One step away from the solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":89234300,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { some p:Photo | some u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{some{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"some p:Photo | some u:User | p in u.posts","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=one)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":36025400,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u:User,p:Photo,i:Influencer | u->p in posts or i->p in posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{all{one of{var2}{sig/Influencer}}{OR{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/Influencer}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}","nextExpr":"all x : Photo | one y : User | y -> x in posts","sourceExpr":"all u:User,p:Photo,i:Influencer | u->p in posts or i->p in posts","predicate":"inv1","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Move', tree='{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var1/Photo, value=var0/Photo)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Influencer}}')\", \"(type='TreeDelete', tree='{in{->{var2/Influencer}{var1/Photo}}{field/posts{set of{sig/Photo}}}}')\", \"(type='Delete', node=OR)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":42679600,"targetExpr":"all x : Photo | one y : User | y -> x in posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { Photo-Ad = User.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{={-{sig/Photo}{sig/Ad}}{.{sig/User}{field/posts{set of{sig/Photo}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"Photo-Ad = User.posts","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node==, value=all)\", \"(type='Update', node=-, value=one of)\", \"(type='Insert', node=one, parent==, position=1)\", \"(type='Insert', node=var0, parent=-, position=0)\", \"(type='Move', tree='{.{sig/User}{field/posts{set of{sig/Photo}}}}', parent=one, position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=sig/Ad)\", \"(type='Delete', node=sig/User)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":36202299,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { Photo+Ad = User.posts + Influencer.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{={+{sig/Ad}{sig/Photo}}{+{.{sig/User}{field/posts{set of{sig/Photo}}}}{.{sig/Influencer}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"Photo+Ad = User.posts + Influencer.posts","predicate":"inv1","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node==, value=all)\", \"(type='Update', node=+, value=one of)\", \"(type='Update', node=+, value=one)\", \"(type='Update', node=sig/Ad, value=var0)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=sig/User)\", \"(type='TreeDelete', tree='{.{sig/Influencer}{field/posts{set of{sig/Photo}}}}')\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":42912900,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u:User| one u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{.{var0/User}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all u: User | one u.posts","predicate":"inv1","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/User)\"]","hint":"Near a solution! Instead of using signature of type User, try using signature of type Photo to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":84927200,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | some u:User | p-> u in posts all p:Photo,u1:User,u2:User | u1 -> p in posts and u2 -> p in posts implies u1=u2 } pred inv2 { no u:User | u->u in follows } pred inv3 { all u1:User,p:Photo | u1 -> p in sees implies (some u2:User | u2 -> p in posts and u1 -> u2 in follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{->{var0/Photo}{var1/User}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/Photo}}{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{=>{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var3/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var2/User}{var3/User}}}}}}}","nextExpr":"all p:Photo | some u:User | u->p in posts all p:Photo, u1,u2:User | u1->p in posts and u2->p in posts implies u1 = u2","sourceExpr":"all p:Photo | some u:User | p-> u in posts all p:Photo,u1:User,u2:User | u1 -> p in posts and u2 -> p in posts implies u1=u2","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{AND{all{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/Photo}}{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{=>{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var3/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var2/User}{var3/User}}}}}}}","operations":"[\"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Delete', node=var1/User)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the arrow operator ('->') expression.","nextAST":"{AND{all{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/Photo}}{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{=>{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var3/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{={var2/User}{var3/User}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":50093100,"targetExpr":"all p:Photo | some u:User | u->p in posts all p:Photo, u1,u2:User | u1->p in posts and u2->p in posts implies u1 = u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u: User | all p: Photo | u.posts in p } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Photo}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"one u: User | all p: Photo | u.posts in p","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=all, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Insert', node=var0/Photo, parent=in, position=0)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Delete', node=var1/Photo)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":45512100,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u: User | all p: Photo | p.~posts = u } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{={.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{var0/User}}}}","nextExpr":"all p: Photo | one p.~posts","sourceExpr":"one u: User | all p: Photo | p.~posts = u","predicate":"inv1","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var1}{sig/Photo}}{={.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{var0/User}}}', parent=root, position=0)\", \"(type='Update', node==, value=one)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=var1/Photo, value=var0/Photo)\", \"(type='Delete', node=var0/User)\", \"(type='TreeDelete', tree='{one of{var0}{sig/User}}')\", \"(type='Delete', node=one)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":38716700,"targetExpr":"all p: Photo | one p.~posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{one{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","sourceExpr":"all x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y","predicate":"inv1","isNewNode":true,"srcDstTED":11,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{one{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}', parent=AND, position=1)\", \"(type='Update', node=one, value==>)\", \"(type='Insert', node=some, parent=one, position=0)\", \"(type='Move', tree='{={var0/User}{var1/User}}', parent=one, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Photo}}', parent=some, position=0)\", \"(type='Move', tree='{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}', parent=some, position=1)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":44543700,"targetExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> lone Photo } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/posts{set of{sig/Photo}}}{one->lone{sig/User}{sig/Photo}}}","nextExpr":"posts in User one -> set Photo","sourceExpr":"posts in User one -> lone Photo","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","operations":"[\"(type='Update', node=one->lone, value=one->)\"]","hint":"One step away from the solution! Instead of using one->lone, try using one-> to help satisfy the required property.","nextAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":27369900,"targetExpr":"posts in User one -> set Photo","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u:User,p:Photo | u->p in posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}","nextExpr":"all x : Photo | one posts.x","sourceExpr":"all u1:User | all p:Photo | u1->p in posts","predicate":"inv1","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=var0/Photo, parent=in, position=2)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Photo}}')\", \"(type='TreeDelete', tree='{->{var0/User}{var1/Photo}}')\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":96156400,"targetExpr":"all x : Photo | one posts.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{one{one of{var1}{sig/User}}{one{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}","nextExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","sourceExpr":"one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y","predicate":"inv1","isNewNode":true,"srcDstTED":13,"targetAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Update', node=one, value=all)\", \"(type='Move', tree='{one{one of{var0}{sig/User}}{one{one of{var1}{sig/User}}{one{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{={var0/User}{var1/User}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}', parent=AND, position=1)\", \"(type='Update', node=one, value=all)\", \"(type='Update', node=one, value==>)\", \"(type='Insert', node=some, parent=one, position=0)\", \"(type='Move', tree='{={var0/User}{var1/User}}', parent=one, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Photo}}', parent=some, position=0)\", \"(type='Move', tree='{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}', parent=some, position=1)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{some{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}{={var0/User}{var1/User}}}}}{in{field/posts{set of{sig/Photo}}}{some->{sig/User}{sig/Photo}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":40635500,"targetExpr":"posts in User some -> Photo all u1,u2:User | (some p:Photo | u1->p in posts and u2->p in posts) implies u1 = u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one u:User|#(u.posts)>=1 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/User}}{>={#{.{var0/User}{field/posts{set of{sig/Photo}}}}}{1}}}","nextExpr":"all p:Photo | #posts.p=1","sourceExpr":"one u:User|#(u.posts)>=1","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{={#{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}{1}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=>=, value==)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Insert', node=var0/Photo, parent=., position=2)\", \"(type='Delete', node=var0/User)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Photo}}{={#{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}{1}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":33821700,"targetExpr":"all p:Photo | #posts.p=1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { iden in posts.~posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{iden}{.{field/posts{set of{sig/Photo}}}{~{field/posts{set of{sig/Photo}}}}}}","nextExpr":"posts in User one -> set Photo","sourceExpr":"iden in posts.~posts","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","operations":"[\"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=in, position=0)\", \"(type='Update', node=set of, value=one->)\", \"(type='Move', tree='{set of{sig/Photo}}', parent=in, position=1)\", \"(type='Insert', node=sig/User, parent=set of, position=0)\", \"(type='Delete', node=iden)\", \"(type='Delete', node=field/posts)\", \"(type='Delete', node=~)\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the field \"posts\" is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":36865500,"targetExpr":"posts in User one -> set Photo","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | some p.~posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{some{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one p.~posts","sourceExpr":"all p: Photo | some p.~posts","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Photo}}{one{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=some, value=one)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{.{var0/Photo}{~{field/posts{set of{sig/Photo}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":28632400,"targetExpr":"all p: Photo | one p.~posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { Photo = User.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{={.{sig/User}{field/posts{set of{sig/Photo}}}}{sig/Photo}}","nextExpr":"posts in User one -> set Photo","sourceExpr":"User.posts = Photo","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent==, position=0)\", \"(type='Insert', node=one->, parent==, position=1)\", \"(type='Insert', node=sig/User, parent=one->, position=0)\", \"(type='Move', tree='{sig/Photo}', parent=one->, position=1)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":96824500,"targetExpr":"posts in User one -> set Photo","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo|all u:User|#(posts[u])<=1 } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{<={#{.{var1/User}{field/posts{set of{sig/Photo}}}}}{1}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p:Photo|all u:User|#(posts[u])<=1","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=all, value=one)\", \"(type='Update', node=#, value=in)\", \"(type='Move', tree='{#{.{var1/User}{field/posts{set of{sig/Photo}}}}}', parent=all, position=1)\", \"(type='Insert', node=var0/Photo, parent=#, position=0)\", \"(type='Delete', node=1)\", \"(type='Delete', node=<=)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":38927400,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p :Photo|one u:User|some u.posts } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{some{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p :Photo|one u:User|some u.posts","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=some, value=in)\", \"(type='Insert', node=var0/Photo, parent=some, position=0)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":35048100,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User -> one Photo } pred inv2 { all u:User | u not in u.follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/posts{set of{sig/Photo}}}{->one{sig/User}{sig/Photo}}}","nextExpr":"posts in User one -> set Photo","sourceExpr":"posts in User -> one Photo","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","operations":"[\"(type='Update', node=->one, value=one->)\"]","hint":"One step away from the solution! Instead of using ->one, try using one-> to help satisfy the required property.","nextAST":"{in{field/posts{set of{sig/Photo}}}{one->{sig/User}{sig/Photo}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":103033900,"targetExpr":"posts in User one -> set Photo","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | some u:User | p in posts.u } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{some{one of{var1}{sig/User}}{in{var0/Photo}{.{field/posts{set of{sig/Photo}}}{var1/User}}}}}","nextExpr":"all p: Photo | one u:User | p in u.posts","sourceExpr":"all p:Photo | some u:User | p in posts.u","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","operations":"[\"(type='Update', node=some, value=one)\", \"(type='Insert', node=var1/User, parent=., position=0)\", \"(type='Delete', node=var1/User)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Photo}}{one{one of{var1}{sig/User}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":37955400,"targetExpr":"all p: Photo | one u:User | p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| #u.follows=0 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{={#{.{var0/User}{field/follows{set of{sig/User}}}}}{0}}}","nextExpr":"all u:User | u.follows & u = none","sourceExpr":"all u:User| #u.follows=0","predicate":"inv2","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{={&{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}{none}}}","operations":"[\"(type='Update', node=#, value=&)\", \"(type='Update', node=0, value=none)\", \"(type='Insert', node=var0/User, parent=#, position=1)\"]","hint":"Near a solution! Instead of using #, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/User}}{={&{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}{none}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":123242700,"targetExpr":"all u:User | u.follows & u = none","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows.User.iden } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{no{.{.{field/follows{set of{sig/User}}}{sig/User}}{iden}}}","nextExpr":"no (follows & iden)","sourceExpr":"no follows.User.iden","predicate":"inv2","isNewNode":true,"srcDstTED":3,"targetAST":"{no{&{field/follows{set of{sig/User}}}{iden}}}","operations":"[\"(type='Update', node=., value=&)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=0)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=.)\"]","hint":"Near a solution! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{no{&{field/follows{set of{sig/User}}}{iden}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":82042600,"targetExpr":"no (follows & iden)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u1, u2:User | u1 -> u2 in follows implies u1 = u2 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{={var0/User}{var1/User}}}}}","nextExpr":"all x,y : User | x -> y in follows implies x != y","sourceExpr":"all u1, u2:User | u1 -> u2 in follows implies u1 = u2","predicate":"inv2","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{!={var0/User}{var1/User}}}}}","operations":"[\"(type='Update', node==, value=!=)\"]","hint":"One step away from the solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using not equal operator ('!=') to specify that the left side is not equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{!={var0/User}{var1/User}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":66809100,"targetExpr":"all x,y : User | x -> y in follows implies x != y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| no u.follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{no{.{var0/User}{field/follows{set of{sig/User}}}}}}","nextExpr":"all x : User | x not in x.follows","sourceExpr":"all x : User | no x.follows","predicate":"inv2","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=no, value=!in)\", \"(type='Insert', node=var0/User, parent=no, position=0)\"]","hint":"Near a solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":142854800,"targetExpr":"all x : User | x not in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u1, u2:User | u1 -> u2 in follows and u2 -> u1 in follows implies u1 = u2 } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var0/User}}{field/follows{set of{sig/User}}}}}{={var0/User}{var1/User}}}}}","nextExpr":"all u1, u2 : User | u1 in u2.follows and u2 in u1.follows implies u1 != u2","sourceExpr":"all u1, u2:User | u1 -> u2 in follows and u2 -> u1 in follows implies u1 = u2","predicate":"inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{!={var0/User}{var1/User}}}}}","operations":"[\"(type='Update', node==, value=!=)\", \"(type='Move', tree='{var0/User}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var1/User}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=->)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using not equal operator ('!=') to specify that the left side is not equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{!={var0/User}{var1/User}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":57002400,"targetExpr":"all u1, u2 : User | u1 in u2.follows and u2 in u1.follows implies u1 != u2","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { iden not in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{!in{iden}{field/follows{set of{sig/User}}}}","nextExpr":"no (follows & iden)","sourceExpr":"iden not in follows","predicate":"inv2","isNewNode":false,"srcDstTED":4,"targetAST":"{no{&{field/follows{set of{sig/User}}}{iden}}}","operations":"[\"(type='Insert', node=no, parent=root, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{iden}{field/follows{set of{sig/User}}}}', parent=no, position=0)\", \"(type='Insert', node=iden, parent=!in, position=2)\", \"(type='Delete', node=iden)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{no{&{field/follows{set of{sig/User}}}{iden}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":98627500,"targetExpr":"no (follows & iden)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no User.iden } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{no{.{sig/User}{iden}}}","nextExpr":"no (follows & iden)","sourceExpr":"no User.iden","predicate":"inv2","isNewNode":true,"srcDstTED":3,"targetAST":"{no{&{field/follows{set of{sig/User}}}{iden}}}","operations":"[\"(type='Update', node=., value=&)\", \"(type='Insert', node=field/follows, parent=., position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Move', tree='{sig/User}', parent=set of, position=0)\"]","hint":"Near a solution! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{no{&{field/follows{set of{sig/User}}}{iden}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":52472700,"targetExpr":"no (follows & iden)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> one Photo } pred inv2 { all u:User | u not in u.*follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{*{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u : User | u not in u.follows","sourceExpr":"all u : User | u not in u.*follows","predicate":"inv2","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=*)\"]","hint":"One step away from the solution! It seems like the field \"follows\" is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":211035600,"targetExpr":"all u : User | u not in u.follows","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> one Photo } pred inv2 { all u:User | u not in u.^follows } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{^{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u : User | u not in u.follows","sourceExpr":"all u : User | u not in u.^follows","predicate":"inv2","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=^)\"]","hint":"One step away from the solution! It seems like the field \"follows\" is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":127264200,"targetExpr":"all u : User | u not in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u1, u2:User, p:Photo | u1 -> p in sees and u2 -> p in posts and u1 -> u2 in follows sees in User set -> set Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}{in{field/sees{set of{sig/Photo}}}{->{sig/User}{sig/Ad}}}}","nextExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","sourceExpr":"all u1, u2:User, p:Photo | u1 -> p in sees and u2 -> p in posts and u1 -> u2 in follows sees in User set -> set Ad","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='TreeDelete', tree='{in{field/sees{set of{sig/Photo}}}{->{sig/User}{sig/Ad}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":174011400,"targetExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u1, u2 : User, p:Photo | u1 -> p in sees implies (u2 -> p in posts and u1->u2 in follows) all a : Ad, u:User | u->a in sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}{all{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}}","nextExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","sourceExpr":"all u1, u2 : User, p:Photo | u1 -> p in sees implies (u2 -> p in posts and u1->u2 in follows) all a : Ad, u:User | u->a in sees","predicate":"inv3","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}', parent=root, position=0)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent==>, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=1)\", \"(type='Update', node=field/posts, value=field/follows)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var2/Photo, value=var1/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var1/User, value=var2/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{all{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":117715800,"targetExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1,u2:User, p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all p:Photo | some u:User | u->p in posts } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u1,u2:User, p:Photo | (u1->p in sees and u2->p in posts and u1->u2 in follows) or p in Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all u1, u2 : User, p : Photo | p in Ad || (( u1->p in sees && u2 -> p in posts ) => u1 -> u2 in follows)","sourceExpr":"all u1,u2:User, p:Photo | (u1->p in sees and u2->p in posts and u1->u2 in follows) or p in Ad","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=1)\"]","hint":"Near a solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":78862100,"targetExpr":"all u1, u2 : User, p : Photo | p in Ad || (( u1->p in sees && u2 -> p in posts ) => u1 -> u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { all x,y :User| x->y in follows implies x!=y } pred inv3 { all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies y->x in follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all p : Photo - Ad | all u1,u2 : User | u1->p in sees and u2->p in posts implies u1->u2 in follows","sourceExpr":"all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies y->x in follows","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Delete', node=var1/User)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the arrow operator ('->') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":80685600,"targetExpr":"all p : Photo - Ad | all u1,u2 : User | u1->p in sees and u2->p in posts implies u1->u2 in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p:Photo |all u1,u2:Photo | p in u2.posts and u2 in u1.follows implies p in u1.sees and Ad not in p } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/Photo}}{all{one of{var2}{sig/Photo}}{=>{AND{in{var0/Photo}{.{var2/Photo}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/Photo}{field/follows{set of{sig/User}}}}}}{AND{!in{sig/Ad}{var0/Photo}}{in{var0/Photo}{.{var1/Photo}{field/sees{set of{sig/Photo}}}}}}}}}}","nextExpr":"all p:Photo - Ad | all u1:User | all u2:User | (p in u1.posts and p in u2.sees) implies u1 in u2.follows","sourceExpr":"all p:Photo |all u1,u2:Photo | p in u2.posts and u2 in u1.follows implies p in u1.sees and Ad not in p","predicate":"inv3","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var2/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Move', tree='{in{var0/Photo}{.{var1/Photo}{field/sees{set of{sig/Photo}}}}}', parent==>, position=1)\", \"(type='Update', node=var0/Photo, value=var1/User)\", \"(type='Update', node=var2/Photo, value=var0/Photo)\", \"(type='Update', node=var1/Photo, value=var2/User)\", \"(type='Update', node=field/sees, value=field/follows)\", \"(type='Update', node=var2/Photo, value=var1/User)\", \"(type='Update', node=var1/Photo, value=var2/User)\", \"(type='Update', node=field/follows, value=field/sees)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='TreeDelete', tree='{!in{sig/Ad}{var0/Photo}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var2/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":76107300,"targetExpr":"all p:Photo - Ad | all u1:User | all u2:User | (p in u1.posts and p in u2.sees) implies u1 in u2.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p: Photo|all u: User|lone(sees.p & u.follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{lone{&{.{field/sees{set of{sig/Photo}}}{var0/Photo}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all p : Photo - Ad | all u : User | p in u.sees implies posts.p in u.follows","sourceExpr":"all p: Photo|all u: User|lone(sees.p & u.follows)","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{.{field/posts{set of{sig/Photo}}}{var0/Photo}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=lone, value==>)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='TreeInsert', tree='{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}', parent=lone, position=0)\", \"(type='Update', node=&, value=in)\", \"(type='Update', node=field/sees, value=field/posts)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{.{field/posts{set of{sig/Photo}}}{var0/Photo}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":51156100,"targetExpr":"all p : Photo - Ad | all u : User | p in u.sees implies posts.p in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) } pred inv4 { all u:User | some p1:Ad | u -> p1 in posts implies (all p2:Photo | u -> p2 in posts implies p2 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all p:Photo-Ad, u1:User | u1->p in sees => (some u2:User | u1->u2 in follows and u2->p in posts)","sourceExpr":"all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":67709300,"targetExpr":"all p:Photo-Ad, u1:User | u1->p in sees => (some u2:User | u1->u2 in follows and u2->p in posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, i: Ad | u.sees in u.follows.posts && u.sees in i } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{AND{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all x : User | x.sees in (x.follows.posts + x.follows + Ad )","sourceExpr":"all u: User, i: Ad | u.sees in u.follows.posts && u.sees in i","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{+{+{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{sig/Ad}}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{AND{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{var1/Ad}}}', parent=all, position=1)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Insert', node=+, parent=AND, position=1)\", \"(type='Insert', node=+, parent=+, position=0)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Move', tree='{var1/Ad}', parent=+, position=1)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}', parent=+, position=0)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=+, position=1)\", \"(type='Update', node=field/sees, value=field/follows)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Ad}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{+{+{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{sig/Ad}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":68882300,"targetExpr":"all x : User | x.sees in (x.follows.posts + x.follows + Ad )","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts implies u1 -> u2 in follows)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{AND{!in{var0/Photo}{sig/Ad}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{=>{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","sourceExpr":"all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts implies u1 -> u2 in follows))","predicate":"inv3","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{=>{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}', parent=AND, position=1)\", \"(type='Move', tree='{!in{var0/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='Update', node==>, value=AND)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":70766600,"targetExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all p:Photo | all u:User | p -> u in sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{in{->{var0/Photo}{var1/User}}{field/sees{set of{sig/Photo}}}}}}","nextExpr":"sees in (follows.posts + User -> Ad)","sourceExpr":"all p:Photo | all u:User | p -> u in sees","predicate":"inv3","isNewNode":true,"srcDstTED":14,"targetAST":"{in{field/sees{set of{sig/Photo}}}{+{->{sig/User}{sig/Ad}}{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Update', node=all, value=in)\", \"(type='Insert', node=field/sees, parent=all, position=0)\", \"(type='Update', node=all, value=+)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var0}{sig/Photo}}', parent=field/sees, position=0)\", \"(type='Update', node=one of, value=->)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=sig/Ad, parent=one of, position=2)\", \"(type='Insert', node=field/follows, parent=in, position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{var0/Photo}{var1/User}}', parent=field/follows, position=0)\", \"(type='Update', node=var0/Photo, value=sig/User)\", \"(type='Delete', node=var0)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/sees{set of{sig/Photo}}}{+{->{sig/User}{sig/Ad}}{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":55102300,"targetExpr":"sees in (follows.posts + User -> Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and p in u2.posts implies u1 in u2.follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var0/User}{.{field/sees{set of{sig/Photo}}}{var2/Photo}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all user1, user2 : User | all p : Photo - Ad | (p in user1.sees and p in user2.posts) implies user2 in user1.follows","sourceExpr":"all u1,u2:User, p:Photo-Ad | u1 in sees.p and p in u2.posts implies u1 in u2.follows","predicate":"inv3","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var2/Photo)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Delete', node=var2/Photo)\"]","hint":"Keep going! Instead of using variable of type User, try using variable of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":74784300,"targetExpr":"all user1, user2 : User | all p : Photo - Ad | (p in user1.sees and p in user2.posts) implies user2 in user1.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | (p in u.sees and p not in Ad implies p in u.follows.posts) and (all p1:Photo | p1 in Ad implies p1 in u.sees) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{AND{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}}}}","nextExpr":"all u : User | all p : Photo | (p in u.sees and p not in Ad) implies (p in u.follows.posts)","sourceExpr":"all u:User, p:Photo | (p in u.sees and p not in Ad implies p in u.follows.posts) and (all p1:Photo | p1 in Ad implies p1 in u.sees)","predicate":"inv3","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Move', tree='{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":85221100,"targetExpr":"all u : User | all p : Photo | (p in u.sees and p not in Ad) implies (p in u.follows.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p:Photo |all u1,u2:User | p in u2.posts and u2 in u1.follows implies Ad not in p } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{!in{sig/Ad}{var0/Photo}}}}}}","nextExpr":"all p : Photo - Ad| all u1,u2 : User | p in u2.posts and p in u1.sees implies u2 in u1.follows","sourceExpr":"all p:Photo |all u1,u2:User | p in u2.posts and u2 in u1.follows implies Ad not in p","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Insert', node=var2/User, parent=in, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{sig/Ad}{var0/Photo}}', parent=in, position=1)\", \"(type='Update', node=var2/User, value=var0/Photo)\", \"(type='Update', node=sig/Ad, value=var1/User)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Update', node=field/follows, value=field/sees)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var0/Photo, value=sig/User)\", \"(type='Move', tree='{var0/Photo}', parent=set of, position=0)\", \"(type='Update', node=sig/User, value=sig/Photo)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":74244300,"targetExpr":"all p : Photo - Ad| all u1,u2 : User | p in u2.posts and p in u1.sees implies u2 in u1.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p:Photo |all u1,u2:User | p in u2.posts and u2 in u1.follows implies p in u1.sees and Ad not in p } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{AND{!in{sig/Ad}{var0/Photo}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}}}}}","nextExpr":"all p : Photo - Ad| all u1,u2 : User | p in u2.posts and p in u1.sees implies u2 in u1.follows","sourceExpr":"all p:Photo |all u1,u2:User | p in u2.posts and u2 in u1.follows implies p in u1.sees and Ad not in p","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}', parent==>, position=1)\", \"(type='Update', node=var0/Photo, value=var2/User)\", \"(type='Update', node=var2/User, value=var0/Photo)\", \"(type='Update', node=field/sees, value=field/follows)\", \"(type='Update', node=field/follows, value=field/sees)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='TreeDelete', tree='{!in{sig/Ad}{var0/Photo}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":78156400,"targetExpr":"all p : Photo - Ad| all u1,u2 : User | p in u2.posts and p in u1.sees implies u2 in u1.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u: User | all p: Photo-Ad | u->p in sees implies (some y: User | u->y in follows and y->p in posts)","sourceExpr":"all u:User, p:Photo| u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":76947700,"targetExpr":"all u: User | all p: Photo-Ad | u->p in sees implies (some y: User | u->y in follows and y->p in posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u1 in u2.follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var0/User}{.{field/sees{set of{sig/Photo}}}{var2/Photo}}}{in{var1/User}{.{field/posts{set of{sig/Photo}}}{var2/Photo}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u1, u2 : User, p : Photo-Ad | (u1 in sees.p && u2 in posts.p) implies (u1 in follows.u2)","sourceExpr":"all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u1 in u2.follows","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var0/User}{.{field/sees{set of{sig/Photo}}}{var2/Photo}}}{in{var1/User}{.{field/posts{set of{sig/Photo}}}{var2/Photo}}}}{in{var0/User}{.{field/follows{set of{sig/User}}}{var1/User}}}}}}}","operations":"[\"(type='Insert', node=var1/User, parent=., position=2)\", \"(type='Delete', node=var1/User)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var0/User}{.{field/sees{set of{sig/Photo}}}{var2/Photo}}}{in{var1/User}{.{field/posts{set of{sig/Photo}}}{var2/Photo}}}}{in{var0/User}{.{field/follows{set of{sig/User}}}{var1/User}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":71946900,"targetExpr":"all u1, u2 : User, p : Photo-Ad | (u1 in sees.p && u2 in posts.p) implies (u1 in follows.u2)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u,u2:User, p:Photo | u->p in sees implies ((u->u2 in follows and p not in Ad and u2->p in posts) or (p in Ad)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{OR{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u1, u2 : User, p: Photo | u1->p in posts implies p not in Ad and u2->p in sees implies u2->u1 in follows","sourceExpr":"all u,u2:User, p:Photo | u->p in sees implies ((u->u2 in follows and p not in Ad and u2->p in posts) or (p in Ad))","predicate":"inv3","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{=>{AND{!in{var2/Photo}{sig/Ad}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{in{->{var1/User}{var0/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}', parent==>, position=1)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Move', tree='{!in{var2/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=1)\", \"(type='Update', node=field/posts, value=field/follows)\", \"(type='Update', node=field/follows, value=field/sees)\", \"(type='Update', node=var2/Photo, value=var0/User)\", \"(type='Insert', node=var2/Photo, parent=->, position=2)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Delete', node=var0/User)\", \"(type='TreeDelete', tree='{in{var2/Photo}{sig/Ad}}')\", \"(type='Delete', node=OR)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{=>{AND{!in{var2/Photo}{sig/Ad}}{in{->{var1/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}}{in{->{var1/User}{var0/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":87143200,"targetExpr":"all u1, u2 : User, p: Photo | u1->p in posts implies p not in Ad and u2->p in sees implies u2->u1 in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1,u2:User, p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all p:Photo | some u:User | u->p in posts } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u1,u2:User, p:Photo | u1->p in sees and u2->p in posts and u1->u2 in follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","sourceExpr":"all u1,u2:User, p:Photo | u1->p in sees and u2->p in posts and u1->u2 in follows","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":89568200,"targetExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u1, u2 : User, p : Photo | not (u1 -> p in sees and u1 -> u2 in follows) not some add : Ad | all u : User | u -> add not in sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{!{some{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{!in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}}{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{!{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all u : User | all p : Photo | u->p in sees implies ((one v : User | v->p in posts and u->v in follows) or (p in Ad))","sourceExpr":"all u1, u2 : User, p : Photo | not (u1 -> p in sees and u1 -> u2 in follows) not some add : Ad | all u : User | u -> add not in sees","predicate":"inv3","isNewNode":true,"srcDstTED":28,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{OR{in{var1/Photo}{sig/Ad}}{one{one of{var2}{sig/User}}{AND{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var3}{sig/Ad}}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Update', node=var3, value=var0)\", \"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Move', tree='{one of{var4}{sig/User}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=var4, value=var1)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}', parent==>, position=0)\", \"(type='Update', node=all, value=OR)\", \"(type='Move', tree='{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{!{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}', parent==>, position=1)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node=all, value=one)\", \"(type='Update', node=var4/User, value=var0/User)\", \"(type='Update', node=var3/Ad, value=var1/Photo)\", \"(type='Update', node=var1, value=var1/Photo)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Move', tree='{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var2/Photo, value=var1/Photo)\", \"(type='Update', node=var1/User, value=var2/User)\", \"(type='Delete', node=!)\", \"(type='Delete', node=all)\", \"(type='Delete', node=some)\", \"(type='Delete', node=!)\", \"(type='TreeDelete', tree='{one of{var0}{sig/User}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{OR{in{var1/Photo}{sig/Ad}}{one{one of{var2}{sig/User}}{AND{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}}","totalTED":28,"challenge":"dkZH6HJNQNLLDX6Aj","time":83786200,"targetExpr":"all u : User | all p : Photo | u->p in sees implies ((one v : User | v->p in posts and u->v in follows) or (p in Ad))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u1, u2 : User, p : Photo | not (u1 -> p in sees and u1 -> u2 in follows and u2 -> p in posts and p not in Ad) not some ad : Ad | all u : User | u -> ad not in sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{!{some{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{!in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}}{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{!{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}}","nextExpr":"all u: User, u2: User, y: Photo | (y not in Ad and u->y in sees and u2->y in posts) implies (u->u2 in follows)","sourceExpr":"all u1, u2 : User, p : Photo | not (u1 -> p in sees and u1 -> u2 in follows and u2 -> p in posts and p not in Ad) not some ad : Ad | all u : User | u -> ad not in sees","predicate":"inv3","isNewNode":true,"srcDstTED":28,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{!{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}', parent=all, position=1)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Move', tree='{!in{var2/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=2)\", \"(type='Update', node=field/posts, value=field/follows)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Insert', node=var0/User, parent=->, position=0)\", \"(type='Insert', node=var2/Photo, parent=->, position=2)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=var2/Photo)\", \"(type='Delete', node=!)\", \"(type='TreeDelete', tree='{!{some{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{!in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":28,"challenge":"dkZH6HJNQNLLDX6Aj","time":85813400,"targetExpr":"all u: User, u2: User, y: Photo | (y not in Ad and u->y in sees and u2->y in posts) implies (u->u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all p: Photo, u: User | p in u.follows.posts => p in u.sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}}}","nextExpr":"all p : Photo - Ad | all u : User | p in u.sees implies p in u.follows.posts","sourceExpr":"all p: Photo, u: User | p in u.follows.posts => p in u.sees","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Update', node=field/posts, value=field/sees)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":62492600,"targetExpr":"all p : Photo - Ad | all u : User | p in u.sees implies p in u.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts implies u2 -> u1 in follows)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{AND{!in{var0/Photo}{sig/Ad}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{=>{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","sourceExpr":"all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts implies u2 -> u1 in follows))","predicate":"inv3","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{=>{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}', parent=AND, position=1)\", \"(type='Move', tree='{!in{var0/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='Update', node==>, value=AND)\", \"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":75262200,"targetExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | u.posts = p } pred inv2 { } pred inv3 { all u: User, p: Photo | p in u.sees <=> p in u.follows.posts or p in Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{OR{<=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{in{var1/Photo}{sig/Ad}}}}}","nextExpr":"all u: User, p: Photo | p in u.sees implies p in u.follows.posts or p in Ad","sourceExpr":"all u: User, p: Photo | p in u.sees <=> p in u.follows.posts or p in Ad","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{OR{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{in{var1/Photo}{sig/Ad}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\"]","hint":"One step away from the solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{OR{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{in{var1/Photo}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":33007100,"targetExpr":"all u: User, p: Photo | p in u.sees implies p in u.follows.posts or p in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1,u2:User, p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all p:Photo | some u:User | u->p in posts } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u1,u2:User, p:Photo | u1->p in sees implies (u2->p in posts and u1->u2 in follows) or p in Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all u1, u2 : User, p : Photo | p in Ad || (( u1->p in sees && u2 -> p in posts ) => u1 -> u2 in follows)","sourceExpr":"all u1,u2:User, p:Photo | u1->p in sees implies (u2->p in posts and u1->u2 in follows) or p in Ad","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=1)\", \"(type='Update', node=field/posts, value=field/follows)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var2/Photo, value=var1/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var1/User, value=var2/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Delete', node=AND)\"]","hint":"Near a solution! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":79365000,"targetExpr":"all u1, u2 : User, p : Photo | p in Ad || (( u1->p in sees && u2 -> p in posts ) => u1 -> u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | some u:User | u -> p in posts } pred inv2 { no u:User | u->u in follows } pred inv3 { all u1:User,p:Photo | u1 -> p in sees implies (some u2:User | u2 -> p in posts and u1 -> u2 in follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u:User | all p:Photo-Ad | u->p in sees implies (some u2:User| u2->p in posts and u->u2 in follows)","sourceExpr":"all u1:User,p:Photo | u1 -> p in sees implies (some u2:User | u2 -> p in posts and u1 -> u2 in follows)","predicate":"inv3","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":68326800,"targetExpr":"all u:User | all p:Photo-Ad | u->p in sees implies (some u2:User| u2->p in posts and u->u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u,u2:User, p:Photo | u->p in sees implies ((u->u2 in follows and p not in Ad) or (p in Ad)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{OR{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u1, u2 : User, p : Photo | (u1 -> p in sees and u2 -> p in posts) => (u1 -> u2 in follows or p in Ad)","sourceExpr":"all u,u2:User, p:Photo | u->p in sees implies ((u->u2 in follows and p not in Ad) or (p in Ad))","predicate":"inv3","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Insert', node=OR, parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var2/Photo}{sig/Ad}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=OR, position=0)\", \"(type='Move', tree='{in{var2/Photo}{sig/Ad}}', parent=OR, position=1)\", \"(type='Insert', node=->, parent=!in, position=0)\", \"(type='Insert', node=field/posts, parent=!in, position=1)\", \"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Move', tree='{var2/Photo}', parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/posts, position=0)\", \"(type='Update', node=sig/Ad, value=sig/Photo)\", \"(type='Move', tree='{sig/Ad}', parent=set of, position=0)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=OR)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":78034000,"targetExpr":"all u1, u2 : User, p : Photo | (u1 -> p in sees and u2 -> p in posts) => (u1 -> u2 in follows or p in Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p in u.sees => p.~posts in u.follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u: User, p: Photo | (p in u.sees implies p.~posts in u.follows) or p in Ad","sourceExpr":"all u: User, p: Photo | p in u.sees => p.~posts in u.follows","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{OR{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var1/Photo}{sig/Ad}}}}}","operations":"[\"(type='Insert', node=OR, parent=all, position=1)\", \"(type='Move', tree='{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}', parent=OR, position=0)\", \"(type='TreeInsert', tree='{in{var1/Photo}{sig/Ad}}', parent=OR, position=1)\"]","hint":"Keep going! Consider adding a disjunction operator ('or') to combine two boolean expressions. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{OR{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var1/Photo}{sig/Ad}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":57893500,"targetExpr":"all u: User, p: Photo | (p in u.sees implies p.~posts in u.follows) or p in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u: User, p: Photo | p in u.sees && p not in Ad implies (some f: u.follows | p in f.posts) all a: Ad, u: User | a in u.sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}{all{one of{var3}{sig/Ad}}{all{one of{var0}{sig/User}}{in{var3/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}}","nextExpr":"all u : User | all p : Photo | (p in u.sees and p not in Ad) implies (p in u.follows.posts)","sourceExpr":"all u: User, p: Photo | p in u.sees && p not in Ad => (some f: u.follows | p in f.posts) all a: Ad, u: User | a in u.sees","predicate":"inv3","isNewNode":false,"srcDstTED":24,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=in)\", \"(type='Update', node=var2, value=var1/Photo)\", \"(type='Move', tree='{var2}', parent=some, position=0)\", \"(type='Insert', node=., parent=some, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/Photo)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{all{one of{var3}{sig/Ad}}{all{one of{var0}{sig/User}}{in{var3/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":24,"challenge":"dkZH6HJNQNLLDX6Aj","time":178144400,"targetExpr":"all u : User | all p : Photo | (p in u.sees and p not in Ad) implies (p in u.follows.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all p:Photo, u:User | p -> u in sees implies p not in Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var0/Photo}{var1/User}}{field/sees{set of{sig/Photo}}}}{!in{var0/Photo}{sig/Ad}}}}}","nextExpr":"all p : Photo - Ad, u : User | p in u.sees implies p in u.follows.posts","sourceExpr":"all p:Photo, u:User | p -> u in sees implies p not in Ad","predicate":"inv3","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{var0/Photo}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Move', tree='{field/sees{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Update', node=sig/Ad, value=var1/User)\", \"(type='Move', tree='{sig/Ad}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":59944000,"targetExpr":"all p : Photo - Ad, u : User | p in u.sees implies p in u.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| u not in u.follows } pred inv3 { all a: Ad, u: User | a in u.sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{in{var0/Ad}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}}","nextExpr":"all p: Photo-Ad | all u: sees.p | u in follows.posts.p","sourceExpr":"all a : Ad | all u : User | a in u.sees","predicate":"inv3","isNewNode":false,"srcDstTED":14,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{.{field/sees{set of{sig/Photo}}}{var0/Photo}}}{in{var1/User}{.{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}{var0/Photo}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=sig/Photo, parent=-, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=-, position=1)\", \"(type='Insert', node=., parent=one of, position=1)\", \"(type='Update', node=var0/Ad, value=var1/User)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=field/sees, parent=., position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=1)\", \"(type='Move', tree='{.{var1/User}{field/sees{set of{sig/Photo}}}}', parent=., position=0)\", \"(type='Insert', node=var0/Photo, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/sees, position=0)\", \"(type='Insert', node=field/follows, parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Move', tree='{sig/User}', parent=set of, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{.{field/sees{set of{sig/Photo}}}{var0/Photo}}}{in{var1/User}{.{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}{var0/Photo}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":201962900,"targetExpr":"all p: Photo-Ad | all u: sees.p | u in follows.posts.p","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u1, u2 : User, p : Photo | not (u1 -> p in sees and u1 -> u2 in follows and p not in Ad) not some ad : Ad | all u : User | u -> ad not in sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{!{some{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{!in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}}{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{!{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all u: User, u2: User, y: Photo | (y not in Ad and u->y in sees and u2->y in posts) implies (u->u2 in follows)","sourceExpr":"all u1, u2 : User, p : Photo | not (u1 -> p in sees and u1 -> u2 in follows and p not in Ad) not some ad : Ad | all u : User | u -> ad not in sees","predicate":"inv3","isNewNode":true,"srcDstTED":27,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{!{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Move', tree='{!in{var2/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='TreeInsert', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=2)\", \"(type='Delete', node=!)\", \"(type='TreeDelete', tree='{!{some{one of{var3}{sig/Ad}}{all{one of{var4}{sig/User}}{!in{->{var4/User}{var3/Ad}}{field/sees{set of{sig/Photo}}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{!in{var2/Photo}{sig/Ad}}{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":27,"challenge":"dkZH6HJNQNLLDX6Aj","time":80340100,"targetExpr":"all u: User, u2: User, y: Photo | (y not in Ad and u->y in sees and u2->y in posts) implies (u->u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows & iden } pred inv3 { all u:User | posts.(u.sees) in u.follows + Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{all{one of{var0}{sig/User}}{in{.{field/posts{set of{sig/Photo}}}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{sig/Ad}}}}","nextExpr":"all u: User | (posts.(u.sees - Ad)) in u.follows","sourceExpr":"all u:User | posts.(u.sees) in u.follows + Ad","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{in{.{field/posts{set of{sig/Photo}}}{-{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=in, position=1)\", \"(type='Insert', node=-, parent=., position=1)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Delete', node=sig/Ad)\", \"(type='Delete', node=+)\"]","hint":"Keep going! It seems like the dot join operator ('.') is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{in{.{field/posts{set of{sig/Photo}}}{-{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":57740800,"targetExpr":"all u: User | (posts.(u.sees - Ad)) in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts and u1 -> u2 in follows)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{AND{!in{var0/Photo}{sig/Ad}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","sourceExpr":"all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts and u1 -> u2 in follows))","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}', parent=AND, position=1)\", \"(type='Move', tree='{!in{var0/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":73938200,"targetExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all a : Ad, u:User | u->a in sees all u1, u2 : User, p:Photo | u1 -> p in sees and u2 -> p in posts implies u1->u2 in follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{in{->{var1/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}}}{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{all{one of{var4}{sig/Photo}}{=>{AND{in{->{var2/User}{var4/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var3/User}{var4/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var2/User}{var3/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all x : Photo-Ad | all y, z : User | y -> x in sees and z -> x in posts implies y -> z in follows","sourceExpr":"all a : Ad, u:User | u->a in sees all u1, u2 : User, p:Photo | u1 -> p in sees and u2 -> p in posts implies u1->u2 in follows","predicate":"inv3","isNewNode":true,"srcDstTED":27,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Ad}}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{one of{var1}{sig/User}}', parent=all, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{all{one of{var4}{sig/Photo}}{=>{AND{in{->{var2/User}{var4/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var3/User}{var4/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var2/User}{var3/User}}{field/follows{set of{sig/User}}}}}}}}', parent=all, position=1)\", \"(type='Insert', node=sig/Photo, parent=-, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=-, position=1)\", \"(type='Move', tree='{=>{AND{in{->{var2/User}{var4/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var3/User}{var4/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var2/User}{var3/User}}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var4/Photo, value=var0/Photo)\", \"(type='Update', node=var3/User, value=var2/User)\", \"(type='Update', node=var4/Photo, value=var0/Photo)\", \"(type='Delete', node=var3/User)\", \"(type='TreeDelete', tree='{one of{var3}{sig/User}}')\", \"(type='TreeDelete', tree='{one of{var4}{sig/Photo}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{in{->{var1/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":27,"challenge":"dkZH6HJNQNLLDX6Aj","time":91050600,"targetExpr":"all x : Photo-Ad | all y, z : User | y -> x in sees and z -> x in posts implies y -> z in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p:Photo -Ad | all u1,u2:User | u1 in u2.follows and p in u1.posts implies p in u1.sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var0/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}}}}","nextExpr":"all p : Photo - Ad| all u1,u2 : User | p in u2.posts and p in u1.sees implies u2 in u1.follows","sourceExpr":"all p:Photo -Ad | all u1,u2:User | u1 in u2.follows and p in u1.posts implies p in u1.sees","predicate":"inv3","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=var0/Photo, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/Photo)\", \"(type='Update', node=field/sees, value=field/follows)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Update', node=field/posts, value=field/sees)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\"]","hint":"Keep going! Instead of using variable of type Photo, try using variable of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var0/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":67564900,"targetExpr":"all p : Photo - Ad| all u1,u2 : User | p in u2.posts and p in u1.sees implies u2 in u1.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts and u1 -> u2 in follows)) all p:Ad,u:User | u -> p in sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{AND{!in{var0/Photo}{sig/Ad}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}}{all{one of{var0}{sig/Ad}}{all{one of{var3}{sig/User}}{in{->{var3/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}}}}","nextExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","sourceExpr":"all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts and u1 -> u2 in follows)) all p:Ad,u:User | u -> p in sees","predicate":"inv3","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{AND{!in{var0/Photo}{sig/Ad}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}', parent=AND, position=1)\", \"(type='Move', tree='{!in{var0/Photo}{sig/Ad}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=1)\", \"(type='Delete', node==>)\", \"(type='TreeDelete', tree='{all{one of{var0}{sig/Ad}}{all{one of{var3}{sig/User}}{in{->{var3/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/Photo}{sig/Ad}}{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":96409000,"targetExpr":"all p : Photo, u1 : User | p not in Ad and u1 -> p in sees implies (some u2 : User | u2 -> p in posts and u1 -> u2 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u,u2:User, p:Photo | u->p in sees implies u->u2 in follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","sourceExpr":"all u, j : User | all p : Photo | u -> p in sees implies u -> j in follows","predicate":"inv3","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":215179000,"targetExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | (p in u.sees and p not in Ad) implies p in u.follows.posts and (all p1:Photo | p1 in Ad implies p1 in u.sees) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{AND{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u : User, p : Photo | p in u.sees and p not in Ad implies some z: User | p in u.follows.posts","sourceExpr":"all u:User, p:Photo | (p in u.sees and p not in Ad) implies p in u.follows.posts and (all p1:Photo | p1 in Ad implies p1 in u.sees)","predicate":"inv3","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{some{one of{var2}{sig/User}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=some)\", \"(type='Move', tree='{one of{var2}{sig/Photo}}', parent=AND, position=0)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='TreeDelete', tree='{=>{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{!in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{some{one of{var2}{sig/User}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":80152900,"targetExpr":"all u : User, p : Photo | p in u.sees and p not in Ad implies some z: User | p in u.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all p: Photo - Ad, u: User | p in u.follows.posts => p in u.sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}}}}","nextExpr":"all p : Photo - Ad | all u : User | p in u.sees implies p in u.follows.posts","sourceExpr":"all p: Photo - Ad, u: User | p in u.follows.posts => p in u.sees","predicate":"inv3","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Update', node=field/posts, value=field/sees)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the variable of type User is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":59235000,"targetExpr":"all p : Photo - Ad | all u : User | p in u.sees implies p in u.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u1, u2:User, p:Photo | u1 -> p in sees and u2 -> p in posts implies u1 -> u2 in follows sees in User set -> set Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}{in{field/sees{set of{sig/Photo}}}{->{sig/User}{sig/Ad}}}}","nextExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","sourceExpr":"all u1, u2:User, p:Photo | u1 -> p in sees and u2 -> p in posts implies u1 -> u2 in follows sees in User set -> set Ad","predicate":"inv3","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}', parent=root, position=0)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='TreeDelete', tree='{in{field/sees{set of{sig/Photo}}}{->{sig/User}{sig/Ad}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":88441200,"targetExpr":"all u,x:User, p:Photo-Ad| u->p in sees and x->p in posts implies u->x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one->Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { User.sees = Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{={.{sig/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}","nextExpr":"sees in (follows.posts + User -> Ad)","sourceExpr":"User.sees = Ad","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{in{field/sees{set of{sig/Photo}}}{+{->{sig/User}{sig/Ad}}{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}}}","operations":"[\"(type='Insert', node=in, parent=root, position=0)\", \"(type='TreeInsert', tree='{field/sees{set of{sig/Photo}}}', parent=in, position=0)\", \"(type='Update', node==, value=+)\", \"(type='Move', tree='{={.{sig/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}', parent=in, position=1)\", \"(type='TreeInsert', tree='{->{sig/User}{sig/Ad}}', parent==, position=0)\", \"(type='Insert', node=field/follows, parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Move', tree='{sig/User}', parent=set of, position=0)\", \"(type='Delete', node=sig/Ad)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{in{field/sees{set of{sig/Photo}}}{+{->{sig/User}{sig/Ad}}{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":51304900,"targetExpr":"sees in (follows.posts + User -> Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all p:Photo, u:User | u -> p in sees implies p in Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{in{var0/Photo}{sig/Ad}}}}}","nextExpr":"all u : User, p : Photo | u -> p in sees => p in Ad + u.follows.posts","sourceExpr":"all p:Photo, u:User | u -> p in sees implies p in Ad","predicate":"inv3","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{in{var1/Photo}{+{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=var0/Photo, value=var1/Photo)\", \"(type='Insert', node=+, parent=in, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Photo, value=var1/Photo)\", \"(type='TreeInsert', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}', parent=+, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=+, position=1)\"]","hint":"Keep going! Instead of using signature of type Photo, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{in{var1/Photo}{+{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":57530600,"targetExpr":"all u : User, p : Photo | u -> p in sees => p in Ad + u.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p:Photo| some (sees.p & posts.p).follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{some{.{&{.{field/sees{set of{sig/Photo}}}{var0/Photo}}{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all p: Photo-Ad | sees.p in follows.posts.p","sourceExpr":"all p:Photo| some (sees.p & posts.p).follows","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{in{.{field/sees{set of{sig/Photo}}}{var0/Photo}}{.{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}{var0/Photo}}}}","operations":"[\"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{.{field/sees{set of{sig/Photo}}}{var0/Photo}}{.{field/posts{set of{sig/Photo}}}{var0/Photo}}}', parent=all, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=0)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using intersection operator ('&') to find the common elements between two sets, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{in{.{field/sees{set of{sig/Photo}}}{var0/Photo}}{.{.{field/follows{set of{sig/User}}}{field/posts{set of{sig/Photo}}}}{var0/Photo}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":58044000,"targetExpr":"all p: Photo-Ad | sees.p in follows.posts.p","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all p: Photo, u: User | p in u.follows.posts => (p in u.sees or p in Ad) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{OR{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{sig/Ad}}}}}}","nextExpr":"all p : Photo | all u : User | p in u.sees => p in u.follows.posts or p in Ad","sourceExpr":"all p: Photo, u: User | p in u.follows.posts => (p in u.sees or p in Ad)","predicate":"inv3","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{OR{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{in{var0/Photo}{sig/Ad}}}}}","operations":"[\"(type='Update', node==>, value=OR)\", \"(type='Insert', node==>, parent==>, position=0)\", \"(type='Move', tree='{in{var0/Photo}{sig/Ad}}', parent==>, position=1)\", \"(type='Move', tree='{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}', parent==>, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Update', node=field/posts, value=field/sees)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=OR)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{OR{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{var0/Photo}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{in{var0/Photo}{sig/Ad}}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":64307000,"targetExpr":"all p : Photo | all u : User | p in u.sees => p in u.follows.posts or p in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u1:User | u1 -> p in sees implies (all u2:User | u2 -> p in posts and u1 -> u2 in follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all p : Photo - Ad, u1 : User | u1->p in sees => some u2 : User | u2->p in posts and u1->u2 in follows","sourceExpr":"all p:Photo,u1:User | u1 -> p in sees implies (all u2:User | u2 -> p in posts and u1 -> u2 in follows)","predicate":"inv3","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Update', node=all, value=some)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":66698900,"targetExpr":"all p : Photo - Ad, u1 : User | u1->p in sees => some u2 : User | u2->p in posts and u1->u2 in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts && u.sees in Ad } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{AND{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}}}","nextExpr":"all x : User | x.sees in (x.follows.posts + x.follows + Ad )","sourceExpr":"all u : User | u.sees in u.follows.posts and u.sees in Ad","predicate":"inv3","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{+{+{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{sig/Ad}}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Insert', node=+, parent=AND, position=1)\", \"(type='Insert', node=+, parent=+, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=+, position=1)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}', parent=+, position=0)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=+, position=1)\", \"(type='Update', node=field/sees, value=field/follows)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{+{+{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{sig/Ad}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":185167900,"targetExpr":"all x : User | x.sees in (x.follows.posts + x.follows + Ad )","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | u in p.~sees => p in u.follows.posts } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var0/User}{.{var1/Photo}{~{field/sees{set of{sig/Photo}}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","nextExpr":"all x : User | all y : Photo - Ad | y in x.sees implies y in x.follows.posts","sourceExpr":"all u: User, p: Photo | u in p.~sees => p in u.follows.posts","predicate":"inv3","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Update', node=var0/User, value=var1/Photo)\", \"(type='Update', node=var1/Photo, value=var0/User)\", \"(type='Move', tree='{field/sees{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":59951900,"targetExpr":"all x : User | all y : Photo - Ad | y in x.sees implies y in x.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => u in p.~posts.follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var0/User}{.{var1/Photo}{~{field/sees{set of{sig/Photo}}}}}}{in{var0/User}{.{.{var1/Photo}{~{field/posts{set of{sig/Photo}}}}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all x : User | all y : Photo - Ad | y in x.sees implies y in x.follows.posts","sourceExpr":"all u: User, p: Photo - Ad | u in p.~sees => u in p.~posts.follows","predicate":"inv3","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Update', node=var0/User, value=var1/Photo)\", \"(type='Update', node=var0/User, value=var1/Photo)\", \"(type='Update', node=var1/Photo, value=var0/User)\", \"(type='Move', tree='{field/sees{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Update', node=var1/Photo, value=var0/User)\", \"(type='Update', node=field/posts, value=field/follows)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using variable of type User, try using variable of type Photo to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":60780900,"targetExpr":"all x : User | all y : Photo - Ad | y in x.sees implies y in x.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| u not in u.follows } pred inv3 { all p: Photo|all u: User|some (sees.p & u.follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{some{&{.{field/sees{set of{sig/Photo}}}{var0/Photo}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all p : Photo - Ad | all u : User | p in u.sees implies posts.p in u.follows","sourceExpr":"all p: Photo|all u: User|some (sees.p & u.follows)","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{.{field/posts{set of{sig/Photo}}}{var0/Photo}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=some, value==>)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='TreeInsert', tree='{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}', parent=some, position=0)\", \"(type='Update', node=&, value=in)\", \"(type='Update', node=field/sees, value=field/posts)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{=>{in{var0/Photo}{.{var1/User}{field/sees{set of{sig/Photo}}}}}{in{.{field/posts{set of{sig/Photo}}}{var0/Photo}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":63509900,"targetExpr":"all p : Photo - Ad | all u : User | p in u.sees implies posts.p in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u->p in sees implies ((lone u2:User | u->u2 in follows and u2->p in posts) or (p in Ad)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{OR{in{var1/Photo}{sig/Ad}}{lone{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}}","nextExpr":"all u : User | all p : Photo | u -> p in sees implies ((some u2 : User | u -> u2 in follows and u2 -> p in posts) or p in Ad)","sourceExpr":"all u:User, p:Photo | u->p in sees implies ((lone u2:User | u->u2 in follows and u2->p in posts) or (p in Ad))","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{OR{in{var1/Photo}{sig/Ad}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}}","operations":"[\"(type='Update', node=lone, value=some)\"]","hint":"One step away from the solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/sees{set of{sig/Photo}}}}{OR{in{var1/Photo}{sig/Ad}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":46000400,"targetExpr":"all u : User | all p : Photo | u -> p in sees implies ((some u2 : User | u -> u2 in follows and u2 -> p in posts) or p in Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u: User, p: Photo | p in u.sees implies (some f: u.follows | p in f.posts) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u : User, p : Photo | p in u.sees implies (p in Ad or one u1 : u.follows | p in u1.posts)","sourceExpr":"all u: User, p: Photo | p in u.sees implies (some f: u.follows | p in f.posts)","predicate":"inv3","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{OR{in{var1/Photo}{sig/Ad}}{one{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}}","operations":"[\"(type='Insert', node=OR, parent==>, position=1)\", \"(type='TreeInsert', tree='{in{var1/Photo}{sig/Ad}}', parent=OR, position=0)\", \"(type='Update', node=some, value=one)\", \"(type='Move', tree='{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}', parent=OR, position=1)\"]","hint":"Keep going! Consider adding a disjunction operator ('or') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{OR{in{var1/Photo}{sig/Ad}}{one{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":68530700,"targetExpr":"all u : User, p : Photo | p in u.sees implies (p in Ad or one u1 : u.follows | p in u1.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all a : Ad, u:User | u->a in sees all u1, u2 : User, p:Photo | u1 -> p in sees implies (u2 -> p in posts and u1->u2 in follows) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{in{->{var1/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}}}{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{all{one of{var4}{sig/Photo}}{=>{in{->{var2/User}{var4/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var3/User}{var4/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var3/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all p: Photo - Ad, u1: User | some u2: User | u1->p in sees => u2->p in posts and u1->u2 in follows","sourceExpr":"all a : Ad, u:User | u->a in sees all u1, u2 : User, p:Photo | u1 -> p in sees implies (u2 -> p in posts and u1->u2 in follows)","predicate":"inv3","isNewNode":true,"srcDstTED":28,"targetAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{some{one of{var2}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Ad}}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{one of{var1}{sig/User}}', parent=all, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{all{one of{var3}{sig/User}}{all{one of{var4}{sig/Photo}}{=>{in{->{var2/User}{var4/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var3/User}{var4/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var3/User}}{field/follows{set of{sig/User}}}}}}}}}', parent=all, position=1)\", \"(type='Insert', node=sig/Photo, parent=-, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=-, position=1)\", \"(type='Move', tree='{=>{in{->{var2/User}{var4/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var3/User}{var4/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/User}{var3/User}}{field/follows{set of{sig/User}}}}}}', parent=all, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var4/Photo, value=var0/Photo)\", \"(type='Update', node=var3/User, value=var2/User)\", \"(type='Update', node=var4/Photo, value=var0/Photo)\", \"(type='Insert', node=var1/User, parent=->, position=0)\", \"(type='Delete', node=var3/User)\", \"(type='TreeDelete', tree='{one of{var3}{sig/User}}')\", \"(type='TreeDelete', tree='{one of{var4}{sig/Photo}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{in{->{var1/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{-{sig/Photo}{sig/Ad}}}{all{one of{var1}{sig/User}}{some{one of{var2}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/sees{set of{sig/Photo}}}}{AND{in{->{var2/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":28,"challenge":"dkZH6HJNQNLLDX6Aj","time":84599900,"targetExpr":"all p: Photo - Ad, u1: User | some u2: User | u1->p in sees => u2->p in posts and u1->u2 in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in p.sees and p in u2.posts implies u1 in u2.follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var0/User}{.{var2/Photo}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all user1, user2 : User | all p : Photo - Ad | (p in user1.sees and p in user2.posts) implies user2 in user1.follows","sourceExpr":"all u1,u2:User, p:Photo-Ad | u1 in p.sees and p in u2.posts implies u1 in u2.follows","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var2/Photo)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var2/Photo, value=var0/User)\"]","hint":"Keep going! Instead of using variable of type User, try using variable of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{-{sig/Photo}{sig/Ad}}}{=>{AND{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":80901200,"targetExpr":"all user1, user2 : User | all p : Photo - Ad | (p in user1.sees and p in user2.posts) implies user2 in user1.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts all i: Ad, u: User | u.sees in i } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var1}{sig/Ad}}{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u:User | u.sees-Ad in u.follows.posts all u:User | u.sees<:Ad in Ad","sourceExpr":"all u: User | u.sees in u.follows.posts all i: Ad, u: User | u.sees in i","predicate":"inv3","isNewNode":true,"srcDstTED":9,"targetAST":"{AND{all{one of{var0}{sig/User}}{in{-{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/User}}{in{<:{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}{sig/Ad}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{var1/Ad}}}', parent=AND, position=1)\", \"(type='Insert', node=-, parent=in, position=0)\", \"(type='Insert', node=<:, parent=in, position=0)\", \"(type='Insert', node=sig/Ad, parent=in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/sees{set of{sig/Photo}}}}', parent=<:, position=0)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Move', tree='{var1/Ad}', parent=<:, position=1)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Ad}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the conjunction operator ('and') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/User}}{in{-{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{all{one of{var0}{sig/User}}{in{<:{.{var0/User}{field/sees{set of{sig/Photo}}}}{sig/Ad}}{sig/Ad}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":68145000,"targetExpr":"all u:User | u.sees-Ad in u.follows.posts all u:User | u.sees<:Ad in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u,u2:User, p:Photo | u->p in sees implies ((u->u2 in follows and u2->p in posts) or (p in Ad)) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{OR{AND{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u1, u2 : User, p : Photo | (u1 -> p in sees and u2 -> p in posts) => (u1 -> u2 in follows or p in Ad)","sourceExpr":"all u,u2:User, p:Photo | u->p in sees implies ((u->u2 in follows and u2->p in posts) or (p in Ad))","predicate":"inv3","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Insert', node=OR, parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=OR, position=0)\", \"(type='Move', tree='{in{var2/Photo}{sig/Ad}}', parent=OR, position=1)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Update', node=field/posts, value=field/follows)\", \"(type='Insert', node=var2/Photo, parent=->, position=2)\", \"(type='Insert', node=var0/User, parent=->, position=0)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=var2/Photo)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=OR)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var2/Photo}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":74516200,"targetExpr":"all u1, u2 : User, p : Photo | (u1 -> p in sees and u2 -> p in posts) => (u1 -> u2 in follows or p in Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | #posts.p=1 } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u: User, p: Photo | p in u.sees implies (some f: u.follows | p in f.posts) all a: Ad, u: User | a in u.sees } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}{all{one of{var3}{sig/Ad}}{all{one of{var0}{sig/User}}{in{var3/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}}","nextExpr":"all u : User, p : Photo | p in u.sees implies (p in Ad or one u1 : u.follows | p in u1.posts)","sourceExpr":"all u: User, p: Photo | p in u.sees implies (some f: u.follows | p in f.posts) all a: Ad, u: User | a in u.sees","predicate":"inv3","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{OR{in{var1/Photo}{sig/Ad}}{one{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}', parent=root, position=0)\", \"(type='Insert', node=OR, parent==>, position=1)\", \"(type='TreeInsert', tree='{in{var1/Photo}{sig/Ad}}', parent=OR, position=0)\", \"(type='Update', node=some, value=one)\", \"(type='Move', tree='{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}', parent=OR, position=1)\", \"(type='TreeDelete', tree='{all{one of{var3}{sig/Ad}}{all{one of{var0}{sig/User}}{in{var3/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{OR{in{var1/Photo}{sig/Ad}}{one{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Photo}{.{var2/User}{field/posts{set of{sig/Photo}}}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":81748300,"targetExpr":"all u : User, p : Photo | p in u.sees implies (p in Ad or one u1 : u.follows | p in u1.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => u in p.~sees.follows } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var0/User}{.{var1/Photo}{~{field/sees{set of{sig/Photo}}}}}}{in{var0/User}{.{.{var1/Photo}{~{field/sees{set of{sig/Photo}}}}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all x : User | all y : Photo - Ad | y in x.sees implies y in x.follows.posts","sourceExpr":"all u: User, p: Photo - Ad | u in p.~sees => u in p.~sees.follows","predicate":"inv3","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Update', node=var0/User, value=var1/Photo)\", \"(type='Update', node=var0/User, value=var1/Photo)\", \"(type='Update', node=var1/Photo, value=var0/User)\", \"(type='Move', tree='{field/sees{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Update', node=field/follows, value=field/posts)\", \"(type='Update', node=var1/Photo, value=var0/User)\", \"(type='Update', node=field/sees, value=field/follows)\", \"(type='Move', tree='{field/sees{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Update', node=sig/User, value=sig/Photo)\", \"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using variable of type User, try using variable of type Photo to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{=>{in{var1/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":63220500,"targetExpr":"all x : User | all y : Photo - Ad | y in x.sees implies y in x.follows.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts = Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var0/User}{.{var1/Ad}{~{field/posts{set of{sig/Photo}}}}}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u : User, a: Ad | u in a.~posts => u.posts = Ad","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Update', node=var0/User, value=var1/Ad)\", \"(type='Update', node=var1/Ad, value=var0/User)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":124581600,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some al: Ad | al in u.posts => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{some{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","nextExpr":"all u : User, ad : Ad | ad in u.posts implies u.posts in Ad","sourceExpr":"all u: User, a: Ad | some al: Ad | al in u.posts => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Move', tree='{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}', parent=all, position=1)\", \"(type='Update', node=var2/Ad, value=var1/Ad)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":43792000,"targetExpr":"all u : User, ad : Ad | ad in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | some p: u.posts | p in a => u.posts = Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{some{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var2/Photo}{var1/Ad}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","nextExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","sourceExpr":"all u: User, a: Ad | some p: u.posts | p in a => u.posts = Ad","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=in, parent==>, position=0)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Move', tree='{var1/Ad}', parent=in, position=0)\", \"(type='Move', tree='{.{var0/User}{field/posts{set of{sig/Photo}}}}', parent=in, position=1)\", \"(type='Insert', node=var2/Photo, parent=in, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=in, position=1)\", \"(type='Delete', node=var2/Photo)\", \"(type='Delete', node=in)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":54470100,"targetExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { all u: User | one a: Ad | u.posts in a => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u : User, ad : Ad | ad in u.posts implies u.posts in Ad","sourceExpr":"all u: User | one a: Ad | u.posts in a => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Insert', node=var1/Ad, parent=in, position=0)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Near a solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":53032200,"targetExpr":"all u : User, ad : Ad | ad in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | some p1:Ad | u -> p1 in posts implies (all p2:Photo | u -> p2 in posts implies p2 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all x : User| some a : Ad | x-> a in posts implies all z : Photo | x->z in posts implies z in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":145014000,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | one p:Ad | p in u.posts implies u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u : User | one a : Ad | a in u.posts implies u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":122484400,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p in Ad or p in u.follows.posts) } pred inv4 { all u:User | some p:Photo | ((p in u.posts) and (p in Ad)) iff u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Photo}}{<=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u: User, p: Photo | p in u.posts and p in Ad implies u.posts in Ad","sourceExpr":"all u:User | some p:Photo | ((p in u.posts) and (p in Ad)) iff u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":54813500,"targetExpr":"all u: User, p: Photo | p in u.posts and p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var0/User}{.{var1/Ad}{~{field/posts{set of{sig/Photo}}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u : User, ad : Ad | ad in u.posts implies u.posts in Ad","sourceExpr":"all u : User, a: Ad | u in a.~posts => u.posts in a","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=var0/User, value=var1/Ad)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Update', node=var1/Ad, value=var0/User)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using variable of type User, try using variable of type Ad to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":46380600,"targetExpr":"all u : User, ad : Ad | ad in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | one p:Photo | p in Ad and p in u.posts implies u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u : User | one p : Photo | p in u.posts and p in Ad implies u.posts in Ad","sourceExpr":"all u : User | one p : Photo | p in Ad and p in u.posts implies u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='TreeInsert', tree='{in{var1/Photo}{sig/Ad}}', parent=AND, position=2)\", \"(type='Update', node=set of, value=var1/Photo)\", \"(type='Move', tree='{set of{sig/Photo}}', parent=in, position=0)\", \"(type='Update', node=sig/Ad, value=.)\", \"(type='Update', node=field/posts, value=var0/User)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=sig/Ad, position=0)\", \"(type='Update', node=var1/Photo, value=field/posts)\", \"(type='Move', tree='{var1/Photo}', parent=sig/Ad, position=1)\", \"(type='Update', node=in, value=set of)\", \"(type='Move', tree='{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}', parent=var1/Photo, position=0)\", \"(type='Update', node=., value=sig/Photo)\", \"(type='Delete', node=sig/Photo)\", \"(type='Delete', node=var1/Photo)\", \"(type='Delete', node=var0/User)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":114091500,"targetExpr":"all u: User, p: Photo | p in u.posts and p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { all x,y :User| x->y in follows implies x!=y } pred inv3 { all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies x->y in follows } pred inv4 { one a:Ad, x:User| x->a in posts implies posts.x in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/Ad}}{one{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{field/posts{set of{sig/Photo}}}{var1/User}}{sig/Ad}}}}}","nextExpr":"all x:User, a:Ad| x->a in posts implies x.posts in Ad","sourceExpr":"one a:Ad, x:User| x->a in posts implies posts.x in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=one, value=all)\", \"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":49570700,"targetExpr":"all x:User, a:Ad| x->a in posts implies x.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u : User, p:Photo | u -> p in sees implies (some u2:User | u->u2 in follows and u2->p in posts) or p in Ad } pred inv4 { all a:Ad, u:User | u->a in posts implies (some p:Photo | u->p in posts and p in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{some{one of{var2}{sig/Photo}}{AND{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u : User, ad : Ad | u->ad in posts implies (all p:Photo | u->p in posts implies p in Ad)","sourceExpr":"all a:Ad, u:User | u->a in posts implies (some p:Photo | u->p in posts and p in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\"]","hint":"Keep going! Instead of using signature of type Ad, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":46541100,"targetExpr":"all u : User, ad : Ad | u->ad in posts implies (all p:Photo | u->p in posts implies p in Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { all x,y :User| x->y in follows implies x!=y } pred inv3 { all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies x->y in follows } pred inv4 { one a:Ad | all x:User, p:Photo| x->a in posts and x->p in posts implies p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var1/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all u:User, a:Ad, p:Photo | u->a in posts and u->p in posts implies p in Ad","sourceExpr":"one a:Ad | all x:User, p:Photo| x->a in posts and x->p in posts implies p in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":52966500,"targetExpr":"all u:User, a:Ad, p:Photo | u->a in posts and u->p in posts implies p in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | some p: u.posts | p in a => u.posts = a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{some{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var2/Photo}{var1/Ad}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}}","nextExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","sourceExpr":"all u: User, a: Ad | some p: u.posts | p in a => u.posts = a","predicate":"inv4","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=in, parent==>, position=0)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Move', tree='{var1/Ad}', parent=in, position=0)\", \"(type='Move', tree='{.{var0/User}{field/posts{set of{sig/Photo}}}}', parent=in, position=1)\", \"(type='Update', node=var1/Ad, value=var2/Photo)\", \"(type='Move', tree='{var1/Ad}', parent=in, position=0)\", \"(type='Insert', node=sig/Ad, parent=in, position=1)\", \"(type='Delete', node=var2/Photo)\", \"(type='Delete', node=in)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":76316100,"targetExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some p: u.posts | p in a => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{some{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var2/Photo}{var1/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, a: Ad | some p: u.posts | p in a => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value==>)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}', parent=some, position=1)\", \"(type='Update', node=var2, value=var1/Ad)\", \"(type='TreeDelete', tree='{in{var2/Photo}{var1/Ad}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":46250000,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User | some p: u.posts | all a: Ad| p in a => u.posts in a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Ad}}{=>{in{var1/Photo}{var2/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}}}}}","nextExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","sourceExpr":"all u: User | some p: u.posts | all a: Ad| p in a => u.posts in a","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{=>{in{var1/Photo}{var2/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}}', parent=some, position=1)\", \"(type='Update', node=var2/Ad, value=sig/Ad)\", \"(type='Update', node=var2/Ad, value=sig/Ad)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":44030100,"targetExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | u.posts in a => u.posts in a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, a: Ad | u.posts in a => u.posts in a","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Insert', node=var1/Ad, parent=in, position=0)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Ad to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":46175500,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u : User | all ad : Ad | ad in u.posts implies u.posts in ad","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=var1/Ad, value=sig/Ad)\"]","hint":"One step away from the solution! Instead of using variable of type Ad, try using signature of type Ad to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":104465600,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { all x,y :User| x->y in follows implies x!=y } pred inv3 { all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies x->y in follows } pred inv4 { one a:Ad|all x:User| x->a in posts implies x.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var1/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all a : Ad, u : User | a in u.posts implies u.posts in Ad","sourceExpr":"one a:Ad|all x:User| x->a in posts implies x.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{var0/Ad}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{.{var1/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Insert', node=var0/Ad, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=var0/Ad)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{var0/Ad}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{.{var1/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":40822100,"targetExpr":"all a : Ad, u : User | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p in u.posts } pred inv2 { no u : User | u in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees implies p in u.follows.posts or p in Ad } pred inv4 { all u : User, p : Photo | p in u.posts and Ad in p } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{sig/Ad}{var1/Photo}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u : User, p : Photo | p in u.posts and Ad in p","predicate":"inv4","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Photo, value=sig/Ad)\", \"(type='Update', node=var1/Photo, value=var1/Ad)\", \"(type='TreeInsert', tree='{.{var0/User}{field/posts{set of{sig/Photo}}}}', parent=in, position=0)\", \"(type='Delete', node=var1/Photo)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":40575400,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | one p:Photo | p in Ad and p in u.posts implies (all p1:Photo | p1 in u.posts implies p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all a : User, b : Photo | b in Ad and b in a.posts implies (all c : Photo | c in a.posts implies c in Ad)","sourceExpr":"all u:User | one p:Photo | p in Ad and p in u.posts implies (all p1:Photo | p1 in u.posts implies p1 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{sig/Ad}}{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":49234200,"targetExpr":"all a : User, b : Photo | b in Ad and b in a.posts implies (all c : Photo | c in a.posts implies c in Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p in Ad or p in u.follows.posts) } pred inv4 { all u:User | some a:Ad | some (u.posts -> Ad) implies u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{some{->{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u:User | some a:Ad | some (u.posts -> Ad) implies u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=->, value=in)\", \"(type='Move', tree='{->{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}', parent==>, position=0)\", \"(type='Insert', node=var1/Ad, parent=->, position=0)\", \"(type='Delete', node=sig/Ad)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":41546700,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts = a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u:User, a: Ad | a in u.posts implies u.posts = Ad","sourceExpr":"all u:User, a: Ad | a in u.posts implies u.posts = a","predicate":"inv4","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=var1/Ad, value=sig/Ad)\"]","hint":"Near a solution! Instead of using variable of type Ad, try using signature of type Ad to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":95901200,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User | one a: Ad | a in u.posts => all d: Ad | u.posts in d } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User | one a: Ad | a in u.posts => all d: Ad | u.posts in d","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Move', tree='{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}', parent==>, position=1)\", \"(type='Update', node=var2/Ad, value=sig/Ad)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":55322100,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | all p: u.posts | p in a => u.posts = a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var2/Photo}{var1/Ad}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}}","nextExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","sourceExpr":"all u: User, a: Ad | all p: u.posts | p in a => u.posts = a","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Insert', node=in, parent==>, position=0)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Move', tree='{var1/Ad}', parent=in, position=0)\", \"(type='Move', tree='{.{var0/User}{field/posts{set of{sig/Photo}}}}', parent=in, position=1)\", \"(type='Update', node=var1/Ad, value=var2/Photo)\", \"(type='Move', tree='{var1/Ad}', parent=in, position=0)\", \"(type='Insert', node=sig/Ad, parent=in, position=1)\", \"(type='Delete', node=var2/Photo)\", \"(type='Delete', node=in)\", \"(type='Delete', node==)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":43536200,"targetExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all p:Photo, u:User | u -> p in posts implies p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Photo}}{field/posts{set of{sig/Photo}}}}{in{var0/Photo}{sig/Ad}}}}}","nextExpr":"all u:User, a:Ad| u->a in posts implies u.posts in Ad","sourceExpr":"all p:Photo, u:User | u -> p in posts implies p in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Photo, value=var1/Ad)\", \"(type='Update', node=var0/Photo, value=var0/User)\", \"(type='Move', tree='{var0/Photo}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using signature of type Photo, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":40539200,"targetExpr":"all u:User, a:Ad| u->a in posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User | all p: u.posts | p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}}","nextExpr":"all ad : Ad | all posts : posts.ad.posts | posts in Ad","sourceExpr":"all u : User | all p : u.posts | p in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{.{.{field/posts{set of{sig/Photo}}}{var0/Ad}}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}}","operations":"[\"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Insert', node=field/posts, parent=., position=0)\", \"(type='Insert', node=var0/Ad, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/posts, position=0)\", \"(type='Update', node=var0/User, value=sig/Photo)\", \"(type='Move', tree='{var0/User}', parent=set of, position=0)\"]","hint":"Keep going! Instead of using signature of type User, try using signature of type Ad to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{.{.{field/posts{set of{sig/Photo}}}{var0/Ad}}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":146970200,"targetExpr":"all ad : Ad | all posts : posts.ad.posts | posts in Ad","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { all u: User | some a: Ad | u.posts in a => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u:User | some a:Ad | u.posts in a implies u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=var1/Ad, parent=in, position=0)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":127229500,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User | all p:u.posts | u.posts in Ad implies p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}{in{var1/Photo}{sig/Ad}}}}}","nextExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","sourceExpr":"all u:User | all p:u.posts | u.posts in Ad implies p in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='TreeInsert', tree='{in{var1/Photo}{sig/Ad}}', parent==>, position=0)\", \"(type='TreeDelete', tree='{in{var1/Photo}{sig/Ad}}')\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":46068400,"targetExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, d: Ad | one a: Ad | u in a.~posts => u.posts in d } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{one{one of{var2}{sig/Ad}}{=>{in{var0/User}{.{var2/Ad}{~{field/posts{set of{sig/Photo}}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, d: Ad | one a: Ad | u in a.~posts => u.posts in d","predicate":"inv4","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Move', tree='{=>{in{var0/User}{.{var2/Ad}{~{field/posts{set of{sig/Photo}}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}', parent=all, position=1)\", \"(type='Update', node=var0/User, value=var1/Ad)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Update', node=var2/Ad, value=var0/User)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=~)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=one)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":42718900,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all p:Photo, i:Influencer | p -> i in posts implies p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/Influencer}}{=>{in{->{var0/Photo}{var1/Influencer}}{field/posts{set of{sig/Photo}}}}{in{var0/Photo}{sig/Ad}}}}}","nextExpr":"all x:User, a:Ad| x->a in posts implies x.posts in Ad","sourceExpr":"all p:Photo, i:Influencer | p -> i in posts implies p in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/Influencer, value=sig/Ad)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Update', node=var0/Photo, value=var0/User)\", \"(type='Update', node=var1/Influencer, value=var1/Ad)\", \"(type='Update', node=var0/Photo, value=var0/User)\", \"(type='Move', tree='{var0/Photo}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using signature of type Photo, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":42446700,"targetExpr":"all x:User, a:Ad| x->a in posts implies x.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User | one a: Ad | a in u.posts => u.posts = a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User | one a: Ad | a in u.posts => u.posts = a","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node==, value=in)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\"]","hint":"Near a solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":48241000,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User | one a: Ad | u.posts in a && #u.posts = 1 } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{AND{={#{.{var0/User}{field/posts{set of{sig/Photo}}}}}{1}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User | one a: Ad | u.posts in a && #u.posts = 1","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=#, value=in)\", \"(type='Move', tree='{#{.{var0/User}{field/posts{set of{sig/Photo}}}}}', parent=AND, position=0)\", \"(type='Insert', node=var1/Ad, parent=#, position=0)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Delete', node=1)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":42548800,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { all u: User, a: u.posts | u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","nextExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","sourceExpr":"all u: User, a: u.posts | u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var1/Photo}{sig/Ad}}', parent==>, position=0)\", \"(type='Move', tree='{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}', parent==>, position=1)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":49145000,"targetExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, d: Ad | one a: Ad | a in u.posts => u.posts in d } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{one{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, d: Ad | one a: Ad | a in u.posts => u.posts in d","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Move', tree='{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}', parent=all, position=1)\", \"(type='Update', node=var2/Ad, value=var1/Ad)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=one)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":53334200,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | some a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User | some a: Ad | a in u.posts => u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":98033500,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, a: Ad | a in u.posts => (all d: Ad | u.posts in d) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, a: Ad | a in u.posts => (all d: Ad | u.posts in d)","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Move', tree='{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}', parent==>, position=1)\", \"(type='Update', node=var2/Ad, value=sig/Ad)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the implication operator ('=>') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":41721200,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some p: u.posts | p in a => u.posts in a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{some{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var2/Photo}{var1/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, a: Ad | some p: u.posts | p in a => u.posts in a","predicate":"inv4","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value==>)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}', parent=some, position=1)\", \"(type='Update', node=var2, value=var1/Ad)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='TreeDelete', tree='{in{var2/Photo}{var1/Ad}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":46430600,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one->Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User,p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (one p:Photo | u->p in posts and p in Ad) implies (all p1:Photo | u->p1 in posts and p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{one{one of{var1}{sig/Photo}}{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all u : User | (all p : Photo | u->p in posts and p in Ad implies (all p1: Photo | u->p1 in posts implies p1 in Ad))","sourceExpr":"all u:User | (one p:Photo | u->p in posts and p in Ad) implies (all p1:Photo | u->p1 in posts and p1 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Move', tree='{one of{var1}{sig/Photo}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}', parent==>, position=1)\", \"(type='Update', node=AND, value==>)\", \"(type='Delete', node=one)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":48654900,"targetExpr":"all u : User | (all p : Photo | u->p in posts and p in Ad implies (all p1: Photo | u->p1 in posts implies p1 in Ad))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User | one a: Ad | a in u.posts => all d: Ad | u.posts = d } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Ad}}{={.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User | one a: Ad | a in u.posts => all d: Ad | u.posts = d","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node==, value=in)\", \"(type='Move', tree='{={.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}', parent==>, position=1)\", \"(type='Update', node=var2/Ad, value=sig/Ad)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Ad}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":45995100,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one u: User | p in u.posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User | some p: u.posts | all a: Ad| u.posts in a => u.posts in a } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Ad}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var2/Ad}}}}}}","nextExpr":"all x : User | all p : Photo-Ad | all a : Ad | a in x.posts implies p not in x.posts","sourceExpr":"all u: User | some p: u.posts | all a: Ad| u.posts in a => u.posts in a","predicate":"inv4","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{all{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{!in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=set of, value=-)\", \"(type='Move', tree='{set of{sig/Photo}}', parent=one of, position=1)\", \"(type='Insert', node=sig/Ad, parent=set of, position=1)\", \"(type='Update', node=in, value=!in)\", \"(type='Insert', node=var2/Ad, parent=in, position=0)\", \"(type='Insert', node=var1/Photo, parent=in, position=0)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=field/posts)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Ad)\", \"(type='Delete', node=var2/Ad)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{all{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{!in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":54139800,"targetExpr":"all x : User | all p : Photo-Ad | all a : Ad | a in x.posts implies p not in x.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | u.posts in a => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User, a: Ad | u.posts in a => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Insert', node=var1/Ad, parent=in, position=0)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Ad to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":41108000,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |some p:u.posts| p in Ad implies u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","sourceExpr":"all u: User | some e : u.posts | e in Ad implies u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":96434000,"targetExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | some p1:Ad | u -> p1 in posts implies (all p2:Photo | p1 != p2 and u -> p2 in posts implies p2 in Ad) } pred inv5 { all inf:Influencer | no u:User | u -> inf not in follows and u != inf } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{AND{!={var1/Ad}{var2/Photo}}{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all u:User | some p1:Ad | u -> p1 in posts implies (all p2:Photo | p1 != p2 and u -> p2 in posts implies p2 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent==>, position=0)\", \"(type='TreeDelete', tree='{!={var1/Ad}{var2/Photo}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":45758600,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { all x,y :User| x->y in follows implies x!=y } pred inv3 { all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies x->y in follows } pred inv4 { one a:Ad, x:User| x->a in posts implies x.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{one{one of{var0}{sig/Ad}}{one{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var1/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all a : Ad, u : User | a in u.posts implies u.posts in Ad","sourceExpr":"one a:Ad, x:User| x->a in posts implies x.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{var0/Ad}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{.{var1/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=one, value=all)\", \"(type='Insert', node=var0/Ad, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Delete', node=var0/Ad)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{var0/Ad}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{in{.{var1/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":43777800,"targetExpr":"all a : Ad, u : User | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all u:User | some p:Photo | u -> p in posts implies p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Photo}}{=>{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}}}","nextExpr":"all u : User , a : Ad | u->a in posts implies u.posts in Ad","sourceExpr":"all u:User | some p:Photo | u -> p in posts implies p in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Photo, value=sig/Ad)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Update', node=var1/Photo, value=var1/Ad)\", \"(type='Update', node=var1/Photo, value=var0/User)\", \"(type='Move', tree='{var1/Photo}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":38888500,"targetExpr":"all u : User , a : Ad | u->a in posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u1:User | p not in Ad and (u1 -> p in sees implies (all u2:User | u2 -> p in posts implies u1 -> u2 in follows)) } pred inv4 { all u:User | some p:Ad | u -> p in posts implies (all photo:Photo | u -> p in posts implies p in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{var1/Ad}{sig/Ad}}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all u:User | some p:Ad | u -> p in posts implies (all photo:Photo | u -> p in posts implies p in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=var1/Ad, value=var2/Photo)\", \"(type='Update', node=var1/Ad, value=var2/Photo)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":53027100,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some ua: a.~posts | ua in u.posts => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{some{one of{var2}{.{var1/Ad}{~{field/posts{set of{sig/Photo}}}}}}{=>{in{var2/User}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","nextExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","sourceExpr":"all u: User, a: Ad | some ua: a.~posts | ua in u.posts => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=var1/Ad, value=var0/User)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\", \"(type='Update', node=var2/User, value=var1/Ad)\", \"(type='Update', node=var0/User, value=var2/Photo)\", \"(type='Move', tree='{var0/User}', parent=in, position=0)\", \"(type='Delete', node=~)\", \"(type='TreeDelete', tree='{field/posts{set of{sig/Photo}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":52270100,"targetExpr":"all u : User| all p : Ad|all p2 : u.posts| p in u.posts implies p2 in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one->Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User,p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (one a:Ad | u->a in posts) implies (all p1:Photo | u->p1 in posts implies p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{one{one of{var1}{sig/Ad}}{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all u:User | (one a:Ad | u->a in posts) implies (all p1:Photo | u->p1 in posts implies p1 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Move', tree='{one of{var1}{sig/Ad}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}', parent==>, position=1)\", \"(type='Delete', node=one)\"]","hint":"Near a solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":54492200,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { all u: User | u.posts in Ad => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","nextExpr":"all x : User | x.posts in (Photo - Ad) or x.posts in Ad","sourceExpr":"all u : User | u.posts in Ad implies u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{OR{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{-{sig/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","operations":"[\"(type='Update', node==>, value=OR)\", \"(type='Insert', node=-, parent=in, position=1)\", \"(type='Insert', node=sig/Photo, parent=-, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=-, position=1)\"]","hint":"Near a solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/User}}{OR{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{-{sig/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":103315300,"targetExpr":"all x : User | x.posts in (Photo - Ad) or x.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | u.posts in a => (all p: u.posts | p in a) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{var1/Ad}}}}}}","nextExpr":"all u : User, p : Ad | p in u.posts => all po : u.posts | po in Ad","sourceExpr":"all u: User, a: Ad | u.posts in a => (all p: u.posts | p in a)","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Insert', node=var1/Ad, parent=in, position=0)\", \"(type='Update', node=var1/Ad, value=sig/Ad)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Ad to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":49123000,"targetExpr":"all u : User, p : Ad | p in u.posts => all po : u.posts | po in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p in Ad or p in u.follows.posts) } pred inv4 { all u:User | some (u.posts -> Ad) implies u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{some{->{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","nextExpr":"all u:User | some u.posts & Ad implies u.posts in Ad","sourceExpr":"all u:User | some (u.posts -> Ad) implies u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{=>{some{&{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","operations":"[\"(type='Update', node=->, value=&)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/User}}{=>{some{&{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":36385400,"targetExpr":"all u:User | some u.posts & Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies a in u.posts } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u : User , ad : Ad | ad in u.posts implies ad in u.posts","predicate":"inv4","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Insert', node=sig/Ad, parent=in, position=2)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Near a solution! Consider adding a signature of type Ad to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":122991200,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all p:Photo, u:User | p -> u in posts implies p in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Photo}}{all{one of{var1}{sig/User}}{=>{in{->{var0/Photo}{var1/User}}{field/posts{set of{sig/Photo}}}}{in{var0/Photo}{sig/Ad}}}}}","nextExpr":"all x:User, a:Ad| x->a in posts implies x.posts in Ad","sourceExpr":"all p:Photo, u:User | p -> u in posts implies p in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=sig/Photo, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Update', node=var0/Photo, value=var0/User)\", \"(type='Update', node=var1/User, value=var1/Ad)\", \"(type='Update', node=var0/Photo, value=var0/User)\", \"(type='Move', tree='{var0/Photo}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/posts{set of{sig/Photo}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using signature of type Photo, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":39695900,"targetExpr":"all x:User, a:Ad| x->a in posts implies x.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User | some al: Ad | al.~posts in u => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{.{var1/Ad}{~{field/posts{set of{sig/Photo}}}}}{var0/User}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","sourceExpr":"all u: User | some al: Ad | al.~posts in u => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{var1/Ad}', parent=in, position=0)\", \"(type='Update', node=~, value=.)\", \"(type='Move', tree='{~{field/posts{set of{sig/Photo}}}}', parent=in, position=1)\", \"(type='Insert', node=var0/User, parent=~, position=0)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var0/User)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":45793200,"targetExpr":"all u:User | all a:Ad | a in u.posts implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | one p:Photo | (p in u.posts and p in Ad) implies (all p1:Photo | p1 in u.posts implies p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u : User| all p : Photo-Ad | all a : Ad | a in u.posts implies not p in u.posts","sourceExpr":"all u : User | one p : Photo | p in u.posts and p in Ad implies (all x : Photo | x in u.posts implies x in Ad)","predicate":"inv4","isNewNode":false,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{all{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{!{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Insert', node=all, parent=one, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Ad}}', parent=all, position=0)\", \"(type='Move', tree='{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}', parent=all, position=1)\", \"(type='Move', tree='{sig/Photo}', parent=-, position=0)\", \"(type='Insert', node=sig/Ad, parent=-, position=1)\", \"(type='Move', tree='{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}', parent==>, position=0)\", \"(type='Update', node==>, value=!)\", \"(type='Move', tree='{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}', parent==>, position=1)\", \"(type='Update', node=var1/Photo, value=var2/Ad)\", \"(type='Update', node=var2/Photo, value=var1/Photo)\", \"(type='TreeDelete', tree='{in{var2/Photo}{sig/Ad}}')\", \"(type='TreeDelete', tree='{in{var1/Photo}{sig/Ad}}')\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Photo}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/Photo}{sig/Ad}}}{all{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{!{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":63375000,"targetExpr":"all u : User| all p : Photo-Ad | all a : Ad | a in u.posts implies not p in u.posts","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | some p:Ad | p in u.posts implies (all p:Photo | p in u.posts implies p in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}}}}}","nextExpr":"all u : User, a : Ad | a in u.posts implies all p : Photo | p in u.posts implies p in Ad","sourceExpr":"all u:User | some p:Ad | p in u.posts implies (all p:Photo | p in u.posts implies p in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=var1, value=var2)\", \"(type='Update', node=var1/Photo, value=var2/Photo)\", \"(type='Update', node=var1/Photo, value=var2/Photo)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":41947400,"targetExpr":"all u : User, a : Ad | a in u.posts implies all p : Photo | p in u.posts implies p in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User, p : Photo | (u -> p in posts and p in Ad) => all p1 : Photo | u -> p1 in posts and p1 in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u : User | (all p : Photo | u->p in posts and p in Ad implies (all p1: Photo | u->p1 in posts implies p1 in Ad))","sourceExpr":"all u : User, p : Photo | (u -> p in posts and p in Ad) => all p1 : Photo | u -> p1 in posts and p1 in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":37911300,"targetExpr":"all u : User | (all p : Photo | u->p in posts and p in Ad implies (all p1: Photo | u->p1 in posts implies p1 in Ad))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { all u: User | one a: u.posts | a in Ad => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","sourceExpr":"all u: User | one l : u.posts | l in Ad implies u.posts in Ad","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=one, value=all)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":111993500,"targetExpr":"all u : User | all p : u.posts | p in Ad implies u.posts in Ad","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p in Ad or p in u.follows.posts) } pred inv4 { all u:User | all p:Photo | ((p in u.posts) and (p in Ad)) iff u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{<=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","nextExpr":"all u: User, p: Photo | p in u.posts and p in Ad implies u.posts in Ad","sourceExpr":"all u:User | all p:Photo | ((p in u.posts) and (p in Ad)) iff u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\"]","hint":"One step away from the solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":29459100,"targetExpr":"all u: User, p: Photo | p in u.posts and p in Ad implies u.posts in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, d: Ad | d in u.posts => u.posts in d all u : User | one a : Ad | a in u.posts => u.posts in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{AND{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}}{all{one of{var0}{sig/User}}{one{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}}","nextExpr":"all u : User | (some a : Ad | a in u.posts) implies all p : Photo | p in u.posts implies p in Ad","sourceExpr":"all u: User, d: Ad | d in u.posts => u.posts in d all u : User | one a : Ad | a in u.posts => u.posts in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":23,"targetAST":"{all{one of{var0}{sig/User}}{=>{some{one of{var1}{sig/Ad}}{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/User}}', parent=AND, position=0)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/User}}{one{one of{var2}{sig/Ad}}{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Ad}}', parent=all, position=0)\", \"(type='Move', tree='{=>{in{var2/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}', parent=all, position=1)\", \"(type='Update', node=sig/Ad, value=sig/Photo)\", \"(type='Update', node=var2/Ad, value=var2/Photo)\", \"(type='Update', node=var0/User, value=var2/Photo)\", \"(type='Move', tree='{var0/User}', parent=in, position=0)\", \"(type='TreeDelete', tree='{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{var1/Ad}}')\", \"(type='Delete', node==>)\", \"(type='TreeDelete', tree='{field/posts{set of{sig/Photo}}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var0}{sig/User}}')\", \"(type='Delete', node=one)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{=>{some{one of{var1}{sig/Ad}}{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":23,"challenge":"dkZH6HJNQNLLDX6Aj","time":57666000,"targetExpr":"all u : User | (some a : Ad | a in u.posts) implies all p : Photo | p in u.posts implies p in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts and p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{some{one of{var1}{sig/Ad}}{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts and p1 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Move', tree='{one of{var1}{sig/Ad}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}', parent==>, position=1)\", \"(type='Update', node=AND, value==>)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":47271100,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u: User, a: Ad | a in u.posts => (all p: User.posts | p = a) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{.{sig/User}{field/posts{set of{sig/Photo}}}}}{={var1/Ad}{var2/Photo}}}}}}","nextExpr":"all u : User, p : Ad | p in u.posts => all po : u.posts | po in Ad","sourceExpr":"all u: User, a: Ad | a in u.posts => (all p: User.posts | p = a)","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=sig/Ad, parent==, position=2)\", \"(type='Update', node=sig/User, value=var0/User)\", \"(type='Delete', node=var1/Ad)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":42862300,"targetExpr":"all u : User, p : Ad | p in u.posts => all po : u.posts | po in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | some p : Photo | (u -> p in posts and p in Ad) => all p1 : Photo | u -> p1 in posts and p1 in Ad } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u : User | (all p : Photo | u->p in posts and p in Ad implies (all p1: Photo | u->p1 in posts implies p1 in Ad))","sourceExpr":"all u : User | some p : Photo | (u -> p in posts and p in Ad) => all p1 : Photo | u -> p1 in posts and p1 in Ad","predicate":"inv4","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{->{var0/User}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":52197800,"targetExpr":"all u : User | (all p : Photo | u->p in posts and p in Ad implies (all p1: Photo | u->p1 in posts implies p1 in Ad))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all p:u.posts| Ad in u.posts implies Ad in p } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{sig/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{sig/Ad}{var1/Photo}}}}}","nextExpr":"all u:User | all p: u.posts| (p in Ad) implies (u.posts in Ad)","sourceExpr":"all u:User |all p:u.posts| Ad in u.posts implies Ad in p","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","operations":"[\"(type='Insert', node=in, parent==>, position=0)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Insert', node=var1/Photo, parent=in, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/posts{set of{sig/Photo}}}}', parent=in, position=0)\", \"(type='Move', tree='{sig/Ad}', parent=in, position=1)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/Photo)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{in{.{var0/User}{field/posts{set of{sig/Photo}}}}{sig/Ad}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":46091500,"targetExpr":"all u:User | all p: u.posts| (p in Ad) implies (u.posts in Ad)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one->Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User,p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (one a:Ad | u->a in posts) implies (all p1:Photo | u->p1 in posts and p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{one{one of{var1}{sig/Ad}}{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all u:User | (one a:Ad | u->a in posts) implies (all p1:Photo | u->p1 in posts and p1 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Move', tree='{one of{var1}{sig/Ad}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Photo}}{AND{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}', parent==>, position=1)\", \"(type='Update', node=AND, value==>)\", \"(type='Delete', node=one)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":47319300,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | one p:Photo | (p in u.posts and p in Ad) implies (all p1:Photo | p1 in u.posts and p1 in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{AND{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all u: User | all p: Photo | p in u.posts and p in Ad implies all p1: Photo | p1 in u.posts implies p1 in Ad","sourceExpr":"all u:User | one p:Photo | (p in u.posts and p in Ad) implies (all p1:Photo | p1 in u.posts and p1 in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Photo}}{=>{AND{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":48160200,"targetExpr":"all u: User | all p: Photo | p in u.posts and p in Ad implies all p1: Photo | p1 in u.posts implies p1 in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u : User, p:Photo | u -> p in sees implies (some u2:User | u->u2 in follows and u2->p in posts) or p in Ad } pred inv4 { all a:Ad, u:User | u->a in posts implies (some p:Photo | u->p in posts implies p in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{some{one of{var2}{sig/Photo}}{=>{in{->{var1/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","nextExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","sourceExpr":"all a:Ad, u:User | u->a in posts implies (some p:Photo | u->p in posts implies p in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\"]","hint":"Keep going! Instead of using signature of type Ad, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{all{one of{var2}{sig/Photo}}{=>{in{->{var0/User}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":49803000,"targetExpr":"all x : User | all a : Ad | x -> a in posts implies all z : Photo | x -> z in posts implies z in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | one p:Ad | p in u.posts implies (all p:Photo | p in u.posts implies p in Ad) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{one{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var1}{sig/Photo}}{=>{in{var1/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{sig/Ad}}}}}}}","nextExpr":"all u : User | all a : Ad | a in u.posts implies all n : Photo | n in u.posts implies n in Ad","sourceExpr":"all u:User | one p:Ad | p in u.posts implies (all p:Photo | p in u.posts implies p in Ad)","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=var1, value=var2)\", \"(type='Update', node=var1/Photo, value=var2/Photo)\", \"(type='Update', node=var1/Photo, value=var2/Photo)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{all{one of{var2}{sig/Photo}}{=>{in{var2/Photo}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{in{var2/Photo}{sig/Ad}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":50392500,"targetExpr":"all u : User | all a : Ad | a in u.posts implies all n : Photo | n in u.posts implies n in Ad","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - Influencer | (i not in u => i in (u).follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i: Influencer, u: User - Influencer | (i not in u => i in (u).follows)","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Near a solution! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":123570900,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i != User => (i in u.follows && User not in i.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!={sig/User}{var0/Influencer}}{AND{!in{sig/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i != User => (i in u.follows && User not in i.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Move', tree='{!in{sig/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Move', tree='{var0/Influencer}', parent=!in, position=0)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Move', tree='{sig/User}', parent=!in, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/follows)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{!={sig/User}{var0/Influencer}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":72673400,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u->p in sees implies ((one u2:User | u->u2 in follows and u2->p in posts) or (p in Ad)) } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { not some u:User, i:Influencer | u->i in follows and u=i } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{!{some{one of{var0}{sig/User}}{some{one of{var1}{sig/Influencer}}{AND{={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u: User , i: Influencer | u->i in follows or u=i","sourceExpr":"not some u:User, i:Influencer | u->i in follows and u=i","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{OR{={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/User}}{some{one of{var1}{sig/Influencer}}{AND{={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value=OR)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{OR{={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":37041300,"targetExpr":"all u: User , i: Influencer | u->i in follows or u=i","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u : User, p:Photo | u -> p in sees implies (some u2:User | u->u2 in follows and u2->p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | u->i in follows implies (u in User or u in Influencer) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}{OR{in{var1/User}{sig/User}}{in{var1/User}{sig/Influencer}}}}}}","nextExpr":"all i : Influencer, u : User | u != i implies u->i in follows","sourceExpr":"all i:Influencer, u:User | u->i in follows implies (u in User or u in Influencer)","predicate":"inv5","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='TreeInsert', tree='{!={var0/Influencer}{var1/User}}', parent==>, position=0)\", \"(type='TreeDelete', tree='{OR{in{var1/User}{sig/User}}{in{var1/User}{sig/Influencer}}}')\"]","hint":"Keep going! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":37279600,"targetExpr":"all i : Influencer, u : User | u != i implies u->i in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: User, u: User - Influencer | (i not in u => i in (u).follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!in{var0/User}{var1/User}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i: User, u: User - Influencer | (i not in u => i in (u).follows)","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=sig/User, value=sig/Influencer)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Update', node=var0/User, value=var0/Influencer)\", \"(type='Update', node=var0/User, value=var0/Influencer)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using signature of type User, try using signature of type Influencer to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":42576000,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i not in u => (i in u.follows && u not in i.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!in{var0/Influencer}{var1/User}}{AND{!in{var1/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i not in u => (i in u.follows && u not in i.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Move', tree='{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='TreeDelete', tree='{!in{var1/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":39673000,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer | i in (User - i).follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{in{var0/Influencer}{.{-{sig/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all i:Influencer | User-i in follows.i","sourceExpr":"all i : Influencer | i in (User-i).follows","predicate":"inv5","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Influencer}}{in{-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","operations":"[\"(type='Move', tree='{-{sig/User}{var0/Influencer}}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=0)\", \"(type='Insert', node=var0/Influencer, parent=., position=1)\", \"(type='Delete', node=var0/Influencer)\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the difference operator ('-') is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{in{-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":178775100,"targetExpr":"all i:Influencer | User-i in follows.i","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u : User, p:Photo | u -> p in sees implies (some u2:User | u->u2 in follows and u2->p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | u->i in follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all x: Influencer, y:User-x | y-> x in follows","sourceExpr":"all i:Influencer | all u:User | u->i in follows","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/User}', parent=-, position=0)\", \"(type='Insert', node=var0/Influencer, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":96404300,"targetExpr":"all x: Influencer, y:User-x | y-> x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts or p in Ad) } pred inv4 { } pred inv5 { follows in Influencer set -> set User } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/follows{set of{sig/User}}}{->{sig/Influencer}{sig/User}}}","nextExpr":"(User->Influencer - iden) in follows","sourceExpr":"follows in Influencer set -> set User","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{in{-{->{sig/User}{sig/Influencer}}{iden}}{field/follows{set of{sig/User}}}}","operations":"[\"(type='Update', node=field/follows, value=-)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Update', node=set of, value=->)\", \"(type='Insert', node=iden, parent=field/follows, position=1)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{sig/Influencer}{sig/User}}', parent=field/follows, position=0)\", \"(type='Insert', node=sig/Influencer, parent=set of, position=1)\", \"(type='Delete', node=sig/Influencer)\"]","hint":"Keep going! Instead of using field \"follows\", try using difference operator ('-') to remove elements from a set.","nextAST":"{in{-{->{sig/User}{sig/Influencer}}{iden}}{field/follows{set of{sig/User}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":41105500,"targetExpr":"(User->Influencer - iden) in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i != u => (i in u.follows && User not in i.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!={var0/Influencer}{var1/User}}{AND{!in{sig/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all i : Influencer, u: User | u != i implies i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i != u => (i in u.follows && User not in i.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Move', tree='{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='TreeDelete', tree='{!in{sig/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":44618800,"targetExpr":"all i : Influencer, u: User | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: User, u: User - Influencer | (i not in u => i in (u+i).follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!in{var0/User}{var1/User}}{in{var0/User}{.{+{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u: User, i: Influencer | u not in i implies i in u.follows","sourceExpr":"all i: User, u: User - Influencer | (i not in u => i in (u+i).follows)","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!in{var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/Influencer}', parent=one of, position=1)\", \"(type='Update', node=var1/User, value=var1/Influencer)\", \"(type='Update', node=var0/User, value=var1/Influencer)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=+)\"]","hint":"Keep going! It seems like the signature of type Influencer is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!in{var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":37146300,"targetExpr":"all u: User, i: Influencer | u not in i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i in Influencer => (i in u.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/Influencer}{sig/Influencer}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all i : Influencer, u: User | u != i implies i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i in Influencer => (i in u.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Update', node=sig/Influencer, value=var1/User)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":35060500,"targetExpr":"all i : Influencer, u: User | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i:Influencer | all u :User | i in u.follows and u!=i } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{AND{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all i : Influencer, u: User | u != i implies i in u.follows","sourceExpr":"all i: Influencer, u: User | u != i and i in u.follows","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":104278700,"targetExpr":"all i : Influencer, u: User | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i in Influencer => (i in u.follows && User not in i.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/Influencer}{sig/Influencer}}{AND{!in{sig/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i in Influencer => (i in u.follows && User not in i.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Move', tree='{!in{sig/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Move', tree='{var0/Influencer}', parent=!in, position=0)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Move', tree='{sig/User}', parent=!in, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/follows)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{in{var0/Influencer}{sig/Influencer}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":41420500,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | (some p:Ad | p in u.posts ) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer | i!=u and i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{AND{!={var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u: User, i: Influencer | u != i implies i in u.follows","sourceExpr":"all u : User | all i : Influencer | i in u.follows and u != i","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":95162800,"targetExpr":"all u: User, i: Influencer | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | (i.follows in u) && i not in User.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{AND{!in{var0/Influencer}{.{sig/User}{field/follows{set of{sig/User}}}}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | (i.follows in u) && i not in User.follows","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/Influencer}{.{sig/User}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Influencer, value=var0/Influencer)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='TreeDelete', tree='{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":47643300,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all x : Influencer | all y : (User - Influencer) | x in y.follows","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=sig/Influencer, value=var0/Influencer)\"]","hint":"One step away from the solution! Instead of using signature of type Influencer, try using variable of type Influencer to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":99974300,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1,u2:User, p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all p:Photo | some u:User | u->p in posts } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User, p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all u:User, i:Influencer | u not in i and u->i in follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{AND{!in{var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u: User, i:Influencer | u!=i => u->i in follows","sourceExpr":"all u:User, i:Influencer | u not in i and u->i in follows","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Update', node=!in, value=!=)\"]","hint":"Near a solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":37333600,"targetExpr":"all u: User, i:Influencer | u!=i => u->i in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: User, u: User - Influencer | (i in Influencer => i in (u+i).follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{+{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all disj u1,u2 : User | u1 in Influencer implies u1 in u2.follows","sourceExpr":"all i: User, u: User - Influencer | (i in Influencer => i in (u+i).follows)","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=disj, parent=all, position=0)\", \"(type='Insert', node=disj, parent=all, position=0)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=+)\"]","hint":"Keep going! Consider adding a disjoint operator ('disj') to specify that two sets are disjoint. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":40603800,"targetExpr":"all disj u1,u2 : User | u1 in Influencer implies u1 in u2.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i:Influencer | all u :User | i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all i : Influencer | all u : User | i in u.follows","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/User}', parent=-, position=0)\", \"(type='Insert', node=var0/Influencer, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":92230100,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all u: User, i: User | u in Influencer => u in i.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u:User,u2:User | u in Influencer and u != u2 implies u in u2.follows","sourceExpr":"all u1,u2 : User | u1 in Influencer implies u1 in u2.follows","predicate":"inv5","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!={var0/User}{var1/User}}{in{var0/User}{sig/Influencer}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var0/User}{sig/Influencer}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!={var0/User}{var1/User}}{in{var0/User}{sig/Influencer}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":91839900,"targetExpr":"all u:User,u2:User | u in Influencer and u != u2 implies u in u2.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - Influencer | i in Influencer => i.follows in u } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/Influencer}{sig/Influencer}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all i : Influencer, u: User | u != i implies i in u.follows","sourceExpr":"all i: Influencer, u: User - Influencer | i in Influencer => i.follows in u","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Update', node=sig/Influencer, value=var1/User)\", \"(type='Insert', node=var0/Influencer, parent=in, position=0)\", \"(type='Update', node=var0/Influencer, value=var1/User)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":40086100,"targetExpr":"all i : Influencer, u: User | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows & iden } pred inv3 { all u:User | u.sees in (u.follows.posts + Ad) } pred inv4 { all u:User | (some u.posts & Ad) implies u.posts in Ad } pred inv5 { all i: Influencer | follows.i in User } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{all{one of{var0}{sig/Influencer}}{in{.{field/follows{set of{sig/User}}}{var0/Influencer}}{sig/User}}}","nextExpr":"all i:Influencer, u:User | u in follows.i","sourceExpr":"all i : Influencer | follows.i in User","predicate":"inv5","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var1/User}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/User}}', parent=all, position=0)\", \"(type='Move', tree='{in{.{field/follows{set of{sig/User}}}{var0/Influencer}}{sig/User}}', parent=all, position=1)\", \"(type='Insert', node=var1/User, parent=in, position=0)\", \"(type='Delete', node=sig/User)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"User\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{in{var1/User}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":100985000,"targetExpr":"all x : Influencer | all y : User-x | y in follows.x","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | (i.follows in u) && i not in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{AND{!in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | (i.follows in u) && i not in u.follows","predicate":"inv5","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Influencer, value=var0/Influencer)\", \"(type='TreeDelete', tree='{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":37779100,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all u: User | u in Influencer => u.follows in (u - Influencer) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{.{var0/User}{field/follows{set of{sig/User}}}}{-{var0/User}{sig/Influencer}}}}}","nextExpr":"all u : User | u in Influencer implies User-u in follows.u","sourceExpr":"all u: User | u in Influencer => u.follows in (u - Influencer)","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{-{sig/User}{var0/User}}{.{field/follows{set of{sig/User}}}{var0/User}}}}}","operations":"[\"(type='Insert', node=-, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=sig/User, parent=-, position=0)\", \"(type='Move', tree='{var0/User}', parent=-, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=0)\", \"(type='Move', tree='{var0/User}', parent=., position=1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{-{sig/User}{var0/User}}{.{field/follows{set of{sig/User}}}{var0/User}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":38404000,"targetExpr":"all u : User | u in Influencer implies User-u in follows.u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User | i in (User-i).follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{in{var0/Influencer}{.{-{sig/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all i: Influencer, u: User | i in (User-i).follows","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/User}', parent=-, position=0)\", \"(type='Insert', node=var0/Influencer, parent=-, position=1)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Move', tree='{sig/User}', parent=., position=0)\", \"(type='Delete', node=var0/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":39713700,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows & iden } pred inv3 { all u:User | u.sees in (u.follows.posts + Ad) } pred inv4 { all u:User | (some u.posts & Ad) implies u.posts in Ad } pred inv5 { all i: Influencer | User in follows.i } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{all{one of{var0}{sig/Influencer}}{in{sig/User}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","nextExpr":"all i:Influencer | User-i in follows.i","sourceExpr":"all x: Influencer| User in follows.x","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Influencer}}{in{-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","operations":"[\"(type='Insert', node=-, parent=in, position=0)\", \"(type='Move', tree='{sig/User}', parent=-, position=0)\", \"(type='Insert', node=var0/Influencer, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{in{-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":89517800,"targetExpr":"all i:Influencer | User-i in follows.i","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all u1,u2:User, p:Photo | u1->p in posts and u2->p in posts implies u1=u2 all p:Photo | some u:User | u->p in posts } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User, p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all u:User, i:Influencer | u!=i and u->i in follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{AND{!={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u: User, i:Influencer | u!=i => u->i in follows","sourceExpr":"all u: User, i:Influencer | u!=i and u->i in follows","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{->{var0/User}{var1/Influencer}}{field/follows{set of{sig/User}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":93264500,"targetExpr":"all u: User, i:Influencer | u!=i => u->i in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one u: User | u in i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad, ua: a.~posts | ua in u => u.posts in Ad } pred inv5 { all i: Influencer | i in (Influencer - i).follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{in{var0/Influencer}{.{-{sig/Influencer}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all i:Influencer | User-i in follows.i","sourceExpr":"all i: Influencer | i in (Influencer - i).follows","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Influencer}}{in{-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","operations":"[\"(type='Move', tree='{-{sig/Influencer}{var0/Influencer}}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=sig/Influencer, value=sig/User)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=0)\", \"(type='Insert', node=var0/Influencer, parent=., position=1)\", \"(type='Delete', node=var0/Influencer)\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the difference operator ('-') is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{in{-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":35357600,"targetExpr":"all i:Influencer | User-i in follows.i","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User | i in (u-i).follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{in{var0/Influencer}{.{-{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all i : Influencer, u: User | u != i implies i in u.follows","sourceExpr":"all i : Influencer | all u : User | i in (u-i).follows","predicate":"inv5","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/Influencer}{var1/User}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Influencer}{.{-{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Delete', node=var0/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":99671200,"targetExpr":"all i : Influencer, u: User | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts => p1 in Ad) } pred inv5 { all inf : Influencer, u : User | inf != u and u -> inf in follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{AND{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all i : Influencer, u : User | u != i implies u->i in follows","sourceExpr":"all i : Influencer, u : User | u->i in follows and u != i","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":95502600,"targetExpr":"all i : Influencer, u : User | u != i implies u->i in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: User, u: User - Influencer | i in Influencer => i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all disj u1,u2:User| u1 in Influencer implies u1 in u2.follows","sourceExpr":"all i: User, u: User - Influencer | i in Influencer => i in u.follows","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=disj, parent=all, position=0)\", \"(type='Insert', node=disj, parent=all, position=0)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Consider adding a disjoint operator ('disj') to specify that two sets are disjoint. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":38045500,"targetExpr":"all disj u1,u2:User| u1 in Influencer implies u1 in u2.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one->Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User,p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p1:Photo | u->p1 in posts implies p1 in Ad) } pred inv5 { all i:Influencer,u:User | u->i in follows and u not in Influencer } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{AND{!in{var1/User}{sig/Influencer}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all i : Influencer, u : User | u != i implies u->i in follows","sourceExpr":"all i:Influencer,u:User | u->i in follows and u not in Influencer","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Update', node=!in, value=!=)\", \"(type='Insert', node=var0/Influencer, parent=!in, position=0)\", \"(type='Delete', node=sig/Influencer)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":33021500,"targetExpr":"all i : Influencer, u : User | u != i implies u->i in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | (some p:Ad | p in u.posts ) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer | u not in Influencer and i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{AND{!in{var0/User}{sig/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u: User, i: Influencer | u not in i implies i in u.follows","sourceExpr":"all u : User, i : Influencer | i in u.follows and u not in Influencer","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!in{var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Influencer, value=var1/Influencer)\"]","hint":"Near a solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!in{var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":110023900,"targetExpr":"all u: User, i: Influencer | u not in i implies i in u.follows","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows & iden } pred inv3 { all u:User | u.sees in (u.follows.posts + Ad) } pred inv4 { all u:User | (some u.posts & Ad) implies u.posts in Ad } pred inv5 { all i: Influencer | follows.i = User } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{all{one of{var0}{sig/Influencer}}{={.{field/follows{set of{sig/User}}}{var0/Influencer}}{sig/User}}}","nextExpr":"all i : Influencer | follows.i = User-{i}","sourceExpr":"all i : Influencer | follows.i = User","predicate":"inv5","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Influencer}}{={-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","operations":"[\"(type='TreeInsert', tree='{-{sig/User}{var0/Influencer}}', parent==, position=0)\", \"(type='Update', node=var0/Influencer, value=.)\", \"(type='Move', tree='{var0/Influencer}', parent==, position=1)\", \"(type='Update', node=set of, value=field/follows)\", \"(type='Move', tree='{set of{sig/User}}', parent=var0/Influencer, position=0)\", \"(type='Update', node=field/follows, value=var0/Influencer)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=var0/Influencer, position=1)\", \"(type='Update', node=sig/User, value=set of)\", \"(type='Move', tree='{sig/User}', parent=sig/User, position=0)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{={-{sig/User}{var0/Influencer}}{.{field/follows{set of{sig/User}}}{var0/Influencer}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":94049500,"targetExpr":"all i : Influencer | follows.i = User-{i}","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: User, u: User | (i not in u => i in (u).follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{!in{var0/User}{var1/User}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i: User, u: User | (i not in u => i in (u).follows)","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=sig/User, value=sig/Influencer)\", \"(type='Update', node=var0/User, value=var0/Influencer)\", \"(type='Update', node=var0/User, value=var0/Influencer)\"]","hint":"Near a solution! Instead of using signature of type User, try using signature of type Influencer to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":36478300,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i != User => (i in u.follows && u not in i.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{!={sig/User}{var0/Influencer}}{AND{!in{var1/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i != User => (i in u.follows && u not in i.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Move', tree='{!in{var1/User}{.{var0/Influencer}{field/follows{set of{sig/User}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Move', tree='{var0/Influencer}', parent=!in, position=0)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Move', tree='{sig/User}', parent=!in, position=1)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/follows)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{!={sig/User}{var0/Influencer}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!in{var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":37584100,"targetExpr":"all inf : Influencer | all x : User | inf not in x implies inf in x.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i in Influencer =>( (i.follows in u) && i not in u.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/Influencer}{sig/Influencer}}{AND{!in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}}}","nextExpr":"all i : Influencer, u: User | u != i implies i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i in Influencer =>( (i.follows in u) && i not in u.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Update', node=sig/Influencer, value=var1/User)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='TreeDelete', tree='{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":40467700,"targetExpr":"all i : Influencer, u: User | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - Influencer | i = Influencer => i.follows in u } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{={sig/Influencer}{var0/Influencer}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all i: Influencer, u: User - Influencer | i = Influencer => i.follows in u","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node==>, value=in)\", \"(type='Move', tree='{var0/Influencer}', parent==>, position=0)\", \"(type='Move', tree='{.{var0/Influencer}{field/follows{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Update', node=sig/Influencer, value=var0/Influencer)\", \"(type='Update', node=var0/Influencer, value=var1/User)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node==)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":41925600,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i.follows in u } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}","nextExpr":"all i : Influencer | all u : User-i | i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i.follows in u","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","operations":"[\"(type='Insert', node=var0/Influencer, parent=in, position=0)\", \"(type='Update', node=sig/Influencer, value=var0/Influencer)\", \"(type='Update', node=var0/Influencer, value=var1/User)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider using a variable of type Influencer to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":37752600,"targetExpr":"all i : Influencer | all u : User-i | i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u : User, p:Photo | u -> p in sees implies (some u2:User | u->u2 in follows and u2->p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | u->i in follows implies i!=u } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}{!={var0/Influencer}{var1/User}}}}}","nextExpr":"all i:Influencer | all u:User | u->i in follows","sourceExpr":"all i : Influencer, u : User | u -> i in follows implies u != i","predicate":"inv5","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Move', tree='{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{!={var0/Influencer}{var1/User}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":90764900,"targetExpr":"all x: Influencer, y:User-x | y-> x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i:Influencer, u: User - Influencer | i in Influencer =>( (i.follows in u) && i not in User.follows) } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{sig/Influencer}}}{=>{in{var0/Influencer}{sig/Influencer}}{AND{!in{var0/Influencer}{.{sig/User}{field/follows{set of{sig/User}}}}}{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}}}}}","nextExpr":"all i : Influencer, u : User | u!=i => i in u.follows","sourceExpr":"all i:Influencer, u: User - Influencer | i in Influencer =>( (i.follows in u) && i not in User.follows)","predicate":"inv5","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/Influencer}{.{sig/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Update', node=sig/Influencer, value=var1/User)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Delete', node=sig/Influencer)\", \"(type='Delete', node=-)\", \"(type='TreeDelete', tree='{in{.{var0/Influencer}{field/follows{set of{sig/User}}}}{var1/User}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type User is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/User}}{=>{!={var0/Influencer}{var1/User}}{in{var0/Influencer}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":40111900,"targetExpr":"all i : Influencer, u : User | u!=i => i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one->Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u:User,p:Photo | u->p in sees implies (some u2:User | u2->p in posts and u->u2 in follows) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p1:Photo | u->p1 in posts implies p1 in Ad) } pred inv5 { follows in User->Influencer } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{in{field/follows{set of{sig/User}}}{->{sig/User}{sig/Influencer}}}","nextExpr":"(User->Influencer - iden) in follows","sourceExpr":"follows in User->Influencer","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{in{-{->{sig/User}{sig/Influencer}}{iden}}{field/follows{set of{sig/User}}}}","operations":"[\"(type='Update', node=field/follows, value=-)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Update', node=set of, value=->)\", \"(type='Insert', node=iden, parent=field/follows, position=1)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{sig/User}{sig/Influencer}}', parent=field/follows, position=0)\", \"(type='Insert', node=sig/Influencer, parent=set of, position=1)\", \"(type='Delete', node=sig/Influencer)\"]","hint":"Keep going! Instead of using field \"follows\", try using difference operator ('-') to remove elements from a set.","nextAST":"{in{-{->{sig/User}{sig/Influencer}}{iden}}{field/follows{set of{sig/User}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":36022700,"targetExpr":"(User->Influencer - iden) in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { all disj u,i:User | Influencer in i implies i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{sig/Influencer}{var1/User}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all disj u1,u2:User| u1 in Influencer implies u1 in u2.follows","sourceExpr":"all disj u,i:User | Influencer in i implies i in u.follows","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=var0/User, parent=in, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var0/User}{sig/Influencer}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":37624000,"targetExpr":"all disj u1,u2:User| u1 in Influencer implies u1 in u2.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { all u:User,i:Influencer |i in u.follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u : User, i : Influencer | u != i implies i in u.follows","sourceExpr":"all u : User , i : Influencer | i in u.follows","predicate":"inv5","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/Influencer}}', parent==>, position=0)\", \"(type='Move', tree='{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Influencer}}{=>{!={var0/User}{var1/Influencer}}{in{var1/Influencer}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":84637200,"targetExpr":"all u : User, i : Influencer | u != i implies i in u.follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | some p1:Ad | u -> p1 in posts implies (all p2:Photo | u -> p2 in posts implies p2 in Ad) } pred inv5 { all inf:Influencer | no u:User | u -> inf not in follows } pred inv6 { } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{no{one of{var1}{sig/User}}{!in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all x: Influencer, y:User-x | y-> x in follows","sourceExpr":"all inf:Influencer | no u:User | u -> inf not in follows","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=!in, value=in)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/User}', parent=-, position=0)\", \"(type='Insert', node=var0/Influencer, parent=-, position=1)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{-{sig/User}{var0/Influencer}}}{in{->{var1/User}{var0/Influencer}}{field/follows{set of{sig/User}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":41229400,"targetExpr":"all x: Influencer, y:User-x | y-> x in follows","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i.posts in d.~date } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{.{var0/Day}{~{field/date{one of{sig/Day}}}}}}}}","nextExpr":"all d : Day, i : Influencer | d in i.posts.date","sourceExpr":"all d: Day, i: Influencer | i.posts in d.~date","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","operations":"[\"(type='Insert', node=var0/Day, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}', parent=., position=0)\", \"(type='Move', tree='{field/date{one of{sig/Day}}}', parent=., position=1)\", \"(type='Delete', node=var0/Day)\", \"(type='Delete', node=~)\", \"(type='Delete', node=.)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider using a variable of type Day to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":115210800,"targetExpr":"all d : Day, i : Influencer | d in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{={.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{var1/Day}}}}","nextExpr":"all i : Influencer, d : Day | some i.posts.date & d","sourceExpr":"all i: Influencer, d: Day | i.posts.date = d","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{&{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{var1/Day}}}}}","operations":"[\"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node==, value=&)\", \"(type='Move', tree='{={.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{var1/Day}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{&{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{var1/Day}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":35811100,"targetExpr":"all i : Influencer, d : Day | some i.posts.date & d","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts => p1 in Ad) } pred inv5 { all inf : Influencer, u : User | inf != u => u -> inf in follows } pred inv6 { all inf : Influencer, d : Day | (some p : Photo | (inf -> p in posts)) } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{one of{var2}{sig/Photo}}{in{->{var0/Influencer}{var2/Photo}}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all d : Day | all i : Influencer | (some p : Photo | i->p in posts and p in d)","sourceExpr":"all i : Influencer | all d : Day | (some p : Photo | i->p in posts)","predicate":"inv6","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{some{one of{var2}{sig/Photo}}{AND{in{->{var1/Influencer}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{->{var2/Photo}{var0/Day}}{field/date{one of{sig/Day}}}}}}}}","operations":"[\"(type='Update', node=sig/Influencer, value=sig/Day)\", \"(type='Update', node=sig/Day, value=sig/Influencer)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='Move', tree='{in{->{var0/Influencer}{var2/Photo}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var2/Photo}{var0/Day}}', parent=AND, position=1)\", \"(type='Update', node=var0/Influencer, value=var1/Influencer)\"]","hint":"Keep going! Instead of using signature of type Influencer, try using signature of type Day to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{some{one of{var2}{sig/Photo}}{AND{in{->{var1/Influencer}{var2/Photo}}{field/posts{set of{sig/Photo}}}}{in{var2/Photo}{var0/Day}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":113624800,"targetExpr":"all d: Day, x: Influencer | some y:Photo| x-> y in posts and y-> d in date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day | some d.~date.~posts } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Day}}{some{.{.{var0/Day}{~{field/date{one of{sig/Day}}}}}{~{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all d : Day | Influencer in (posts.date.d)","sourceExpr":"all d: Day | some d.~date.~posts","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Day}}{in{sig/Influencer}{.{.{field/posts{set of{sig/Photo}}}{field/date{one of{sig/Day}}}}{var0/Day}}}}","operations":"[\"(type='Update', node=some, value=in)\", \"(type='Insert', node=sig/Influencer, parent=some, position=0)\", \"(type='Update', node=sig/Photo, value=var0/Day)\", \"(type='Move', tree='{sig/Photo}', parent=., position=1)\", \"(type='Insert', node=field/posts, parent=., position=0)\", \"(type='Move', tree='{field/date{one of{sig/Day}}}', parent=., position=1)\", \"(type='Insert', node=set of, parent=field/posts, position=0)\", \"(type='Update', node=var0/Day, value=sig/Photo)\", \"(type='Move', tree='{var0/Day}', parent=set of, position=0)\", \"(type='Delete', node=~)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/posts)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Day}}{in{sig/Influencer}{.{.{field/posts{set of{sig/Photo}}}{field/date{one of{sig/Day}}}}{var0/Day}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":69542700,"targetExpr":"all d : Day | Influencer in (posts.date.d)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts or p in Ad) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer , u: User | i != u implies u -> i in follows } pred inv6 { all i:Influencer , p:Photo | i -> p in posts implies (date in Photo some-> one Day) } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Photo}}{=>{in{->{var0/Influencer}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{field/date{one of{sig/Day}}}{some->one{sig/Photo}{sig/Day}}}}}}","nextExpr":"all i : Influencer, d : Day | some i.posts & date.d","sourceExpr":"all i:Influencer , p:Photo | i -> p in posts implies (date in Photo some-> one Day)","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{&{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{.{field/date{one of{sig/Day}}}{var1/Day}}}}}}","operations":"[\"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=sig/Photo, value=sig/Day)\", \"(type='Update', node==>, value=&)\", \"(type='Move', tree='{=>{in{->{var0/Influencer}{var1/Photo}}{field/posts{set of{sig/Photo}}}}{in{field/date{one of{sig/Day}}}{some->one{sig/Photo}{sig/Day}}}}', parent=some, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{var0/Influencer}', parent=in, position=0)\", \"(type='Update', node=sig/Photo, value=var1/Day)\", \"(type='Move', tree='{sig/Photo}', parent=in, position=1)\", \"(type='Delete', node=var1/Photo)\", \"(type='Delete', node=->)\", \"(type='Delete', node=sig/Day)\", \"(type='Delete', node=some->one)\"]","hint":"Keep going! Instead of using signature of type Photo, try using signature of type Day to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{&{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{.{field/date{one of{sig/Day}}}{var1/Day}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":37530500,"targetExpr":"all i : Influencer, d : Day | some i.posts & date.d","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | all p:Photo | p in Ad and p in u.posts implies u.posts in Ad } pred inv5 { all i:Influencer, u:User | i in u.follows or i=u } pred inv6 { all i:Influencer | one d:Day | d in i.posts } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{one{one of{var1}{sig/Day}}{in{var1/Day}{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}}}}","nextExpr":"all i : Influencer | all d : Day | d in i.posts.date","sourceExpr":"all i:Influencer | one d:Day | d in i.posts","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{in{var1/Day}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/date{one of{sig/Day}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{in{var1/Day}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":32546400,"targetExpr":"all i : Influencer | all d : Day | d in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | all p:Photo | p in Ad and p in u.posts implies u.posts in Ad } pred inv5 { all i:Influencer, u:User | i in u.follows or i=u } pred inv6 { all i:Influencer, p:Photo | one d:Day | p in i.posts.date implies d in p } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Photo}}{one{one of{var2}{sig/Day}}{=>{in{var1/Photo}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}{in{var2/Day}{var1/Photo}}}}}}","nextExpr":"all i: Influencer, d: Day | d in i.posts.date","sourceExpr":"all i:Influencer, p:Photo | one d:Day | p in i.posts.date implies d in p","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{in{var1/Day}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","operations":"[\"(type='Move', tree='{in{var1/Photo}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Photo, value=sig/Day)\", \"(type='Update', node=var1/Photo, value=var1/Day)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Day}}')\", \"(type='TreeDelete', tree='{in{var2/Day}{var1/Photo}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=one)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{in{var1/Day}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":33798800,"targetExpr":"all i: Influencer, d: Day | d in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all i: Influencer | some i.posts.date } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{some{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}","nextExpr":"all i : Influencer | i.posts.date = Day","sourceExpr":"all i: Influencer | some i.posts.date","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Influencer}}{={.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{sig/Day}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=sig/Day, parent=some, position=1)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/Influencer}}{={.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{sig/Day}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":38148300,"targetExpr":"all i : Influencer | i.posts.date = Day","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day | (some i: Influencer | i.posts in d.~date) } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Day}}{some{one of{var1}{sig/Influencer}}{in{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{.{var0/Day}{~{field/date{one of{sig/Day}}}}}}}}","nextExpr":"all d : Day, i : Influencer | d in i.posts.date","sourceExpr":"all d: Day | (some i: Influencer | i.posts in d.~date)","predicate":"inv6","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=var0/Day, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}', parent=., position=0)\", \"(type='Move', tree='{field/date{one of{sig/Day}}}', parent=., position=1)\", \"(type='Delete', node=var0/Day)\", \"(type='Delete', node=~)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":40384300,"targetExpr":"all d : Day, i : Influencer | d in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows & iden } pred inv3 { all u:User | u.sees in (u.follows.posts + Ad) } pred inv4 { all u:User | (some u.posts & Ad) implies u.posts in Ad } pred inv5 { all i: Influencer | (User - i) in follows.i } pred inv6 { Day in Influencer.posts.date } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{in{sig/Day}{.{.{sig/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}","nextExpr":"all i : Influencer | Day in i.posts.date","sourceExpr":"Day in Influencer.posts.date","predicate":"inv6","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Influencer}}{in{sig/Day}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Influencer}}', parent=all, position=0)\", \"(type='Move', tree='{in{sig/Day}{.{.{sig/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Influencer, value=var0/Influencer)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Influencer\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Influencer}}{in{sig/Day}{.{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":75258800,"targetExpr":"all i : Influencer | Day in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | (some a:Ad | a in u.posts) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer-u | i in u.follows } pred inv6 { all d:Day,i:Influencer | i in posts.Photo.date } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var1/Influencer}{.{.{field/posts{set of{sig/Photo}}}{sig/Photo}}{field/date{one of{sig/Day}}}}}}}","nextExpr":"all d : Day, i : Influencer | d in i.posts.date","sourceExpr":"all d:Day,i:Influencer | i in posts.Photo.date","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","operations":"[\"(type='Update', node=var1/Influencer, value=var0/Day)\", \"(type='Insert', node=var1/Influencer, parent=., position=0)\", \"(type='Delete', node=sig/Photo)\"]","hint":"Near a solution! Instead of using variable of type Influencer, try using variable of type Day to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":37472100,"targetExpr":"all d : Day, i : Influencer | d in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p in u.follows.posts } pred inv4 { } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i.posts.date in d } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}{var0/Day}}}}","nextExpr":"all d : Day, i : Influencer | d in i.posts.date","sourceExpr":"all d : Day, i : Influencer | i.posts.date in d","predicate":"inv6","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","operations":"[\"(type='Insert', node=var0/Day, parent=in, position=0)\", \"(type='Delete', node=var0/Day)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Day to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Day}}{all{one of{var1}{sig/Influencer}}{in{var0/Day}{.{.{var1/Influencer}{field/posts{set of{sig/Photo}}}}{field/date{one of{sig/Day}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":67914900,"targetExpr":"all d : Day, i : Influencer | d in i.posts.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:Photo | p in u.sees implies (p not in Ad and p in u.follows.posts) or (p in Ad) } pred inv4 { all u:User | all p:Photo | p in Ad and p in u.posts implies u.posts in Ad } pred inv5 { all i:Influencer, u:User | i in u.follows or i=u } pred inv6 { all i:Influencer, p:Photo | one d:Day | p in i.posts implies d in p } pred inv7 { } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Photo}}{one{one of{var2}{sig/Day}}{=>{in{var1/Photo}{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}}{in{var2/Day}{var1/Photo}}}}}}","nextExpr":"all i : Influencer, d : Day | some p : Photo | p in i.posts and d in p.date","sourceExpr":"all i:Influencer, p:Photo | one d:Day | p in i.posts implies d in p","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{one of{var2}{sig/Photo}}{AND{in{var2/Photo}{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}}{in{var1/Day}{.{var2/Photo}{field/date{one of{sig/Day}}}}}}}}}","operations":"[\"(type='Update', node=one, value=some)\", \"(type='Update', node=sig/Photo, value=sig/Day)\", \"(type='Update', node==>, value=AND)\", \"(type='Update', node=sig/Day, value=sig/Photo)\", \"(type='Update', node=var1/Photo, value=var2/Photo)\", \"(type='Update', node=var2/Day, value=var1/Day)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=var1/Photo, value=var2/Photo)\", \"(type='Move', tree='{var1/Photo}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/date{one of{sig/Day}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Influencer}}{all{one of{var1}{sig/Day}}{some{one of{var2}{sig/Photo}}{AND{in{var2/Photo}{.{var0/Influencer}{field/posts{set of{sig/Photo}}}}}{in{var1/Day}{.{var2/Photo}{field/date{one of{sig/Day}}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":34899000,"targetExpr":"all i : Influencer, d : Day | some p : Photo | p in i.posts and d in p.date","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj e,s,o: User | (e in s && s in o && e not in o) => o in e.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{disj}{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{var2/User}}{in{var0/User}{var1/User}}{in{var1/User}{var2/User}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e,s,o: User | (e in s && s in o && e not in o) => o in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":23,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Update', node=AND, value=-)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=AND, position=0)\", \"(type='Insert', node=+, parent=AND, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/User}{var2/User}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var0/User}{var1/User}}', parent=+, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=+, position=1)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var2/User, value=sig/User)\", \"(type='Move', tree='{var2/User}', parent=set of, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":23,"challenge":"dkZH6HJNQNLLDX6Aj","time":128788200,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested = u2 - u1 } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{={-{var1/User}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested = u2 - u1","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node==, value=in)\", \"(type='Move', tree='{var1/User}', parent==, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":75441300,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows => u1.suggested = (u2.follows - u1.follows) } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{={-{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u1,u2: User | u2 in u1.follows => u1.suggested = (u2.follows - u1.follows)","predicate":"inv7","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=-)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":52294500,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | (some p:Ad | p in u.posts ) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer | i!=u implies i in u.follows } pred inv6 { all d:Day,i:Influencer | d in i.posts.date } pred inv7 { all u1,u2:User | u2 in u1.suggested implies (some u3:User | u2 not in u1.follows and u1!=u2 and u2 in u3.follows and u3 in u1.follows) } pred inv8 { all u:User,a:Ad | a in u.sees }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all s:User | all u:User | s in u.suggested iff some u1:User | u!=s and s in u1.follows and u1 in u.follows and s not in u.follows","sourceExpr":"all x,x1:User | x1 in x.suggested implies some x3:User | x1 in x3.follows and x3 in x.follows and x1 not in x.follows and x1!=x","predicate":"inv7","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var1/User)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":186875700,"targetExpr":"all s:User | all u:User | s in u.suggested iff some u1:User | u!=s and s in u1.follows and u1 in u.follows and s not in u.follows","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u,s:User | u -> s in suggested implies ((some f:User | u -> f in follows and f -> s in follows) and u -> s not in follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all u1, u3: User | (some u2: User | u1->u2 in follows and u2->u3 in follows and not (u1->u3 in follows) and u1 != u3) <=> u1->u3 in suggested","sourceExpr":"all u, s : User | u->s in suggested => u->s not in follows && some f : User | u->f in follows && f->s in follows","predicate":"inv7","isNewNode":false,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{!={var0/User}{var1/User}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}', parent=some, position=1)\", \"(type='Insert', node=!, parent=AND, position=0)\", \"(type='Update', node=one of, value=!=)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=3)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=!, position=0)\", \"(type='Update', node=var2, value=var0/User)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{!={var0/User}{var1/User}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":87910400,"targetExpr":"all u1, u3: User | (some u2: User | u1->u2 in follows and u2->u3 in follows and not (u1->u3 in follows) and u1 != u3) <=> u1->u3 in suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts => p1 in Ad) } pred inv5 { all inf : Influencer, u : User | inf != u => u -> inf in follows } pred inv6 { all inf : Influencer, d : Day | (some p : Photo | (inf -> p in posts and p->d in date)) } pred inv7 { all u1, u2 : User | u1 -> u2 in suggested implies (some u3 : User | u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","sourceExpr":"all u1, u2 : User | u1 -> u2 in suggested implies (some u3 : User | u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2)","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='TreeInsert', tree='{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=2)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":65601600,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all a,b : User | a in b.follows.follows && a not in b.follows implies a in b.suggested","sourceExpr":"all disj u,uu:User | u in uu.follows.follows && u not in uu.follows implies u in uu.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the disjoint operator ('disj'). If you want to keep it, try to fix your expression another way and reach a different solution!","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":122812600,"targetExpr":"all u1,u2:User | (u1!=u2 and u1 in u2.follows.follows and u1 not in u2.follows) <=> (u1 in u2.suggested)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | s in o.follows && s not in e.follows=> s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e: User, o: User, s: User | s in o.follows && s not in e.follows=> s in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Update', node=AND, value=-)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Update', node=in, value=+)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=!in, position=2)\", \"(type='Insert', node=var0/User, parent=in, position=2)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":53030000,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | (some a:Ad | a in u.posts) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer-u | i in u.follows } pred inv6 { all d:Day,i:Influencer | i in posts.(date.d) } pred inv7 { all u1:User,u2:User-u1,u3:User-u1-u2 | u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows implies u3 not in u1.follows } pred inv8 { all u1,u2:User, a:Ad | a in u2.posts and u1 in sees.a implies u2 in (u1.follows+u1.suggested) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{var0/User}}}{all{one of{var2}{-{-{sig/User}{var0/User}}{var1/User}}}{=>{AND{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all u1:User,u2:User-u1,u3:User-u1-u2 | u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows implies u3 not in u1.follows","predicate":"inv7","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Move', tree='{one of{var2}{-{-{sig/User}{var0/User}}{var1/User}}}', parent=some, position=0)\", \"(type='Move', tree='{AND{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":61199600,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj e,s,o: User | (s in e.follows && o in s.follows && o not in e.follows) => o in e.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{disj}{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all disj u1, u2, u3 : User | u2 in u1.follows and u3 in u2.follows and u3 not in u1.follows implies (u3 in u1.suggested)","predicate":"inv7","isNewNode":false,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Insert', node=!=, parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=disj, value=var0/User)\", \"(type='Move', tree='{disj}', parent=!=, position=0)\", \"(type='Insert', node=var1/User, parent=!=, position=1)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":141612300,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows && u2.follows != u1.follows => u2.follows in u1.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!={.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","sourceExpr":"all disj u1,u2: User | u2 in u1.follows && u2.follows != u1.follows => u2.follows in u1.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Insert', node=!in, parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Move', tree='{var1/User}', parent=in, position=0)\", \"(type='Insert', node=var1/User, parent=!in, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Insert', node=one of, parent=some, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=some, position=1)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Insert', node=var2, parent=one of, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=one of, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=!=)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":54086600,"targetExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u,s:User | u -> s in suggested iff (some f:User | u -> f in follows and f -> s in follows and u -> s not in follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","sourceExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows)","predicate":"inv7","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\"]","hint":"Near a solution! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":110453200,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u-> p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | i != u implies u -> i in follows } pred inv6 { all i:Influencer, d:Day | some p:Photo | i -> p in posts and p-> d in date } pred inv7 { all u1:User, u2:User | u1 -> u2 not in follows implies u1 -> u2 in suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all u1:User, u2:User | u1 -> u2 not in follows implies u1 -> u2 in suggested","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Insert', node=., parent==>, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Move', tree='{field/suggested{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Update', node=->, value=.)\", \"(type='Move', tree='{->{var0/User}{var1/User}}', parent=-, position=1)\", \"(type='Update', node=->, value=.)\", \"(type='Insert', node=field/follows, parent=->, position=1)\", \"(type='Insert', node=field/follows, parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":46959100,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all u: User | u.suggested = (u.follows.follows - u.follows) - u.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","nextExpr":"all u : User | u.suggested = u.follows.follows - u.follows - u.iden","sourceExpr":"all u: User | u.suggested = (u.follows.follows - u.follows) - u.follows","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{iden}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=sig/User, value=iden)\", \"(type='Move', tree='{sig/User}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/follows)\"]","hint":"Near a solution! Instead of using signature of type User, try using identity relation constructor ('iden') to specifies the identity relation.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{iden}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":51295000,"targetExpr":"all u : User | u.suggested = u.follows.follows - u.follows - u.iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User | some f: u.follows.follows | uu not in u.follows && uu in f => uu in u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{some{one of{var2}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u,uu: User | some f: u.follows.follows | uu not in u.follows && uu in f => uu in u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=-, parent=some, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=some, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":55296900,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all u: User | u.suggested = (u.follows.follows) - u.follows } pred inv8 { all u: User, a: Ad | (u in a.~sees) => (a in u.follows.posts or a in u.suggested.posts) }","sourceAST":"{all{one of{var0}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","nextExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","sourceExpr":"all u : User | u.suggested = (u.follows.follows - u.follows)","predicate":"inv7","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Insert', node=-, parent==, position=0)\", \"(type='Move', tree='{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":114369900,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj u,o: User | (o in u.follows.follows && o not in u.follows) => o in u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u : User, u2 : User | u2 not in u.follows && u2 in u.follows.follows => u2 in u.suggested","sourceExpr":"all disj u,u2 : User | u2 in u.follows.follows and u2 not in u.follows => u2 in u.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the disjoint operator ('disj'). If you want to keep it, try to fix your expression another way and reach a different solution!","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":106626400,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | (e in o.follows && s in o.follows && s not in e.follows) => s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all disj e: User, o: User, s: User | (e in o.follows && s in o.follows && s not in e.follows) => s in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var1/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":60439100,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.suggested => u2 in u1.follows.follows && u2 not in u1.follows } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","sourceExpr":"all disj u1, u2 : User | u2 in u1.suggested implies u2 not in u1.follows and u2 in u1.follows.follows","predicate":"inv7","isNewNode":false,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=2)\", \"(type='Update', node==>, value=AND)\", \"(type='Move', tree='{=>{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}', parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=<=>, position=1)\", \"(type='Update', node=., value=!=)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=0)\", \"(type='Move', tree='{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}', parent==>, position=2)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Move', tree='{sig/User}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/suggested)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":159266000,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all u: User, s: User | s in u.follows.follows && s not in u.follows && s != u => s = u.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","sourceExpr":"all u: User, s: User | s in u.follows.follows && s not in u.follows && s != u => s = u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var1/User, parent==, position=0)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":61011300,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 = u1.suggested => u2 in u1.follows.follows && u2 not in u1.follows } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","sourceExpr":"all disj u1,u2: User | u2 = u1.suggested => u2 in u1.follows.follows && u2 not in u1.follows","predicate":"inv7","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=2)\", \"(type='Update', node==>, value=AND)\", \"(type='Move', tree='{=>{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}', parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=<=>, position=1)\", \"(type='Update', node==, value=!=)\", \"(type='Move', tree='{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}', parent==>, position=2)\", \"(type='Move', tree='{var0/User}', parent==, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='TreeDelete', tree='{field/suggested{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":53037100,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | (some a:Ad | a in u.posts) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer-u | i in u.follows } pred inv6 { all d:Day,i:Influencer | i in posts.(date.d) } pred inv7 { all u1,u2,u3:User | u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows implies u3 not in u1.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all u1: User, u2: User, u3: User | u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows implies u3 not in u1.follows","predicate":"inv7","isNewNode":false,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":69858400,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User | some f: u.follows.follows | uu not in u.follows && uu in f => uu = u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{some{one of{var2}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u,uu: User | some f: u.follows.follows | uu not in u.follows && uu in f => uu = u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=-, parent=some, position=0)\", \"(type='Update', node=field/suggested, value=.)\", \"(type='Move', tree='{field/suggested{set of{sig/User}}}', parent=some, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=field/suggested, position=0)\", \"(type='Update', node=set of, value=field/suggested)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Update', node=sig/User, value=set of)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Move', tree='{var0/User}', parent=sig/User, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=.)\", \"(type='Delete', node==)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":61449500,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts or p in Ad) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer , u: User | i != u implies u -> i in follows } pred inv6 { all i:Influencer , d:Day | some p:Photo | i -> p in posts and p -> d in date } pred inv7 { all u1, u2:User | u1 -> u2 in suggested implies (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2 and u2 != u3) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!={var1/User}{var2/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","sourceExpr":"all u1, u2:User | u1 -> u2 in suggested implies (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2 and u2 != u3)","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='TreeDelete', tree='{!={var2/User}{var1/User}}')\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":54975600,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested = u2 } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested = u2","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var1/User, parent==, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":53437800,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | all dif: u2.follows - u1.follows | u2 in u1.follows => u1 = dif } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{one of{var2}{-{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{={var0/User}{var2/User}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u1,u2: User | all dif: u2.follows - u1.follows | u2 in u1.follows => u1 = dif","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=all, value==)\", \"(type='Update', node=one of, value=-)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=all, position=1)\", \"(type='Insert', node=var0/User, parent=one of, position=2)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{={var0/User}{var2/User}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":49467500,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj e,s,o: User | (s in e.follows && o in s.follows && o not in e.follows) => (o in e.suggested && e not in e.suggested) } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{disj}{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{AND{!in{var0/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all disj e,s,o: User | (s in e.follows && o in s.follows && o not in e.follows) => (o in e.suggested && e not in e.suggested)","predicate":"inv7","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Insert', node=!=, parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=disj, value=var0/User)\", \"(type='Move', tree='{disj}', parent=!=, position=0)\", \"(type='Insert', node=var1/User, parent=!=, position=1)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='TreeDelete', tree='{!in{var0/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":60888600,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User | some f: u.follows.follows - u | uu not in u.follows && uu in f => uu in u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{some{one of{var2}{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u,uu: User | some f: u.follows.follows - u | uu not in u.follows && uu in f => uu in u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=-, parent=some, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=some, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":60160100,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested = ((u1.follows).(follows)) - u1.follows } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested = ((u1.follows).(follows)) - u1.follows","predicate":"inv7","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node==, value=in)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Move', tree='{var0/User}', parent==, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{.{var0/User}{field/follows{set of{sig/User}}}}')\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":63336100,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p in u.posts } pred inv2 { all u : User | u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u : User, a : Ad | a in u.posts => u.posts in Ad } pred inv5 { all i : Influencer, u : User | u!=i => i in u.follows } pred inv6 { all i : Influencer, d : Day | d in i.posts.date } pred inv7 { all u: User | u.suggested in u.follows.follows and u.suggested not in u.follows } pred inv8 { all a : Ad, u : User | a in u.sees => a in u.follows.posts or a in u.suggested.posts }","sourceAST":"{all{one of{var0}{sig/User}}{AND{!in{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{.{var0/User}{field/suggested{set of{sig/User}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","sourceExpr":"all x : User | (x.suggested in x.follows.follows) && (x.suggested not in x.follows)","predicate":"inv7","isNewNode":false,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=AND, value==)\", \"(type='Insert', node=-, parent=AND, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=AND, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=!in, position=1)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":128890500,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all u: User, s: User | s in u.follows.follows && s not in u.follows => s in u.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1,u2 : User | (u1 != u2 and u2 in u1.follows.follows and u2 not in u1.follows) implies u2 in u1.suggested","sourceExpr":"all disj u : User, u2 : User | u2 not in u.follows && u2 in u.follows.follows => u2 in u.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\"]","hint":"Keep going! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":102316900,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i:Influencer | all u :User | u!= i => i in u.follows } pred inv6 { all i:Influencer | all d:Day | d in i.posts.date } pred inv7 { all disj u,u2:User | u2 in u.follows implies u2.follows.follows in u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all disj u,u2:User | u2 in u.follows implies u2.follows.follows in u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=0)\", \"(type='Insert', node=in, parent=AND, position=1)\", \"(type='Insert', node=var1/User, parent=in, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=in, position=1)\", \"(type='Insert', node=+, parent=in, position=1)\", \"(type='Insert', node=var1/User, parent=in, position=0)\", \"(type='Move', tree='{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":51019000,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u->u not in follows } pred inv3 { all u : User, p:Photo | u -> p in sees implies (some u2:User | u->u2 in follows and u2->p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | i!=u implies u->i in follows } pred inv6 { all d:Day, i:Influencer | some p:Photo | i->p in posts and p->d in date } pred inv7 { all u1,u2: User | u1->u2 in suggested implies (some u3:User | u1->u3 in follows and u3->u2 in follows and u1->u2 not in follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u, v : User | u->v in suggested iff (some z : User | u->z in follows and z->v in follows and u->v not in follows)","sourceExpr":"all u : User | (all s : User | u->s in suggested implies (some u1 : User | u->u1 in follows and u1->s in follows and u->s not in follows))","predicate":"inv7","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":4,"challenge":"dkZH6HJNQNLLDX6Aj","time":117384700,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj e,s,o: User | (e in s.follows && s in o.follows && e not in o.follows) => o in e.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{disj}{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all disj e,s,o: User | (e in s.follows && s in o.follows && e not in o.follows) => o in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Insert', node=!=, parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=disj, value=var0/User)\", \"(type='Move', tree='{disj}', parent=!=, position=0)\", \"(type='Insert', node=var1/User, parent=!=, position=1)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{var0/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Update', node=var1/User, value=var2/User)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Update', node=var1/User, value=var2/User)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":56204600,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all u: User, s: User - u | u in s.follows => u in s.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{var0/User}}}{=>{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all u: User, s: User - u | u in s.follows => u in s.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Move', tree='{.{var1/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Update', node=in, value=-)\", \"(type='Move', tree='{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Move', tree='{var0/User}', parent=-, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":55388700,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all u1: User, u2: User - u1 | u2 in u1.follows.follows && u2 not in u1.follows => (u2) in u1.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{var0/User}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all u : User, p : User - u | p in u.follows.follows and p not in u.follows implies p in u.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":143623100,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { all u:User | u-> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (( some u2:User | u->u2 in follows and u2->p in posts)) } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts) } pred inv5{ all i:Influencer, u:User | i != u implies u -> i in follows } pred inv6 { all i:Influencer, d:Day | some p:Photo | i -> p in posts and p -> d in date } pred inv7 { all u1,u2 : User | u1->u2 in suggested implies (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1->u2 not in follows and u1!=u2) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","sourceExpr":"all u1, u3 : User | u1->u3 in suggested => (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":100064900,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all u: User | u.suggested = (u.follows.follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all u : User | u.suggested = (u.follows.follows - u.follows)","sourceExpr":"all u : User | u.suggested = u.follows.follows","predicate":"inv7","isNewNode":false,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Insert', node=-, parent==, position=0)\", \"(type='Insert', node=., parent==, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Update', node=var0/User, value=.)\", \"(type='Move', tree='{var0/User}', parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Move', tree='{field/suggested{set of{sig/User}}}', parent=., position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=sig/User, value=var0/User)\", \"(type='Move', tree='{sig/User}', parent=var0/User, position=0)\", \"(type='Update', node=., value=field/follows)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=var0/User, position=1)\", \"(type='Update', node=field/follows, value=set of)\", \"(type='Update', node=set of, value=sig/User)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{all{one of{var0}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":114222400,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i:Influencer | all u :User | u!= i => i in u.follows } pred inv6 { all i:Influencer | all d:Day | d in i.posts.date } pred inv7 { all disj u,u2:User |all sug:u.suggested | u2 in u.follows => u2.follows.follows in sug } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{one of{var2}{.{var0/User}{field/suggested{set of{sig/User}}}}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var2/User}}}}}}","nextExpr":"all x, z : User | x in suggested.z iff z in (x.follows.follows - x.follows - x)","sourceExpr":"all disj u,u2:User |all sug:u.suggested | u2 in u.follows => u2.follows.follows in sug","predicate":"inv7","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{var0/User}{.{field/suggested{set of{sig/User}}}{var1/User}}}{in{var1/User}{-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node==>, value=in)\", \"(type='Update', node=var2, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent==>, position=0)\", \"(type='Insert', node=-, parent==>, position=1)\", \"(type='Insert', node=var1/User, parent=., position=2)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Move', tree='{var2/User}', parent=-, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Insert', node=., parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{var0/User}{.{field/suggested{set of{sig/User}}}{var1/User}}}{in{var1/User}{-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}}}}}","totalTED":19,"challenge":"dkZH6HJNQNLLDX6Aj","time":65532300,"targetExpr":"all x, z : User | x in suggested.z iff z in (x.follows.follows - x.follows - x)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts => p1 in Ad) } pred inv5 { all inf : Influencer, u : User | inf != u => u -> inf in follows } pred inv6 { all inf : Influencer, d : Day | (some p : Photo | (inf -> p in posts and p->d in date)) } pred inv7 { all u1, u2 : User | u1 -> u2 in suggested implies (all u3 : User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{all{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","sourceExpr":"all u1, u2 : User | u1 -> u2 in suggested implies (all u3 : User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2)","predicate":"inv7","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=all, value=some)\"]","hint":"Near a solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":56713400,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | (o in e.follows && s in o.follows && s not in e.follows) => s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all u, f, s: User | (f in u.follows and s in f.follows and s not in u.follows) implies s in u.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":240990800,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p in u.posts } pred inv2 { no u : User | u in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees implies p in u.follows.posts or p in Ad } pred inv4 { } pred inv5 { all i : Influencer, u : User - i | i in u.follows } pred inv6 { all i : Influencer, d : Day | some p : i.posts | p.date = d } pred inv7 { all u: User | u.suggested = { ffu: u.follows & u.follows.follows | ffu not in u.follows and ffu != u } } pred inv8 { all u: User | all p: u.follows.posts | (Ad in p implies (Ad in u.sees or Ad in u.suggested.posts)) }","sourceAST":"{all{one of{var0}{sig/User}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{comprehension{one of{var1}{&{.{var0/User}{field/follows{set of{sig/User}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","sourceExpr":"all u: User | u.suggested = { ffu: u.follows & u.follows.follows | ffu not in u.follows and ffu != u }","predicate":"inv7","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Insert', node=-, parent==, position=0)\", \"(type='Update', node=sig/User, value=.)\", \"(type='Move', tree='{sig/User}', parent==, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=sig/User, value=var0/User)\", \"(type='Move', tree='{sig/User}', parent=-, position=1)\", \"(type='Update', node=!in, value=var0/User)\", \"(type='Move', tree='{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=sig/User, position=0)\", \"(type='Update', node=var0/User, value=field/suggested)\", \"(type='Move', tree='{var0/User}', parent=sig/User, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Update', node=&, value=.)\", \"(type='Move', tree='{&{.{var0/User}{field/follows{set of{sig/User}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}', parent=-, position=1)\", \"(type='Update', node=comprehension, value=set of)\", \"(type='Move', tree='{comprehension{one of{var1}{&{.{var0/User}{field/follows{set of{sig/User}}}}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}', parent=var0/User, position=0)\", \"(type='Update', node=field/follows, value=.)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=sig/User, value=var0/User)\", \"(type='Move', tree='{sig/User}', parent=&, position=0)\", \"(type='Update', node=., value=field/follows)\", \"(type='Update', node=AND, value=sig/User)\", \"(type='Update', node=var1, value=var0/User)\", \"(type='Move', tree='{var1}', parent=field/follows, position=0)\", \"(type='Update', node=set of, value=field/follows)\", \"(type='Update', node=field/follows, value=set of)\", \"(type='Update', node=sig/User, value=set of)\", \"(type='Update', node=set of, value=sig/User)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Move', tree='{var0/User}', parent=sig/User, position=0)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/follows)\", \"(type='Delete', node=.)\", \"(type='Delete', node=one of)\", \"(type='TreeDelete', tree='{!={var0/User}{var1/User}}')\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/suggested)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":54497100,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u,s:User | u -> s in suggested implies (some f:User | u -> f in follows and f -> s in follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all u : User | (all s : User | u->s in suggested implies (some u1 : User | u->u1 in follows and u1->s in follows and u->s not in follows))","sourceExpr":"all u1,u3:User | u1->u3 in suggested implies (some u2:User | u1->u2 in follows and u2->u3 in follows)","predicate":"inv7","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","operations":"[\"(type='TreeInsert', tree='{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=AND, position=0)\"]","hint":"Keep going! Consider adding a exclusion operator ('!in') to specify that some element(s) do not belong to a set. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}}}","totalTED":11,"challenge":"dkZH6HJNQNLLDX6Aj","time":101572600,"targetExpr":"all u1,u3:User | u1->u3 in suggested iff (some u2:User | u1->u2 in follows and u2->u3 in follows and u1->u3 not in follows and u1!=u3)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u-> p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | i != u implies u -> i in follows } pred inv6 { all i:Influencer, d:Day | some p:Photo | i -> p in posts and p-> d in date } pred inv7 { all u1:User | some u2:User | u1 -> u2 not in follows implies u1 -> u2 in suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/User}}{=>{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all u1:User | some u2:User | u1 -> u2 not in follows implies u1 -> u2 in suggested","predicate":"inv7","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node==>, value==)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Insert', node=., parent==>, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Move', tree='{field/suggested{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Update', node=->, value=.)\", \"(type='Move', tree='{->{var0/User}{var1/User}}', parent=-, position=1)\", \"(type='Update', node=->, value=.)\", \"(type='Insert', node=field/follows, parent=->, position=1)\", \"(type='Insert', node=field/follows, parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":53656700,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all e,s,o: User | (e in s.follows && s in o.follows && e not in o.follows) => o in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","sourceExpr":"all u1, u2, u3 : User | u1 in u2.follows and u2 in u3.follows and u1 not in u3.follows implies u3 in u1.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Move', tree='{=>{AND{!in{var0/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}', parent=all, position=1)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Update', node=in, value=one of)\", \"(type='Move', tree='{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=some, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}', parent=some, position=1)\", \"(type='Move', tree='{.{var2/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Update', node=var0/User, value=var2)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='TreeDelete', tree='{one of{var2}{sig/User}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":161019700,"targetExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | all dif: u1.follows - u2.follows| u2 in u1.follows => u1.suggested in dif } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{one of{var2}{-{.{var0/User}{field/follows{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{.{var0/User}{field/suggested{set of{sig/User}}}}{var2/User}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj u1,u2: User | all dif: u1.follows - u2.follows| u2 in u1.follows => u1.suggested in dif","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node==, parent=all, position=1)\", \"(type='Move', tree='{var2}', parent=one of, position=0)\", \"(type='Insert', node=sig/User, parent=one of, position=1)\", \"(type='Insert', node=-, parent==, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==, position=1)\", \"(type='Update', node=-, value=.)\", \"(type='Move', tree='{-{.{var0/User}{field/follows{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Update', node=in, value=+)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=in, position=2)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":55096400,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all u: User | u.suggested = (u.follows.follows).follows } pred inv8 { all u: User, a: Ad | (u in a.~sees) => (a in u.follows.posts or a in u.suggested.posts) }","sourceAST":"{all{one of{var0}{sig/User}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{.{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}","nextExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","sourceExpr":"all u: User | u.suggested = (u.follows.follows).follows","predicate":"inv7","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Insert', node=-, parent==, position=0)\", \"(type='Insert', node=., parent==, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Move', tree='{field/suggested{set of{sig/User}}}', parent=., position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Insert', node=., parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='Update', node=., value=field/follows)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=., position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Update', node=., value=field/follows)\", \"(type='Move', tree='{.{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=., position=1)\", \"(type='Update', node=field/follows, value=set of)\", \"(type='Update', node=field/follows, value=set of)\", \"(type='Update', node=set of, value=sig/User)\", \"(type='Update', node=set of, value=sig/User)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":51858000,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all e,s,o: User | (e in s && s in o && e not in o) => o in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{var2/User}}{in{var0/User}{var1/User}}{in{var1/User}{var2/User}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all e,s,o: User | (e in s && s in o && e not in o) => o in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Update', node=AND, value=-)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=AND, position=0)\", \"(type='Insert', node=+, parent=AND, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/User}{var2/User}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var0/User}{var1/User}}', parent=+, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=+, position=1)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var2/User, value=sig/User)\", \"(type='Move', tree='{var2/User}', parent=set of, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":51524800,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no follows & iden } pred inv3 { all u:User | u.sees in (u.follows.posts + Ad) } pred inv4 { all u:User | (some u.posts & Ad) implies u.posts in Ad } pred inv5 { all i: Influencer | (User - i) in follows.i } pred inv6 { all i:Influencer | Day in i.posts.date } pred inv7 { all u:User | u.suggested in (u.follows).follows - u.follows } pred inv8 { all a:Ad,u:User | u -> a in sees implies (some p:User | p -> a in posts and (u -> p in follows or u -> p in suggested)) }","sourceAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/suggested{set of{sig/User}}}}{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u: User | u.suggested in u.follows.follows - u.follows - u","sourceExpr":"all u: User | u.suggested in (u.follows.follows - u.follows)","predicate":"inv7","isNewNode":false,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Insert', node=-, parent=in, position=1)\", \"(type='Move', tree='{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{in{.{var0/User}{field/suggested{set of{sig/User}}}}{-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}}}","totalTED":13,"challenge":"dkZH6HJNQNLLDX6Aj","time":115116800,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User | some f: u.follows.follows | uu in u.suggested => uu not in u.follows && uu in f } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{some{one of{var2}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}{=>{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u,uu: User | some f: u.follows.follows | uu in u.suggested => uu not in u.follows && uu in f","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=-, parent=some, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=some, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=!in)\", \"(type='TreeDelete', tree='{in{var1/User}{var2/User}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":52587200,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { all disj u,i:User | i in Influencer implies i in u.follows } pred inv6 { all i:Influencer,d:Day | d in i.posts.date } pred inv7 { all u:User,s:u.suggested-u.follows | s in u.follows.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u : User | u.follows.follows - u - u.follows = u.suggested","sourceExpr":"all u:User,s:u.suggested-u.follows | s in u.follows.follows","predicate":"inv7","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=all, value==)\", \"(type='Insert', node=-, parent=all, position=0)\", \"(type='Insert', node=., parent=all, position=1)\", \"(type='Move', tree='{-{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":46623100,"targetExpr":"all u : User | u.follows.follows - u - u.follows = u.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all u: User, s: User | s in u.follows.follows && s not in u.follows && s != u => s in u.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","sourceExpr":"all u1,u2 : User | (u1 != u2 and u2 in u1.follows.follows and u2 not in u1.follows) implies u2 in u1.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":107467600,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj u,o: User | (o in u.follows.follows && o not in u.follows && u not in u.follows) => o in u.suggested } pred inv8 { all u: User, a: Ad | (u in a.~sees) => (a in u.follows.posts or a in u.suggested.posts) }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{!in{var0/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u: User, y: User| y in u.suggested iff y not in u.follows && y in u.follows.follows && u not in y","sourceExpr":"all disj u,o: User | (o in u.follows.follows && o not in u.follows && u not in u.follows) => o in u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{!in{var0/User}{var1/User}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Move', tree='{var0/User}', parent=!in, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{!in{var0/User}{var1/User}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":58821700,"targetExpr":"all u: User, y: User| y in u.suggested iff y not in u.follows && y in u.follows.follows && u not in y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | (e in s && s in o && e not in o) => e in o.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{var1/User}}{in{var0/User}{var2/User}}{in{var2/User}{var1/User}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e: User, o: User, s: User | (e in s && s in o && e not in o) => e in o.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Move', tree='{.{var1/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Insert', node=+, parent=-, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/User}{var1/User}}', parent=., position=0)\", \"(type='Insert', node=field/follows, parent=., position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var2/User}{var1/User}}', parent=+, position=0)\", \"(type='Move', tree='{var0/User}', parent=+, position=1)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Update', node=in, value=set of)\", \"(type='Move', tree='{in{var0/User}{var2/User}}', parent=field/follows, position=0)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":53431700,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User, f: u.follows.follows - u | uu not in u.follows && uu in f => uu in u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{one of{var2}{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj u,uu: User, f: u.follows.follows - u | uu not in u.follows && uu in f => uu in u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node==, parent=all, position=1)\", \"(type='Move', tree='{var2}', parent=one of, position=0)\", \"(type='Insert', node=sig/User, parent=one of, position=1)\", \"(type='Insert', node=-, parent==, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==, position=1)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Update', node=AND, value=+)\", \"(type='Move', tree='{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}', parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=AND, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=AND, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":64799000,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows && u2.follows not in u1.follows => u1.suggested in u2.follows } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u1,u2: User | u2 in u1.follows && u2.follows not in u1.follows => u1.suggested in u2.follows","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Update', node=AND, value=-)\", \"(type='Move', tree='{AND{!in{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}', parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=AND, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=!in, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{.{var1/User}{field/follows{set of{sig/User}}}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":61429200,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u1 not in u2 && u2 in u1.follows.follows && u2 not in u1.follows => u2 = u1.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all u1, u2: User | u1 not in u2 and u2 in u1.follows.follows and u2 not in u1.follows iff u2 in u1.suggested","sourceExpr":"all disj u1,u2: User | u1 not in u2 && u2 in u1.follows.follows && u2 not in u1.follows => u2 = u1.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var1/User, parent==, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":6,"challenge":"dkZH6HJNQNLLDX6Aj","time":53340400,"targetExpr":"all u1, u2: User | u1 not in u2 and u2 in u1.follows.follows and u2 not in u1.follows iff u2 in u1.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | (some p:Ad | p in u.posts ) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer | i!=u implies i in u.follows } pred inv6 { all d:Day,i:Influencer | d in i.posts.date } pred inv7 { all u1,u2,u3:User | u3 not in u1.follows and u3 in u2.follows and u2 in u1.follows implies u3 in u1.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all user1, user2, user3: User | user3 not in user1.follows and (user3 in user2.follows and user2 in user1.follows) implies user3 in user1.suggested","predicate":"inv7","isNewNode":false,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Move', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Move', tree='{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}', parent=some, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var1/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var2/User)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":157735300,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e,s,o: User | (e in s && s in o && e not in o) => e in o.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{disj}{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{var2/User}}{in{var0/User}{var1/User}}{in{var1/User}{var2/User}}}{in{var0/User}{.{var2/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e,s,o: User | (e in s && s in o && e not in o) => e in o.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":23,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Insert', node=-, parent==>, position=0)\", \"(type='Move', tree='{.{var2/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Insert', node=+, parent=-, position=1)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/User}{var2/User}}', parent=., position=0)\", \"(type='Insert', node=field/follows, parent=., position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var1/User}{var2/User}}', parent=+, position=0)\", \"(type='Move', tree='{var0/User}', parent=+, position=1)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Update', node=in, value=set of)\", \"(type='Move', tree='{in{var0/User}{var1/User}}', parent=field/follows, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var2/User, value=sig/User)\", \"(type='Move', tree='{var2/User}', parent=set of, position=0)\", \"(type='Update', node=var2/User, value=sig/User)\", \"(type='Move', tree='{var2/User}', parent=set of, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":23,"challenge":"dkZH6HJNQNLLDX6Aj","time":52408300,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | (e in s && s in o && e not in o) => o in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{var1/User}}{in{var0/User}{var2/User}}{in{var2/User}{var1/User}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e: User, o: User, s: User | (e in s && s in o && e not in o) => o in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Update', node=AND, value=-)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=AND, position=0)\", \"(type='Insert', node=+, parent=AND, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/User}{var1/User}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var0/User}{var2/User}}', parent=+, position=0)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Move', tree='{var2/User}', parent=+, position=1)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Update', node=var2/User, value=sig/User)\", \"(type='Move', tree='{var2/User}', parent=set of, position=0)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":65740600,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows && u2.follows not in u1.follows => u2.follows in u1.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","sourceExpr":"all disj u1,u2: User | u2 in u1.follows && u2.follows not in u1.follows => u2.follows in u1.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Insert', node=!in, parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Move', tree='{var1/User}', parent=in, position=0)\", \"(type='Insert', node=var1/User, parent=!in, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Insert', node=one of, parent=some, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=some, position=1)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Insert', node=var2, parent=one of, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=one of, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=!in)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":54136300,"targetExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u,s:User | u -> s in suggested iff ((some f:User | u -> f in follows and f -> s in follows) and u -> s not in follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}","nextExpr":"all u1, u3 : User | (u1->u3 in suggested) <=> (u1->u3 not in follows and u1 != u3) and (some u2 : User | u1->u2 in follows and u2->u3 in follows)","sourceExpr":"all u,s:User | u -> s in suggested iff ((some f:User | u -> f in follows and f -> s in follows) and u -> s not in follows)","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\"]","hint":"Near a solution! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{some{one of{var2}{sig/User}}{AND{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var1/User}}{field/follows{set of{sig/User}}}}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}","totalTED":3,"challenge":"dkZH6HJNQNLLDX6Aj","time":65683400,"targetExpr":"all u1, u3 : User | (u1->u3 in suggested) <=> (u1->u3 not in follows and u1 != u3) and (some u2 : User | u1->u2 in follows and u2->u3 in follows)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User | (e in o.follows && e not in o) => o in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!in{var0/User}{var1/User}}{in{var0/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1,u2 : User | (u1 in u2.suggested) <=> (u1 in ( u2.follows.follows - u2.follows) and u1!=u2)","sourceExpr":"all disj e: User, o: User | (e in o.follows && e not in o) => o in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{in{var0/User}{-{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=!in, value=!=)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Insert', node=-, parent=in, position=1)\", \"(type='Update', node=var0/User, value=var1/User)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='TreeInsert', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{in{var0/User}{-{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}}}{in{var0/User}{.{var1/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":55772800,"targetExpr":"all u1,u2 : User | (u1 in u2.suggested) <=> (u1 in ( u2.follows.follows - u2.follows) and u1!=u2)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | s in o.follows => s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e: User, o: User, s: User | s in o.follows => s in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Update', node=in, value=-)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=+, parent=in, position=1)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Move', tree='{var2/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":16,"challenge":"dkZH6HJNQNLLDX6Aj","time":54855100,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | (o in e.follows && o in s.follows && s not in e.follows) => s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x : User |all y : User | y in x.suggested <=> ((some z : x.follows | y in z.follows) and (y not in x.follows + x))","sourceExpr":"all disj e: User, o: User, s: User | (o in e.follows && o in s.follows && s not in e.follows) => s in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Move', tree='{=>{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}', parent=all, position=1)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Update', node=in, value=one of)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=some, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}', parent=some, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Update', node=var1/User, value=var2)\", \"(type='TreeDelete', tree='{one of{var2}{sig/User}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":60951000,"targetExpr":"all x : User |all y : User | y in x.suggested <=> ((some z : x.follows | y in z.follows) and (y not in x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | all dif: u1.follows - u2.follows| u2 in u1.follows => dif in u1.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{all{one of{var2}{-{.{var0/User}{field/follows{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u1,u2: User | all dif: u1.follows - u2.follows| u2 in u1.follows => dif in u1.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=all, value==)\", \"(type='Insert', node=-, parent=all, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=all, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Move', tree='{var2/User}', parent=-, position=1)\", \"(type='Update', node=-, value=.)\", \"(type='Move', tree='{-{.{var0/User}{field/follows{set of{sig/User}}}}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=-, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":55938700,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all e: User, o: User - e, s: User - (e + o) | s in o.follows => s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{var0/User}}}{all{one of{var2}{-{sig/User}{+{var0/User}{var1/User}}}}{=>{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in (u1.follows)+u1","sourceExpr":"all e: User, o: User - e, s: User - (e + o) | s in o.follows => s in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Update', node=-, value=!in)\", \"(type='Move', tree='{-{sig/User}{+{var1/User}{var0/User}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=., parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=., position=0)\", \"(type='Insert', node=field/follows, parent=., position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Move', tree='{var0/User}', parent=set of, position=0)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":61072000,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in (u1.follows)+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | (some p:Ad | p in u.posts ) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer | i!=u implies i in u.follows } pred inv6 { all d:Day,i:Influencer | d in i.posts.date } pred inv7 { all u1,u2:User | u2 in u1.suggested iff (all u3:User | u2 not in u1.follows and u1!=u2 and u2 in u3.follows and u3 in u1.follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{all{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all u1,u2:User | u2 in u1.suggested iff (all u3:User | u2 not in u1.follows and u1!=u2 and u2 in u3.follows and u3 in u1.follows)","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=<=>, position=0)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}', parent=AND, position=1)\", \"(type='TreeDelete', tree='{!={var0/User}{var1/User}}')\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the equivalence operator ('<=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":71527400,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { all disj u,i:User | i in Influencer implies i in u.follows } pred inv6 { all i:Influencer,d:Day | d in i.posts.date } pred inv7 { all u:User,s:u.suggested | s in u.follows.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}","nextExpr":"all u : User | u.follows.follows - u - u.follows = u.suggested","sourceExpr":"all u1 : User | all u2 : u1.suggested | u2 in u1.follows.follows","predicate":"inv7","isNewNode":false,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=all, value==)\", \"(type='Insert', node=-, parent=all, position=0)\", \"(type='Insert', node=., parent=all, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var1}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=one of, position=2)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":129037600,"targetExpr":"all u : User | u.follows.follows - u - u.follows = u.suggested","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User | some f: u.follows.follows - u | uu not in u.follows && uu in f => uu = u.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{some{one of{var2}{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}{={.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u,uu: User | some f: u.follows.follows - u | uu not in u.follows && uu in f => uu = u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=-, parent=some, position=0)\", \"(type='Update', node=field/suggested, value=.)\", \"(type='Move', tree='{field/suggested{set of{sig/User}}}', parent=some, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=field/suggested, position=0)\", \"(type='Update', node=set of, value=field/suggested)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Update', node=sig/User, value=set of)\", \"(type='Update', node=var0/User, value=sig/User)\", \"(type='Move', tree='{var0/User}', parent=sig/User, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=.)\", \"(type='Delete', node==)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":64087200,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => (u2-u1) in u1.suggested } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{-{var1/User}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => (u2-u1) in u1.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Move', tree='{var1/User}', parent=in, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":54319500,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | (some a:Ad | a in u.posts) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer-u | i in u.follows } pred inv6 { all d:Day,i:Influencer | i in posts.(date.d) } pred inv7 { all u1,u2,u3:User | u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows iff u3 not in u1.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{<=>{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{AND{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","sourceExpr":"all u1,u2,u3:User | u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows iff u3 not in u1.follows","predicate":"inv7","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Move', tree='{<=>{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{AND{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}', parent=all, position=1)\", \"(type='Insert', node=AND, parent=<=>, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=<=>, position=1)\", \"(type='Move', tree='{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=0)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Update', node=in, value=one of)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=some, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=some, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Update', node=var2/User, value=var2)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{one of{var2}{sig/User}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the equivalence operator ('<=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{some{one of{var2}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":52918700,"targetExpr":"all x : User | all y : User | ((y not in x.follows+x) and (some z : x.follows | y in z.follows)) <=> y in x.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all u,o: User | (o in (u-o).follows.follows && o not in (u-o).follows) => o in u.suggested } pred inv8 { all u: User, a: Ad | (u in a.~sees) => (a in u.follows.posts or a in u.suggested.posts) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{-{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{-{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all u,o: User | (o in (u-o).follows.follows && o not in (u-o).follows) => o in u.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{-{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":52664000,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p in u.posts } pred inv2 { no u : User | u in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees implies p in u.follows.posts or p in Ad } pred inv4 { } pred inv5 { all i : Influencer, u : User - i | i in u.follows } pred inv6 { all i : Influencer, d : Day | some p : i.posts | p.date = d } pred inv7 { all u: User | all fu: u.follows | all ffu: fu.follows | (ffu not in u.follows) and (ffu != u) implies (ffu in u.suggested) } pred inv8 { all u: User | all p: u.follows.posts | (Ad in p implies (Ad in u.sees or Ad in u.suggested.posts)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/follows{set of{sig/User}}}}}{all{one of{var2}{.{var1/User}{field/follows{set of{sig/User}}}}}{=>{AND{!={var0/User}{var2/User}}{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u : User | u.follows.follows - u - u.follows = u.suggested","sourceExpr":"all u: User | all fu: u.follows | all ffu: fu.follows | (ffu not in u.follows) and (ffu != u) implies (ffu in u.suggested)","predicate":"inv7","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=all, value==)\", \"(type='Insert', node=-, parent=all, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=all, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Move', tree='{var0/User}', parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=!=)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var0/User}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":19,"challenge":"dkZH6HJNQNLLDX6Aj","time":49267400,"targetExpr":"all u : User | u.follows.follows - u - u.follows = u.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | (some a:Ad | a in u.posts) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer-u | i in u.follows } pred inv6 { all d:Day,i:Influencer | i in posts.(date.d) } pred inv7 { all u1,u2,u3:User | u1!=u2 and u2!=u3 and u1!=u3 and u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows implies u3 not in u1.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!={var0/User}{var1/User}}{!={var1/User}{var2/User}}{!={var0/User}{var2/User}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all u1,u2,u3:User | u1!=u2 and u2!=u3 and u1!=u3 and u3 in u1.suggested and u2 in u1.follows and u3 in u2.follows implies u3 not in u1.follows","predicate":"inv7","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Move', tree='{=>{AND{!={var0/User}{var1/User}}{!={var2/User}{var1/User}}{!={var0/User}{var2/User}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}', parent=all, position=1)\", \"(type='Update', node=!in, value=in)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=!=, value=one of)\", \"(type='Move', tree='{!={var2/User}{var1/User}}', parent=some, position=0)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Update', node=var2/User, value=var2)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=1)\", \"(type='Move', tree='{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=2)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='TreeDelete', tree='{!={var0/User}{var2/User}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/User}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":21,"challenge":"dkZH6HJNQNLLDX6Aj","time":57484400,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i:Influencer | all u :User | u!= i => i in u.follows } pred inv6 { all i:Influencer | all d:Day | d in i.posts.date } pred inv7 { all u,u2:User |all sug:u.suggested | u2 in u.follows => u2.follows.follows in sug } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{.{var0/User}{field/suggested{set of{sig/User}}}}}{=>{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{.{.{var1/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{var2/User}}}}}}","nextExpr":"all x, z : User | x in suggested.z iff z in (x.follows.follows - x.follows - x)","sourceExpr":"all u,u2:User |all sug:u.suggested | u2 in u.follows => u2.follows.follows in sug","predicate":"inv7","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{var0/User}{.{field/suggested{set of{sig/User}}}{var1/User}}}{in{var1/User}{-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node==>, value=in)\", \"(type='Update', node=var2, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent==>, position=0)\", \"(type='Insert', node=-, parent==>, position=1)\", \"(type='Insert', node=var1/User, parent=., position=2)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Move', tree='{var2/User}', parent=-, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Insert', node=., parent=-, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Insert', node=var0/User, parent=., position=0)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{in{var0/User}{.{field/suggested{set of{sig/User}}}{var1/User}}}{in{var1/User}{-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}}}}}","totalTED":17,"challenge":"dkZH6HJNQNLLDX6Aj","time":56223000,"targetExpr":"all x, z : User | x in suggested.z iff z in (x.follows.follows - x.follows - x)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { all disj u,i:User | i in Influencer implies i in u.follows } pred inv6 { all i:Influencer,d:Day | d in i.posts.date } pred inv7 { all u:User,s:u.suggested-u.follows | s in u.follows.follows implies s not in u.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{=>{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","sourceExpr":"all u:User,s:u.suggested-u.follows | s in u.follows.follows implies s not in u.follows","predicate":"inv7","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Move', tree='{var1}', parent=one of, position=0)\", \"(type='Insert', node=sig/User, parent=one of, position=1)\", \"(type='Insert', node=AND, parent=<=>, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=<=>, position=1)\", \"(type='Update', node=., value=!=)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=AND, position=0)\", \"(type='Insert', node=!in, parent=AND, position=1)\", \"(type='Move', tree='{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}', parent=AND, position=2)\", \"(type='Update', node=sig/User, value=var1/User)\", \"(type='Move', tree='{sig/User}', parent=., position=1)\", \"(type='Insert', node=var1/User, parent=!in, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=!in, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/suggested)\", \"(type='Delete', node=-)\", \"(type='Delete', node=one of)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":57325200,"targetExpr":"all u, s: User | s in u.suggested iff s not in u.follows and s in u.follows.follows and s != u","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | u in posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u1,u2:User, p:Photo-Ad | u1 in sees.p and u2 in posts.p implies u2 in u1.follows } pred inv4 { all u:User | (some a:Ad | a in u.posts) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer-u | i in u.follows } pred inv6 { all d:Day,i:Influencer | i in posts.(date.d) } pred inv7 { all u1:User,u2:User-u1,u3:User-u1-u2 | u3 in u1.suggested implies u3 not in u1.follows and u2 in u1.follows and u3 in u2.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{sig/User}{var0/User}}}{all{one of{var2}{-{-{sig/User}{var0/User}}{var1/User}}}{=>{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}{AND{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}}}}}}","nextExpr":"all u,y : User | y in u.suggested iff (u != y and (y not in u.follows) and (some z : User | (z in u.follows) and (y in z.follows)))","sourceExpr":"all u1:User, u2:User-u1,u3:User-u1-u2 | u3 in u1.suggested implies u3 not in u1.follows and u2 in u1.follows and u3 in u2.follows","predicate":"inv7","isNewNode":false,"srcDstTED":24,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{some{one of{var2}{sig/User}}{AND{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node=all, value=<=>)\", \"(type='Move', tree='{sig/User}', parent=one of, position=1)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Move', tree='{in{var2/User}{.{var1/User}{field/follows{set of{sig/User}}}}}', parent=all, position=1)\", \"(type='Update', node=-, value=!=)\", \"(type='Move', tree='{-{-{sig/User}{var0/User}}{var1/User}}', parent=AND, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}', parent=AND, position=1)\", \"(type='Insert', node=some, parent=AND, position=2)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='Move', tree='{var0/User}', parent=-, position=0)\", \"(type='Update', node=var2/User, value=var1/User)\", \"(type='TreeInsert', tree='{one of{var2}{sig/User}}', parent=some, position=0)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=AND, position=1)\", \"(type='Update', node=var0/User, value=var2/User)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=sig/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=AND)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{some{one of{var2}{sig/User}}{AND{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":24,"challenge":"dkZH6HJNQNLLDX6Aj","time":80590000,"targetExpr":"all u,y : User | y in u.suggested iff (u != y and (y not in u.follows) and (some z : User | (z in u.follows) and (y in z.follows)))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all disj u,uu: User | some f: u.follows.follows | uu not in u.follows && uu in f => uu = (u.suggested-u) } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{some{one of{var2}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{var2/User}}}{={-{.{var0/User}{field/suggested{set of{sig/User}}}}{var0/User}}{var1/User}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u,uu: User | some f: u.follows.follows | uu not in u.follows && uu in f => uu = (u.suggested-u)","predicate":"inv7","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Update', node=some, value==)\", \"(type='Insert', node=-, parent=some, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=some, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Move', tree='{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node==)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":18,"challenge":"dkZH6HJNQNLLDX6Aj","time":65673900,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User,p:Photo | p in u.sees implies (some u2:User | u2 in u.follows and p in u2.posts) or p in Ad } pred inv4 { all u:User | (some p:Ad | p in u.posts ) implies u.posts in Ad } pred inv5 { all u:User,i:Influencer | i!=u implies i in u.follows } pred inv6 { all d:Day,i:Influencer | d in i.posts.date } pred inv7 { all u1,u2:User | u2 in u1.suggested iff (all u3:User | u2 in u3.follows and u3 in u1.follows and u2 not in u1.follows) } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{all{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","sourceExpr":"all u1,u2:User | u2 in u1.suggested iff (all u3:User | u2 in u3.follows and u3 in u1.follows and u2 not in u1.follows)","predicate":"inv7","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=<=>, position=0)\", \"(type='TreeInsert', tree='{!={var0/User}{var1/User}}', parent=AND, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the equivalence operator ('<=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!={var0/User}{var1/User}}{some{one of{var2}{sig/User}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{var2/User}{field/follows{set of{sig/User}}}}}{in{var2/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":5,"challenge":"dkZH6HJNQNLLDX6Aj","time":56361500,"targetExpr":"all x,y: User | y in x.suggested <=> ( some z: User | y in z.follows && z in x.follows && y not in x.follows) && x!=y","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one posts.p } pred inv2 { all u:User | u not in u.follows } pred inv3 { all u:User, p:u.sees| p not in Ad implies p in u.follows.posts } pred inv4 { all u:User |all a:Ad | a in u.posts implies u.posts in Ad } pred inv5 { all disj u,i:User | i in Influencer implies i in u.follows } pred inv6 { all i:Influencer,d:Day | d in i.posts.date } pred inv7 { all u:User,s:u.suggested-u.follows | s in u.follows.follows and s not in u.follows } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{-{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}}}","nextExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","sourceExpr":"all u:User,s:u.suggested-u.follows | s in u.follows.follows and s not in u.follows","predicate":"inv7","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","operations":"[\"(type='Update', node=all, value==)\", \"(type='Insert', node=-, parent=all, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=all, position=1)\", \"(type='Insert', node=-, parent=-, position=0)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Move', tree='{var1/User}', parent=-, position=1)\", \"(type='Update', node=field/follows, value=field/suggested)\", \"(type='Update', node=-, value=.)\", \"(type='Move', tree='{-{.{var0/User}{field/suggested{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=-, position=1)\", \"(type='Move', tree='{field/follows{set of{sig/User}}}', parent=-, position=1)\", \"(type='Update', node=field/suggested, value=field/follows)\", \"(type='Delete', node=var0/User)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=!in)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}","totalTED":19,"challenge":"dkZH6HJNQNLLDX6Aj","time":46071100,"targetExpr":"all u:User | u.suggested = (u.follows.follows - u.follows - u)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | i.posts.date = d } pred inv7 { all disj e: User, o: User, s: User | (e in o && s in o && e not in s) => s in e.suggested } pred inv8 { }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{=>{AND{!in{var0/User}{var2/User}}{in{var0/User}{var1/User}}{in{var2/User}{var1/User}}}{in{var2/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","sourceExpr":"all disj e: User, o: User, s: User | (e in o && s in o && e not in s) => s in e.suggested","predicate":"inv7","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value==)\", \"(type='Update', node=AND, value=-)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent==>, position=1)\", \"(type='Insert', node=., parent=AND, position=0)\", \"(type='Insert', node=+, parent=AND, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/User}{var2/User}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var0/User}{var1/User}}', parent=+, position=0)\", \"(type='Update', node=var2/User, value=var0/User)\", \"(type='Move', tree='{var2/User}', parent=+, position=1)\", \"(type='Insert', node=field/follows, parent=!in, position=1)\", \"(type='Insert', node=field/follows, parent=in, position=1)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Insert', node=set of, parent=field/follows, position=0)\", \"(type='Update', node=var2/User, value=sig/User)\", \"(type='Move', tree='{var2/User}', parent=set of, position=0)\", \"(type='Update', node=var1/User, value=sig/User)\", \"(type='Move', tree='{var1/User}', parent=set of, position=0)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var2/User)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/User}}{={-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":20,"challenge":"dkZH6HJNQNLLDX6Aj","time":49469800,"targetExpr":"all x,y,z : User | x.suggested = (x.follows.follows - (x.follows + x))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u1.suggested = (u2.follows -u1.follows ) } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{={-{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","nextExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","sourceExpr":"all disj u1,u2: User | u1.suggested = (u2.follows -u1.follows )","predicate":"inv7","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","operations":"[\"(type='Insert', node=-, parent==, position=0)\", \"(type='Move', tree='{-{.{var1/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}', parent=-, position=0)\", \"(type='Insert', node=var0/User, parent=-, position=1)\", \"(type='Insert', node=., parent=-, position=0)\", \"(type='Move', tree='{.{var1/User}{field/follows{set of{sig/User}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{={-{-{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}{var0/User}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":44279900,"targetExpr":"all u1,u2: User | u1.suggested = (u1.follows.follows - u1.follows - u1)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo | p not in Ad && p in u.sees => p.~posts in u.follows } pred inv4 { all u: User, a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User-i | i in u.follows } pred inv6 { all d: Day, i: Influencer | i in d.~date.~posts } pred inv7 { all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested in u2 } pred inv8 { }","sourceAST":"{all{disj}{one of{var0}{sig/User}}{all{disj}{one of{var1}{sig/User}}{=>{AND{!in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{.{var0/User}{field/suggested{set of{sig/User}}}}{var1/User}}}}}","nextExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","sourceExpr":"all disj u1,u2: User | u2 in u1.follows.follows && u2 not in u1.follows => u1.suggested in u2","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Insert', node=var1/User, parent=in, position=0)\", \"(type='Insert', node=+, parent=!in, position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Insert', node=var0/User, parent=+, position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var1/User)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{<=>{AND{!in{var1/User}{+{.{var0/User}{field/follows{set of{sig/User}}}}{var0/User}}}{in{var1/User}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":7,"challenge":"dkZH6HJNQNLLDX6Aj","time":48733800,"targetExpr":"all u1, u2 : User | u2 in u1.suggested <=> u2 in u1.follows.follows and u2 not in u1.follows+u1","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts or p in Ad) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer , u: User | i != u implies u -> i in follows } pred inv6 { all i:Influencer , d:Day | some p:Photo | i -> p in posts and p -> d in date } pred inv7 { all u1, u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u:User, a:Ad | u -> Ad in sees implies (some u2:User | u2 -> a in posts and (u -> u2 in follows or u -> u2 in suggested)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{sig/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","sourceExpr":"all u:User, a:Ad | u -> Ad in sees implies (some u2:User | u2 -> a in posts and (u -> u2 in follows or u -> u2 in suggested))","predicate":"inv8","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Update', node=sig/Ad, value=var1/Ad)\"]","hint":"One step away from the solution! Instead of using signature of type Ad, try using variable of type Ad to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":99526400,"targetExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { one x,y :User| one p:Photo| x->p in posts and y -> p in posts implies x = y } pred inv2 { all x,y :User| x->y in follows implies x!=y } pred inv3 { all p:Photo-Ad, x,y:User| x->p in sees and y->p in posts implies x->y in follows } pred inv4 { all x:User, a:Ad| x->a in posts implies x.posts in Ad } pred inv5 { all i:Influencer, x:User-i| x->i in follows } pred inv6 { all d:Day, i:Influencer| some p:Photo| i -> p in posts and p->d in date } pred inv7 { } pred inv8 { all x,y:User, a:Ad| x->a in sees and y->a in posts implies x->y in follows or y->x in suggested }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Ad}}{OR{=>{AND{in{->{var0/User}{var2/Ad}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Ad}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{->{var1/User}{var0/User}}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u:User, x:User, a:Ad| u->a in sees and x->a in posts implies u->x in follows or u->x in suggested","sourceExpr":"all x:User, y:User, a:Ad| x->a in sees and y->a in posts implies x->y in follows or y->x in suggested","predicate":"inv8","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Ad}}{OR{=>{AND{in{->{var0/User}{var2/Ad}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Ad}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=var0/User, parent=->, position=0)\", \"(type='Delete', node=var0/User)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the arrow operator ('->') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Ad}}{OR{=>{AND{in{->{var0/User}{var2/Ad}}{field/sees{set of{sig/Photo}}}}{in{->{var1/User}{var2/Ad}}{field/posts{set of{sig/Photo}}}}}{in{->{var0/User}{var1/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var1/User}}{field/suggested{set of{sig/User}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":106155600,"targetExpr":"all u:User, x:User, a:Ad| u->a in sees and x->a in posts implies u->x in follows or u->x in suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all i: Photo | one i.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User | u.sees in u.follows.posts + Ad } pred inv4 { all u: User, a: Ad | some pa: a.~posts | pa in u => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in u.follows } pred inv6 { all d: Day, i: Influencer | some p: i.posts | p in d.~date } pred inv7 { all u: User | u.suggested = (u.follows.follows - (u.follows + u)) } pred inv8 { all u: User, a: Ad | u.sees in a => a.~posts in u.follows or a.~posts in u.suggested }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{OR{=>{in{.{var0/User}{field/sees{set of{sig/Photo}}}}{var1/Ad}}{in{.{var1/Ad}{~{field/posts{set of{sig/Photo}}}}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{.{var1/Ad}{~{field/posts{set of{sig/Photo}}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","nextExpr":"all u : User | all a : Ad | a in u.sees implies posts.a in u.follows or posts.a in u.suggested","sourceExpr":"all u: User, a: Ad | u.sees in a => a.~posts in u.follows or a.~posts in u.suggested","predicate":"inv8","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{OR{=>{in{var1/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{.{field/posts{set of{sig/Photo}}}{var1/Ad}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{.{field/posts{set of{sig/Photo}}}{var1/Ad}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","operations":"[\"(type='Insert', node=var1/Ad, parent=in, position=0)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=0)\", \"(type='Insert', node=var1/Ad, parent=., position=1)\", \"(type='Move', tree='{field/posts{set of{sig/Photo}}}', parent=., position=0)\", \"(type='Insert', node=var1/Ad, parent=., position=1)\", \"(type='Delete', node=var1/Ad)\", \"(type='Delete', node=var1/Ad)\", \"(type='Delete', node=~)\", \"(type='Delete', node=var1/Ad)\", \"(type='Delete', node=~)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider using a variable of type Ad to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{OR{=>{in{var1/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{.{field/posts{set of{sig/Photo}}}{var1/Ad}}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{.{field/posts{set of{sig/Photo}}}{var1/Ad}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":99266700,"targetExpr":"all u : User | all a : Ad | a in u.sees implies posts.a in u.follows or posts.a in u.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts or p in Ad) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer , u: User | i != u implies u -> i in follows } pred inv6 { all i:Influencer , d:Day | some p:Photo | i -> p in posts and p -> d in date } pred inv7 { all u1, u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u:User, a:Ad | u -> Ad in sees implies (all u1:User | u -> u1 in follows or u -> u1 in suggested) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{sig/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x: User, a: Ad | x -> a in sees implies all z: User | z -> a in posts implies x -> z in follows or x -> z in suggested","sourceExpr":"all u:User, a:Ad | u -> Ad in sees implies (all u1:User | u -> u1 in follows or u -> u1 in suggested)","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=sig/Ad, value=var1/Ad)\", \"(type='Insert', node==>, parent=OR, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}', parent==>, position=1)\"]","hint":"Keep going! Instead of using signature of type Ad, try using variable of type Ad to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":55072400,"targetExpr":"all x: User, a: Ad | x -> a in sees implies all z: User | z -> a in posts implies x -> z in follows or x -> z in suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts or p in Ad) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer , u: User | i != u implies u -> i in follows } pred inv6 { all i:Influencer , d:Day | some p:Photo | i -> p in posts and p -> d in date } pred inv7 { all u1, u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u:User, a:Ad | u -> Ad in sees implies (some u1:User | u -> u1 in follows or u -> u1 in suggested) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{sig/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","sourceExpr":"all u:User, a:Ad | u -> Ad in sees implies (some u1:User | u -> u1 in follows or u -> u1 in suggested)","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=some, position=1)\", \"(type='Update', node=sig/Ad, value=var1/Ad)\", \"(type='Move', tree='{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":68517800,"targetExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad | all u:User | u -> a in sees implies (some p:User | p -> a in posts implies u -> p in follows or u -> p in suggested) }","sourceAST":"{all{one of{var0}{sig/Ad}}{all{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var1/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x: User, a: Ad | x -> a in sees implies all z: User | z -> a in posts implies x -> z in follows or x -> z in suggested","sourceExpr":"all a:Ad | all u:User | u -> a in sees implies (some p:User | p -> a in posts implies u -> p in follows or u -> p in suggested)","predicate":"inv8","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\"]","hint":"Keep going! Instead of using signature of type Ad, try using signature of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","totalTED":8,"challenge":"dkZH6HJNQNLLDX6Aj","time":85054700,"targetExpr":"all x: User, a: Ad | x -> a in sees implies all z: User | z -> a in posts implies x -> z in follows or x -> z in suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p in u.posts } pred inv2 { no u : User | u in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees implies p in u.follows.posts or p in Ad } pred inv4 { } pred inv5 { all i : Influencer, u : User - i | i in u.follows } pred inv6 { all i : Influencer, d : Day | some p : i.posts | p.date = d } pred inv7 { all u: User | u.suggested = { ffu: u.follows.follows | (ffu not in u.follows) and (ffu != u) } } pred inv8 { all u: User | all p: u.follows.posts | (Ad in p implies (Ad in u.sees or Ad in u.suggested.posts)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{=>{in{sig/Ad}{var1/Photo}}{OR{in{sig/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{sig/Ad}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u:User| all p: u.sees| p in Ad implies (p in u.follows.posts or p in u.suggested.posts)","sourceExpr":"all u: User | all p: u.follows.posts | (Ad in p implies (Ad in u.sees or Ad in u.suggested.posts))","predicate":"inv8","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{OR{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='Update', node=field/posts, value=field/sees)\", \"(type='Insert', node=var1/Photo, parent=in, position=0)\", \"(type='Update', node=sig/Ad, value=var1/Photo)\", \"(type='Update', node=sig/Ad, value=var1/Photo)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/follows{set of{sig/User}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1/Photo)\"]","hint":"Keep going! It seems like the variable of type User is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{OR{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":14,"challenge":"dkZH6HJNQNLLDX6Aj","time":94349800,"targetExpr":"all u:User| all p: u.sees| p in Ad implies (p in u.follows.posts or p in u.suggested.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u-> p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | i != u implies u -> i in follows } pred inv6 { all i:Influencer, d:Day | some p:Photo | i -> p in posts and p-> d in date } pred inv7 { all u1:User, u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u:User, a:Ad | u -> a in sees implies (some u2:User | u2 -> a in posts and (u->u2 in follows or u2->u2 in suggested)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","sourceExpr":"all u:User, a:Ad | u -> a in sees implies (some u2:User | u2 -> a in posts and (u->u2 in follows or u2->u2 in suggested))","predicate":"inv8","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Update', node=var2/User, value=var0/User)\"]","hint":"One step away from the solution! Instead of using variable of type User, try using variable of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":39633000,"targetExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User, p:Photo| u -> p in sees implies ((p in Ad) or (some u2:User | u -> u2 in follows and u2 -> p in posts)) } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u-> p in posts implies p in Ad) } pred inv5 { all i:Influencer, u:User | i != u implies u -> i in follows } pred inv6 { all i:Influencer, d:Day | some p:Photo | i -> p in posts and p-> d in date } pred inv7 { all u1:User, u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u:User, a:Ad | u -> a in sees implies (some u2:User | u2 -> a in posts and (u->u2 in follows or u2 -> u in suggested)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var2/User}{var0/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","sourceExpr":"all x:User, a:Ad| x->a in sees implies some y:User| y->a in posts and (x->y in follows or y->x in suggested)","predicate":"inv8","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Insert', node=var0/User, parent=->, position=0)\", \"(type='Delete', node=var0/User)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type User to correctly capture the property you want to specify. Think about how you can incorporate this within the arrow operator ('->') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":95636200,"targetExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","createdShorterPath":true}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p:Photo | one u:User | p in u.posts } pred inv2 { all u:User| u not in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees => p in u.follows.posts or p in Ad } pred inv4 { all u:User |all a: Ad | a in u.posts => u.posts in Ad } pred inv5 { all i:Influencer | all u :User | u!= i => i in u.follows } pred inv6 { all i:Influencer | all d:Day | d in i.posts.date } pred inv7 { all u : User | u.suggested = (u.follows.follows - (u.follows + u)) } pred inv8 { all u,u2 :User | some p:u2.posts | p in Ad and p in u.sees implies u2 in u.follows or u2 in u.suggested }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{some{one of{var2}{.{var1/User}{field/posts{set of{sig/Photo}}}}}{OR{=>{AND{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u1 : User, u2 : User, p: Photo | p in Ad and p in u1.sees and p in u2.posts implies u2 in u1.follows or u2 in u1.suggested","sourceExpr":"all u,u2 :User | some p:u2.posts | p in Ad and p in u.sees implies u2 in u.follows or u2 in u.suggested","predicate":"inv8","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{AND{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{sig/Photo}', parent=one of, position=1)\", \"(type='TreeInsert', tree='{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}', parent=AND, position=2)\", \"(type='Delete', node=var1/User)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/posts)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/User}}{all{one of{var2}{sig/Photo}}{OR{=>{AND{in{var2/Photo}{sig/Ad}}{in{var2/Photo}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{var2/Photo}{.{var1/User}{field/posts{set of{sig/Photo}}}}}}{in{var1/User}{.{var0/User}{field/follows{set of{sig/User}}}}}}{in{var1/User}{.{var0/User}{field/suggested{set of{sig/User}}}}}}}}}","totalTED":12,"challenge":"dkZH6HJNQNLLDX6Aj","time":70790000,"targetExpr":"all u1 : User, u2 : User, p: Photo | p in Ad and p in u1.sees and p in u2.posts implies u2 in u1.follows or u2 in u1.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj u,o: User | (o in u.follows.follows && o not in u.follows && u not in u.follows) => o in u.suggested } pred inv8 { all u: User, a: Ad | (a in u.follows or a in u.suggested) => (u in a.~sees) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{OR{in{var1/Ad}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Ad}{.{var0/User}{field/suggested{set of{sig/User}}}}}}{in{var0/User}{.{var1/Ad}{~{field/sees{set of{sig/Photo}}}}}}}}}","nextExpr":"all u:User | not some a:Ad | u->a in sees and posts . a not in u.follows+u.suggested","sourceExpr":"all u: User, a: Ad | (a in u.follows or a in u.suggested) => (u in a.~sees)","predicate":"inv8","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{!{some{one of{var1}{sig/Ad}}{AND{!in{.{field/posts{set of{sig/Photo}}}{var1/Ad}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}}}}}","operations":"[\"(type='Insert', node=!, parent=all, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var1}{sig/Ad}}{=>{OR{in{var1/Ad}{.{var0/User}{field/follows{set of{sig/User}}}}}{in{var1/Ad}{.{var0/User}{field/suggested{set of{sig/User}}}}}}{in{var0/User}{.{var1/Ad}{~{field/sees{set of{sig/Photo}}}}}}}}', parent=!, position=0)\", \"(type='Update', node==>, value=AND)\", \"(type='Update', node=OR, value=!in)\", \"(type='Insert', node=., parent=OR, position=0)\", \"(type='Insert', node=+, parent=OR, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Move', tree='{field/sees{set of{sig/Photo}}}', parent=in, position=1)\", \"(type='TreeInsert', tree='{field/posts{set of{sig/Photo}}}', parent=., position=0)\", \"(type='Move', tree='{var1/Ad}', parent=., position=1)\", \"(type='Move', tree='{.{var0/User}{field/follows{set of{sig/User}}}}', parent=+, position=0)\", \"(type='Move', tree='{.{var0/User}{field/suggested{set of{sig/User}}}}', parent=+, position=1)\", \"(type='Move', tree='{var0/User}', parent=->, position=0)\", \"(type='Move', tree='{var1/Ad}', parent=->, position=1)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/Ad)\", \"(type='Delete', node=in)\", \"(type='Delete', node=~)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/User}}{!{some{one of{var1}{sig/Ad}}{AND{!in{.{field/posts{set of{sig/Photo}}}{var1/Ad}}{+{.{var0/User}{field/follows{set of{sig/User}}}}{.{var0/User}{field/suggested{set of{sig/User}}}}}}{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":59324100,"targetExpr":"all u:User | not some a:Ad | u->a in sees and posts . a not in u.follows+u.suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p: Photo | one p.~posts } pred inv2 { all u: User | u not in u.follows } pred inv3 { all u: User, p: Photo - Ad | u in p.~sees => p in u.follows.posts } pred inv4 { all u : User, a: Ad | u in a.~posts => u.posts in Ad } pred inv5 { all i: Influencer, u: User - i | i in (u).follows } pred inv6 { all i: Influencer, d: Day | d in i.posts.date } pred inv7 { all disj u,o: User | (o in u.follows.follows && o not in u.follows && u not in u.follows) => o in u.suggested } pred inv8 { all u: User, a: Ad | (a in u.follows.posts or a in u.suggested.posts) => (u in a.~sees) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{OR{in{var1/Ad}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Ad}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}{in{var0/User}{.{var1/Ad}{~{field/sees{set of{sig/Photo}}}}}}}}}","nextExpr":"all u : User | all a : Ad | a in u.sees implies (a in u.follows.posts or a in u.suggested.posts)","sourceExpr":"all u: User, a: Ad | (a in u.follows.posts or a in u.suggested.posts) => (u in a.~sees)","predicate":"inv8","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{OR{in{var1/Ad}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Ad}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='TreeInsert', tree='{in{var1/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}', parent==>, position=0)\", \"(type='TreeDelete', tree='{in{var0/User}{.{var1/Ad}{~{field/sees{set of{sig/Photo}}}}}}')\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{var1/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{OR{in{var1/Ad}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Ad}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":15,"challenge":"dkZH6HJNQNLLDX6Aj","time":68797900,"targetExpr":"all u : User | all a : Ad | a in u.sees implies (a in u.follows.posts or a in u.suggested.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { } pred inv2 { } pred inv3 { all u:User, p:Photo | (u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts)) or p in Ad } pred inv4 { all u : User | (some p : Ad | (u -> p in posts)) => all p1 : Photo | (u -> p1 in posts => p1 in Ad) } pred inv5 { all inf : Influencer, u : User | inf != u => u -> inf in follows } pred inv6 { all inf : Influencer, d : Day | (some p : Photo | (inf -> p in posts and p->d in date)) } pred inv7 { all u1, u2 : User | u1 -> u2 in suggested iff (some u3 : User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u : User | some a : Ad, u2 : User | (u -> a in sees and u2 -> a in posts) => (u -> u2 in follows or u -> u2 in suggested) }","sourceAST":"{all{one of{var0}{sig/User}}{some{one of{var1}{sig/Ad}}{some{one of{var2}{sig/User}}{=>{AND{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all u : User, a : Ad, us : User | u -> a in sees and us -> a in posts implies (u -> us in follows or u -> us in suggested)","sourceExpr":"all u : User | some a : Ad, u2 : User | (u -> a in sees and u2 -> a in posts) => (u -> u2 in follows or u -> u2 in suggested)","predicate":"inv8","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{all{one of{var2}{sig/User}}{=>{AND{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","totalTED":2,"challenge":"dkZH6HJNQNLLDX6Aj","time":65983900,"targetExpr":"all u : User, a : Ad, us : User | u -> a in sees and us -> a in posts implies (u -> us in follows or u -> us in suggested)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { all p : Photo | one u : User | p in u.posts } pred inv2 { no u : User | u in u.follows } pred inv3 { all u : User, p : Photo | p in u.sees implies p in u.follows.posts or p in Ad } pred inv4 { } pred inv5 { all i : Influencer, u : User - i | i in u.follows } pred inv6 { all i : Influencer, d : Day | some p : i.posts | p.date = d } pred inv7 { all u: User | u.suggested = { ffu: u.follows.follows | (ffu not in u.follows) and (ffu != u) } } pred inv8 { all u: User | all p: u.posts | (Ad in p implies (Ad in u.sees or Ad in u.suggested.posts)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/posts{set of{sig/Photo}}}}}{=>{in{sig/Ad}{var1/Photo}}{OR{in{sig/Ad}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{in{sig/Ad}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u: User | all a : u.sees | a in Ad implies ( a in u.follows.posts or a in u.suggested.posts)","sourceExpr":"all u: User | all p: u.posts | (Ad in p implies (Ad in u.sees or Ad in u.suggested.posts))","predicate":"inv8","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{OR{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Update', node=field/posts, value=field/sees)\", \"(type='Insert', node=var1/Photo, parent=in, position=0)\", \"(type='Update', node=sig/Ad, value=var1/Photo)\", \"(type='Update', node=sig/Ad, value=var1/Photo)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=field/sees, value=field/posts)\", \"(type='Move', tree='{var0/User}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/follows{set of{sig/User}}}', parent=., position=1)\", \"(type='Delete', node=var1/Photo)\"]","hint":"Keep going! Instead of using field \"posts\", try using field \"sees\" to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{.{var0/User}{field/sees{set of{sig/Photo}}}}}{=>{in{var1/Photo}{sig/Ad}}{OR{in{var1/Photo}{.{.{var0/User}{field/follows{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}{in{var1/Photo}{.{.{var0/User}{field/suggested{set of{sig/User}}}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":10,"challenge":"dkZH6HJNQNLLDX6Aj","time":58846200,"targetExpr":"all u: User | all a : u.sees | a in Ad implies ( a in u.follows.posts or a in u.suggested.posts)","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { no u:User | u->u in follows } pred inv3 { all p:Photo,u:User | u -> p in sees implies (some u2:User | u -> u2 in follows and u2 -> p in posts) or p in Ad } pred inv4 { all u:User | (some a:Ad | u -> a in posts) implies (all p:Photo | u -> p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | u != i implies u -> i in follows } pred inv6 { all d:Day,i:Influencer | (some p:Photo | i -> p in posts and p -> d in date) } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all a:Ad | some u:User | u -> a in sees implies (some p:User | p -> a in posts implies u -> p in follows or u -> p in suggested) }","sourceAST":"{all{one of{var0}{sig/Ad}}{some{one of{var1}{sig/User}}{=>{in{->{var1/User}{var0/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var0/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var1/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var1/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","nextExpr":"all x: User, a: Ad | x -> a in sees implies all z: User | z -> a in posts implies x -> z in follows or x -> z in suggested","sourceExpr":"all a:Ad | some u:User | u -> a in sees implies (some p:User | p -> a in posts implies u -> p in follows or u -> p in suggested)","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Ad, value=sig/User)\", \"(type='Update', node=sig/User, value=sig/Ad)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\", \"(type='Update', node=var0/Ad, value=var1/Ad)\", \"(type='Update', node=var1/User, value=var0/User)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{all{one of{var2}{sig/User}}{OR{=>{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}}}}}","totalTED":9,"challenge":"dkZH6HJNQNLLDX6Aj","time":76019600,"targetExpr":"all x: User, a: Ad | x -> a in sees implies all z: User | z -> a in posts implies x -> z in follows or x -> z in suggested","createdShorterPath":false}
{"mapping":"APTED","code":"sig User { follows : set User, sees : set Photo, posts : set Photo, suggested : set User } sig Influencer extends User {} sig Photo { date : one Day } sig Ad extends Photo {} sig Day {} pred inv1 { posts in User one -> Photo } pred inv2 { all u:User | u -> u not in follows } pred inv3 { all u:User,p:Photo | u -> p in sees implies ((some u2:User | u->u2 in follows and u2->p in posts) or p in Ad) } pred inv4 { all u:User | (some a:Ad | u->a in posts) implies (all p:Photo | u->p in posts implies p in Ad) } pred inv5 { all i:Influencer,u:User | i != u implies u -> i in follows } pred inv6 { all i:Influencer, d:Day | some p:Photo | i -> p in posts and p -> d in date } pred inv7 { all u1,u2:User | u1 -> u2 in suggested iff (some u3:User | u1 -> u3 in follows and u3 -> u2 in follows and u1 -> u2 not in follows and u1 != u2) } pred inv8 { all u:User,a:Ad | u -> a in sees implies (some u2:User | u->a in posts and (u->u2 in follows or u->u2 in suggested)) }","sourceAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var0/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","nextExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","sourceExpr":"all u:User,a:Ad | u -> a in sees implies (some u2:User | u->a in posts and (u->u2 in follows or u->u2 in suggested))","predicate":"inv8","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","operations":"[\"(type='Update', node=var0/User, value=var2/User)\"]","hint":"One step away from the solution! Instead of using variable of type User, try using variable of type User to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/User}}{all{one of{var1}{sig/Ad}}{=>{in{->{var0/User}{var1/Ad}}{field/sees{set of{sig/Photo}}}}{some{one of{var2}{sig/User}}{AND{OR{in{->{var0/User}{var2/User}}{field/follows{set of{sig/User}}}}{in{->{var0/User}{var2/User}}{field/suggested{set of{sig/User}}}}}{in{->{var2/User}{var1/Ad}}{field/posts{set of{sig/Photo}}}}}}}}}","totalTED":1,"challenge":"dkZH6HJNQNLLDX6Aj","time":36818500,"targetExpr":"all u: User, a: Ad | u->a in sees implies (some u1: User | u1->a in posts && (u->u1 in follows || u->u1 in suggested))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { adj.~adj = iden } pred oriented { } pred acyclic { } pred complete { } pred noLoops { all n : Node | n not in n.^adj } pred weaklyConnected { all n : Node | Node in n.*(adj+~adj) } pred stonglyConnected { Node in Node.*adj } pred transitive { }","sourceAST":"{all{one of{var0}{sig/Node}}{!in{var0/Node}{.{var0/Node}{^{field/adj{set of{sig/Node}}}}}}}","nextExpr":"all n:Node | n not in n.adj","sourceExpr":"all n: Node | n not in n.^adj","predicate":"noLoops","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Node}}{!in{var0/Node}{.{var0/Node}{field/adj{set of{sig/Node}}}}}}","operations":"[\"(type='Move', tree='{field/adj{set of{sig/Node}}}', parent=., position=1)\", \"(type='Delete', node=^)\"]","hint":"One step away from the solution! It seems like the field \"adj\" is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Node}}{!in{var0/Node}{.{var0/Node}{field/adj{set of{sig/Node}}}}}}","totalTED":1,"challenge":"gAeD3MTGCCv8YNTaK","time":90626600,"targetExpr":"all n:Node | n not in n.adj","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { adj.~adj = iden } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.*(adj+~adj) } pred stonglyConnected { Node in Node.*adj } pred transitive { }","sourceAST":"{in{sig/Node}{.{sig/Node}{*{field/adj{set of{sig/Node}}}}}}","nextExpr":"all n:Node | Node in n.*adj","sourceExpr":"Node in Node.*adj","predicate":"stonglyConnected","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{field/adj{set of{sig/Node}}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Node}}', parent=all, position=0)\", \"(type='Move', tree='{in{sig/Node}{.{sig/Node}{*{field/adj{set of{sig/Node}}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Node, value=var0/Node)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Node\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{field/adj{set of{sig/Node}}}}}}}","totalTED":5,"challenge":"gAeD3MTGCCv8YNTaK","time":90747200,"targetExpr":"all n:Node | Node in n.*adj","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { adj.~adj = iden } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.*(adj+~adj) } pred stonglyConnected { Node in Node.^adj } pred transitive { }","sourceAST":"{in{sig/Node}{.{sig/Node}{^{field/adj{set of{sig/Node}}}}}}","nextExpr":"Node in Node.*adj","sourceExpr":"Node in Node.^adj","predicate":"stonglyConnected","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{field/adj{set of{sig/Node}}}}}}}","operations":"[\"(type='Update', node=^, value=*)\"]","hint":"Keep going! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.","nextAST":"{in{sig/Node}{.{sig/Node}{*{field/adj{set of{sig/Node}}}}}}","totalTED":6,"challenge":"gAeD3MTGCCv8YNTaK","time":56676300,"targetExpr":"all n:Node | Node in n.*adj","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { adj.~adj = iden } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.*(adj+~adj) } pred stonglyConnected { } pred transitive { }","sourceAST":"{={.{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}{iden}}","nextExpr":"adj = ~adj","sourceExpr":"adj.~adj = iden","predicate":"undirected","isNewNode":false,"srcDstTED":2,"targetAST":"{={field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}","operations":"[\"(type='Move', tree='{field/adj{set of{sig/Node}}}', parent==, position=0)\", \"(type='Move', tree='{~{field/adj{set of{sig/Node}}}}', parent==, position=1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=iden)\"]","hint":"Near a solution! It seems like the field \"adj\" is not in the right place. Try moving it to the inside of the equal operator ('=') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{={field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}","totalTED":2,"challenge":"gAeD3MTGCCv8YNTaK","time":97764800,"targetExpr":"adj = ~adj","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { adj.~adj in iden } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.*(adj+~adj) } pred stonglyConnected { } pred transitive { }","sourceAST":"{in{.{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}{iden}}","nextExpr":"adj = ~adj","sourceExpr":"adj.~adj in iden","predicate":"undirected","isNewNode":false,"srcDstTED":3,"targetAST":"{={field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}","operations":"[\"(type='Update', node=., value==)\", \"(type='Move', tree='{.{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}', parent=root, position=0)\", \"(type='Delete', node=iden)\", \"(type='Delete', node=in)\"]","hint":"Near a solution! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{={field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}","totalTED":3,"challenge":"gAeD3MTGCCv8YNTaK","time":44015300,"targetExpr":"adj = ~adj","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { all n : Node | n in n.adj.~adj } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.*(adj+~adj) } pred stonglyConnected { } pred transitive { }","sourceAST":"{all{one of{var0}{sig/Node}}{in{var0/Node}{.{.{var0/Node}{field/adj{set of{sig/Node}}}}{~{field/adj{set of{sig/Node}}}}}}}","nextExpr":"adj = ~adj","sourceExpr":"all n : Node | n in n.adj.~adj","predicate":"undirected","isNewNode":false,"srcDstTED":9,"targetAST":"{={field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}","operations":"[\"(type='Update', node=., value==)\", \"(type='Move', tree='{.{.{var0/Node}{field/adj{set of{sig/Node}}}}{~{field/adj{set of{sig/Node}}}}}', parent=root, position=0)\", \"(type='Move', tree='{field/adj{set of{sig/Node}}}', parent=., position=0)\", \"(type='Delete', node=var0/Node)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Node}}')\", \"(type='Delete', node=var0/Node)\", \"(type='Delete', node=in)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{={field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}","totalTED":9,"challenge":"gAeD3MTGCCv8YNTaK","time":45268700,"targetExpr":"adj = ~adj","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.^(adj+~adj) } pred stonglyConnected { } pred transitive { }","sourceAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{^{+{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}}}}}","nextExpr":"all n:Node | Node in n.*(adj + ~adj)","sourceExpr":"all n : Node | Node in n.^(adj + ~adj)","predicate":"weaklyConnected","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{+{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}}}}}","operations":"[\"(type='Update', node=^, value=*)\"]","hint":"One step away from the solution! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.","nextAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{+{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}}}}}","totalTED":1,"challenge":"gAeD3MTGCCv8YNTaK","time":99584600,"targetExpr":"all n:Node | Node in n.*(adj + ~adj)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Node { adj : set Node } pred undirected { } pred oriented { } pred acyclic { } pred complete { } pred noLoops { } pred weaklyConnected { all n : Node | Node in n.^adj } pred stonglyConnected { } pred transitive { }","sourceAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{^{field/adj{set of{sig/Node}}}}}}}","nextExpr":"all n:Node | Node in n.*(adj + ~adj)","sourceExpr":"all n: Node | Node in n.^adj","predicate":"weaklyConnected","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{+{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}}}}}","operations":"[\"(type='Insert', node=*, parent=., position=1)\", \"(type='Insert', node=+, parent=*, position=0)\", \"(type='TreeInsert', tree='{field/adj{set of{sig/Node}}}', parent=+, position=0)\", \"(type='Update', node=^, value=~)\", \"(type='Move', tree='{^{field/adj{set of{sig/Node}}}}', parent=+, position=1)\"]","hint":"Keep going! Consider adding a reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Node}}{in{sig/Node}{.{var0/Node}{*{+{field/adj{set of{sig/Node}}}{~{field/adj{set of{sig/Node}}}}}}}}}","totalTED":6,"challenge":"gAeD3MTGCCv8YNTaK","time":126283100,"targetExpr":"all n:Node | Node in n.*(adj + ~adj)","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, c: Course | (p in Student => p in c.~enrolled) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{var0/Person}{sig/Student}}{in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all x: Person, y: Course | x in Student => x in y.~enrolled","predicate":"inv1","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=!in)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":2,"challenge":"JDKw8yJZF5fiP3jv3","time":90756800,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p in Professor => p not in Course.~enrolled all p: Person | p in Student => p in Course.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Student}}{in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person | p in Professor => p not in Course.~enrolled all p: Person | p in Student => p in Course.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=AND, position=0)\", \"(type='Update', node=var0, value=var1)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Course, value=var1/Course)\", \"(type='TreeDelete', tree='{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":19,"challenge":"JDKw8yJZF5fiP3jv3","time":106153900,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, c: Course | p = Student => p in c.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{={sig/Student}{var0/Person}}{in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, c: Course | p = Student => p in c.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node==, value=!in)\", \"(type='Update', node=in, value=!in)\", \"(type='Insert', node=var0/Person, parent==, position=0)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":4,"challenge":"JDKw8yJZF5fiP3jv3","time":35876900,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p in Professor => p in p.teaches } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Professor}}{in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","nextExpr":"all p:Person | p not in Student implies no p.enrolled","sourceExpr":"all p: Person | p in Professor => p in p.teaches","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{=>{!in{var0/Person}{sig/Student}}{no{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=no)\", \"(type='Update', node=sig/Professor, value=sig/Student)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{=>{!in{var0/Person}{sig/Student}}{no{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":33271200,"targetExpr":"all p:Person | p not in Student implies no p.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, s: Student, c: Course | p not in s => p not in c } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Course}}{=>{!in{var0/Person}{var1/Person}}{!in{var0/Person}{var2/Course}}}}}}","nextExpr":"all x: Person , y: Course | (x not in Student) implies y not in x.enrolled","sourceExpr":"all p: Person, s: Student, c: Course | p not in s => p not in c","predicate":"inv1","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var2}{sig/Course}}{=>{!in{var0/Person}{var1/Person}}{!in{var0/Person}{var2/Course}}}}', parent=all, position=1)\", \"(type='Update', node=var2, value=var1)\", \"(type='Update', node=var1/Person, value=sig/Student)\", \"(type='Insert', node=var1/Course, parent=!in, position=0)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='Insert', node=field/enrolled, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Update', node=var2/Course, value=sig/Course)\", \"(type='Move', tree='{var2/Course}', parent=set of, position=0)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Student}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":11,"challenge":"JDKw8yJZF5fiP3jv3","time":61625900,"targetExpr":"all x: Person , y: Course | (x not in Student) implies y not in x.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, c: Course | p in Student => p in Course.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{var0/Person}{sig/Student}}{in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, c: Course | p in Student => p in Course.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Course, value=var1/Course)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":3,"challenge":"JDKw8yJZF5fiP3jv3","time":31252600,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, c: Course | (p in Professor => p not in c.~enrolled) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, c: Course | (p in Professor => p not in c.~enrolled)","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Professor, value=sig/Student)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":2,"challenge":"JDKw8yJZF5fiP3jv3","time":29427700,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all s: Student | s in Course.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}","nextExpr":"all x: Person - Student | no x.enrolled","sourceExpr":"all s: Student | s in Course.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}","operations":"[\"(type='Update', node=in, value=no)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=sig/Person, parent=-, position=0)\", \"(type='Move', tree='{sig/Student}', parent=-, position=1)\", \"(type='Update', node=sig/Course, value=var0/Person)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":34150700,"targetExpr":"all x: Person - Student | no x.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, s: Student | p not in s => p not in Course.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Student}}{=>{!in{var0/Person}{var1/Person}}{!in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, s: Student | p not in s => p not in Course.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Update', node=var1/Person, value=sig/Student)\", \"(type='Update', node=sig/Course, value=var1/Course)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":3,"challenge":"JDKw8yJZF5fiP3jv3","time":34694100,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, s: Student, c: Course | p not in s => p not in c.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Course}}{=>{!in{var0/Person}{var1/Person}}{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, s: Student, c: Course | p not in s => p not in c.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var2}{sig/Course}}{=>{!in{var0/Person}{var1/Person}}{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}', parent=all, position=1)\", \"(type='Update', node=var2, value=var1)\", \"(type='Update', node=var1/Person, value=sig/Student)\", \"(type='Update', node=var2/Course, value=var1/Course)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Student}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":38919000,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, s: Student | p not in Student => p not in Course.~enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Student}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{sig/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, s: Student | p not in Student => p not in Course.~enrolled","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Update', node=sig/Course, value=var1/Course)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":2,"challenge":"JDKw8yJZF5fiP3jv3","time":37543900,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person, c: Course | (p in Student => p in c.~enrolled) && (p in Professor => p not in c.~enrolled) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{AND{=>{in{var0/Person}{sig/Student}}{in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","sourceExpr":"all p: Person, c: Course | (p in Student => p in c.~enrolled) && (p in Professor => p not in c.~enrolled)","predicate":"inv1","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{=>{in{var0/Person}{sig/Student}}{in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}', parent=all, position=1)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=!in)\", \"(type='TreeDelete', tree='{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":15,"challenge":"JDKw8yJZF5fiP3jv3","time":38766800,"targetExpr":"all p: Person, c: Course | p not in Student => p not in c.~enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Professor |some (s.teaches & j.teaches) implies no (s.enrolled & j.teaches) } pred inv10 { all p:Person-Student | no p.enrolled->grades } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{->{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}","nextExpr":"all p : (Person-Student) | p not in Course.grades.Grade","sourceExpr":"all p:Person-Student | no p.enrolled->grades","predicate":"inv10","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}}","operations":"[\"(type='Update', node=->, value=!in)\", \"(type='Move', tree='{->{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=all, position=1)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Insert', node=., parent=->, position=1)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Insert', node=sig/Grade, parent=., position=1)\", \"(type='Move', tree='{sig/Course}', parent=., position=0)\", \"(type='Move', tree='{field/grades{->{sig/Person}{sig/Grade}}}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/enrolled)\", \"(type='Delete', node=.)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using arrow operator ('->') to map a relation, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}}","totalTED":8,"challenge":"JDKw8yJZF5fiP3jv3","time":116394300,"targetExpr":"all p : (Person-Student) | p not in Course.grades.Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => (#(p1.enrolled & p2.teaches)=0) } pred inv10 { all p: Person | p in Student => p in Course.grades.Person } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Student}}{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Person}}}}}","nextExpr":"all p : Person | p in Course.grades.Grade implies p in Student","sourceExpr":"all p: Person | p in Student => p in Course.grades.Person","predicate":"inv10","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}","operations":"[\"(type='TreeInsert', tree='{in{var0/Person}{sig/Student}}', parent==>, position=2)\", \"(type='Update', node=sig/Person, value=sig/Grade)\", \"(type='TreeDelete', tree='{in{var0/Person}{sig/Student}}')\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":46582200,"targetExpr":"all p : Person | p in Course.grades.Grade implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Professor |some (s.teaches & j.teaches) implies no (s.enrolled & j.teaches) } pred inv10 { all p:Person-Student | no p.enrolled.grades } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}","nextExpr":"all p : (Person-Student) | p not in Course.grades.Grade","sourceExpr":"all x : Person - Student | no x.enrolled.grades","predicate":"inv10","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}}","operations":"[\"(type='Update', node=., value=!in)\", \"(type='Move', tree='{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=all, position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Insert', node=sig/Grade, parent=., position=1)\", \"(type='Move', tree='{sig/Course}', parent=., position=0)\", \"(type='Move', tree='{field/grades{->{sig/Person}{sig/Grade}}}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/enrolled)\", \"(type='Delete', node=.)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}}","totalTED":8,"challenge":"JDKw8yJZF5fiP3jv3","time":99853100,"targetExpr":"all p : (Person-Student) | p not in Course.grades.Grade","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x: Person - Student | no x.enrolled } pred inv2 { all x: Person - Professor | no x.teaches } pred inv3 { all c: Course | (some p : Professor | c in p.teaches ) } pred inv4 { all p : Project | (one c : Course | p in c.projects) } pred inv5 { all x: Person - Student | no x.projects all p: Project | (some s: Student | p in s.projects) } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student|all c:s.enrolled|lone (c.projects & s.projects) } pred inv8 { all p:Professor|all c:p.enrolled | c not in p.teaches } pred inv9 { all p,p1 : Professor | all c:p.teaches | c not in p1.enrolled } pred inv10 { all s:Professor | all c:s.enrolled | no c.grades } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{no{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}","nextExpr":"all p: Person - Student | all c: Course | no p.(c.grades)","sourceExpr":"all s:Professor | all c:s.enrolled | no c.grades","predicate":"inv10","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{all{one of{var1}{sig/Course}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=sig/Professor, value=sig/Person)\", \"(type='Move', tree='{sig/Professor}', parent=-, position=0)\", \"(type='Insert', node=sig/Student, parent=-, position=1)\", \"(type='Move', tree='{sig/Course}', parent=one of, position=1)\", \"(type='Insert', node=., parent=no, position=0)\", \"(type='Insert', node=var0/Person, parent=., position=0)\", \"(type='Move', tree='{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=., position=1)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/enrolled)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{all{one of{var1}{sig/Course}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","totalTED":9,"challenge":"JDKw8yJZF5fiP3jv3","time":37528300,"targetExpr":"all p: Person - Student | all c: Course | no p.(c.grades)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => (#(p1.enrolled & p2.teaches)=0) } pred inv10 { all p: Person | p not in Student => p not in Course.grades.Person } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{!in{var0/Person}{sig/Student}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Person}}}}}","nextExpr":"all p:(Person-Student) | p not in Course.grades.Grade","sourceExpr":"all p: Person | p not in Student => p not in Course.grades.Person","predicate":"inv10","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}}","operations":"[\"(type='Move', tree='{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Person}}}', parent=all, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/Person}', parent=-, position=0)\", \"(type='Insert', node=sig/Student, parent=-, position=1)\", \"(type='Update', node=sig/Person, value=sig/Grade)\", \"(type='TreeDelete', tree='{!in{var0/Person}{sig/Student}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! It seems like the exclusion operator ('!in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{-{sig/Person}{sig/Student}}}{!in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":34757500,"targetExpr":"all p:(Person-Student) | p not in Course.grades.Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student all p:Project| (some x:Student| x->p in projects) } pred inv6 { all x:Student, c:Course, p:Project| x->p in projects and c->p in projects implies x->c in enrolled } pred inv7 { all x:Student, c:Course, p,y:Project| x->p in projects and x->y in projects and c->p in projects and c->y in projects implies p=y } pred inv8 { all x:Professor, c:Course| x->c in teaches implies x->c not in enrolled } pred inv9 { all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches)) } pred inv10 { all x:Person, c:Course, g:Grade| c->x->g in grades implies x in Student } pred inv11 { all x:Student, c:Course, g:Grade| c->x->g in grades implies x->c in enrolled } pred inv12 { all c:Course, x:Student| (some g,y:Grade | c->x->g in grades and c->x->y in grades implies g = y) } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Grade}}{some{one of{var3}{sig/Grade}}{=>{AND{in{->{var0/Course}{->{var1/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var0/Course}{->{var1/Person}{var3/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{={var2/Grade}{var3/Grade}}}}}}}","nextExpr":"all x:Person, c:Course, g,u:Grade| c->x->g in grades and c->x->u in grades implies g=u","sourceExpr":"all c:Course, x:Student| (some g,y:Grade | c->x->g in grades and c->x->y in grades implies g = y)","predicate":"inv12","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{all{one of{var3}{sig/Grade}}{=>{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var1/Course}{->{var0/Person}{var3/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{={var2/Grade}{var3/Grade}}}}}}}","operations":"[\"(type='Update', node=sig/Course, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=var0/Course, value=var1/Course)\", \"(type='Update', node=var0/Course, value=var1/Course)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Course, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{all{one of{var3}{sig/Grade}}{=>{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var1/Course}{->{var0/Person}{var3/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{={var2/Grade}{var3/Grade}}}}}}}","totalTED":8,"challenge":"JDKw8yJZF5fiP3jv3","time":113301600,"targetExpr":"all x:Person, c:Course, g,u:Grade| c->x->g in grades and c->x->u in grades implies g=u","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student all p:Project| (some x:Student| x->p in projects) } pred inv6 { all x:Student, c:Course, p:Project| x->p in projects and c->p in projects implies x->c in enrolled } pred inv7 { all x:Student, c:Course, p,y:Project| x->p in projects and x->y in projects and c->p in projects and c->y in projects implies p=y } pred inv8 { all x:Professor, c:Course| x->c in teaches implies x->c not in enrolled } pred inv9 { all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches)) } pred inv10 { all x:Person, c:Course, g:Grade| c->x->g in grades implies x in Student } pred inv11 { all x:Student, c:Course, g:Grade| c->x->g in grades implies x->c in enrolled } pred inv12 { all c:Course, x:Student| (lone g:Grade | c->x->g in grades) } pred inv13 { } pred inv14 { all x,y,z:Student, p,g:Project| x->p in projects and y->p in projects implies z->g in projects and x->g in projects } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Project}}{all{one of{var4}{sig/Project}}{=>{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{AND{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","nextExpr":"(all ref0,ref1:(one Student),ref2,ref3:(one Project)|((((ref0 -> ref2) in (Person <: projects)) && ((ref0 -> ref3) in (Person <: projects)) && ((ref1 -> ref2) in (Person <: projects)) && (ref0 != ref1) && (ref2 != ref3)) => ((ref1 -> ref3) !in (Person <: projects))))","sourceExpr":"all x,y,z:Student, p,g:Project| x->p in projects and y->p in projects implies z->g in projects and x->g in projects","predicate":"inv14","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Update', node=all, value==>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{->{var0/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}', parent=all, position=1)\", \"(type='Update', node=one of, value=!=)\", \"(type='Move', tree='{one of{var4}{sig/Project}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Move', tree='{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=4)\", \"(type='Update', node=var4, value=var0/Person)\", \"(type='Update', node=sig/Project, value=var1/Person)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var4/Project, value=var3/Project)\", \"(type='Update', node=var3/Project, value=var2/Project)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var4/Project, value=var2/Project)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=AND)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Project to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":19,"challenge":"JDKw8yJZF5fiP3jv3","time":123928700,"targetExpr":"(all ref0,ref1:(one Student),ref2,ref3:(one Project)|((((ref0 -> ref2) in (Person <: projects)) && ((ref0 -> ref3) in (Person <: projects)) && ((ref1 -> ref2) in (Person <: projects)) && (ref0 != ref1) && (ref2 != ref3)) => ((ref1 -> ref3) !in (Person <: projects))))","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student all p:Project| (some x:Student| x->p in projects) } pred inv6 { all x:Student, c:Course, p:Project| x->p in projects and c->p in projects implies x->c in enrolled } pred inv7 { all x:Student, c:Course, p,y:Project| x->p in projects and x->y in projects and c->p in projects and c->y in projects implies p=y } pred inv8 { all x:Professor, c:Course| x->c in teaches implies x->c not in enrolled } pred inv9 { all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches)) } pred inv10 { all x:Person, c:Course, g:Grade| c->x->g in grades implies x in Student } pred inv11 { all x:Student, c:Course, g:Grade| c->x->g in grades implies x->c in enrolled } pred inv12 { all c:Course, x:Student| (lone g:Grade | c->x->g in grades) } pred inv13 { } pred inv14 { all x,y,z:Student, p,g:Project| x->p in projects and y->p in projects implies z->g in projects and x->g in projects implies z!=y } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Project}}{all{one of{var4}{sig/Project}}{=>{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{=>{AND{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}}{!={var1/Person}{var2/Person}}}}}}}}}","nextExpr":"(all ref0,ref1:(one Student),ref2,ref3:(one Project)|((((ref0 -> ref2) in (Person <: projects)) && ((ref0 -> ref3) in (Person <: projects)) && ((ref1 -> ref2) in (Person <: projects)) && (ref0 != ref1) && (ref2 != ref3)) => ((ref1 -> ref3) !in (Person <: projects))))","sourceExpr":"all x,y,z:Student, p,g:Project| x->p in projects and y->p in projects implies z->g in projects and x->g in projects implies z!=y","predicate":"inv14","isNewNode":true,"srcDstTED":23,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Update', node=all, value==>)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{->{var0/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}', parent=all, position=1)\", \"(type='Update', node=one of, value=!=)\", \"(type='Move', tree='{one of{var4}{sig/Project}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Move', tree='{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=4)\", \"(type='Update', node=var4, value=var0/Person)\", \"(type='Update', node=sig/Project, value=var1/Person)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var4/Project, value=var3/Project)\", \"(type='Update', node=var3/Project, value=var2/Project)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var4/Project, value=var2/Project)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{!={var2/Person}{var1/Person}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Project to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":23,"challenge":"JDKw8yJZF5fiP3jv3","time":41059700,"targetExpr":"(all ref0,ref1:(one Student),ref2,ref3:(one Project)|((((ref0 -> ref2) in (Person <: projects)) && ((ref0 -> ref3) in (Person <: projects)) && ((ref1 -> ref2) in (Person <: projects)) && (ref0 != ref1) && (ref2 != ref3)) => ((ref1 -> ref3) !in (Person <: projects))))","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Professor |some (s.teaches & j.teaches) implies no (s.enrolled & j.teaches) } pred inv10 { all c:Course , p:Person , g:Grade | p->g in c.grades implies p in Student } pred inv11 { all c:Course, p:Person,g:Grade | p->g in c.grades implies c in p.enrolled } pred inv12 { all c:Course, p:Person| lone g:Grade | p->g in c.grades } pred inv13 { } pred inv14 { all disj s,ss:Student | no s.projects & ss.projects } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Student}}{all{disj}{one of{var1}{sig/Student}}{no{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Person}{field/projects{set of{sig/Project}}}}}}}}","nextExpr":"all disj s1,s2 : Student | lone s1.projects & s2.projects","sourceExpr":"all disj s,ss:Student | no s.projects & ss.projects","predicate":"inv14","isNewNode":true,"srcDstTED":1,"targetAST":"{all{disj}{one of{var0}{sig/Student}}{all{disj}{one of{var1}{sig/Student}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Person}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=no, value=lone)\"]","hint":"One step away from the solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{disj}{one of{var0}{sig/Student}}{all{disj}{one of{var1}{sig/Student}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Person}{field/projects{set of{sig/Project}}}}}}}}","totalTED":1,"challenge":"JDKw8yJZF5fiP3jv3","time":41399800,"targetExpr":"all disj s1,s2 : Student | lone s1.projects & s2.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student all p:Project| (some x:Student| x->p in projects) } pred inv6 { all x:Student, c:Course, p:Project| x->p in projects and c->p in projects implies x->c in enrolled } pred inv7 { all x:Student, c:Course, p,y:Project| x->p in projects and x->y in projects and c->p in projects and c->y in projects implies p=y } pred inv8 { all x:Professor, c:Course| x->c in teaches implies x->c not in enrolled } pred inv9 { all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches)) } pred inv10 { all x:Person, c:Course, g:Grade| c->x->g in grades implies x in Student } pred inv11 { all x:Student, c:Course, g:Grade| c->x->g in grades implies x->c in enrolled } pred inv12 { all c:Course, x:Student| (lone g:Grade | c->x->g in grades) } pred inv13 { } pred inv14 { all x:Student, y:Student-x, p:Project, g:Project-p| x->p in projects and y->p in projects and x->g in projects implies y->g not in projects } pred inv15 { all x:Student, y:Student-x, p:Project, c:Course, g:Grade| x->p in projects and y->p in projects and c->x->g in grades implies #c->y->g <= 1 }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{-{sig/Student}{var0/Person}}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Course}}{all{one of{var4}{sig/Grade}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{->{var0/Person}{var4/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{<={#{->{var3/Course}{->{var1/Person}{var4/Grade}}}}{1}}}}}}}}","nextExpr":"all s1,s2: Student | all p: Project | all c: Course | all g1,g2: Grade | s1->p in projects and s2->p in projects and c->p in projects and c->s1->g1 in grades and c->s2->g2 in grades => g1 = g2 or g1 = prev[g2] or g2 = prev[g1]","sourceExpr":"all x:Student, y:Student-x, p:Project, c:Course, g:Grade| x->p in projects and y->p in projects and c->x->g in grades implies #c->y->g <= 1","predicate":"inv15","isNewNode":true,"srcDstTED":50,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Course}}{all{one of{var4}{sig/Grade}}{all{one of{var5}{sig/Grade}}{OR{={.{var5/Grade}{field{~{.{ordering/Ord}{field/Next{->{sig/Grade}{sig/Grade}}}}}}}{var4/Grade}}{={.{var4/Grade}{field{~{.{ordering/Ord}{field/Next{->{sig/Grade}{sig/Grade}}}}}}}{var5/Grade}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{->{var0/Person}{var4/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var3/Course}{->{var1/Person}{var5/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{={var4/Grade}{var5/Grade}}}}}}}}}}","operations":"[\"(type='Move', tree='{sig/Student}', parent=one of, position=1)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var5}{sig/Grade}}', parent=all, position=0)\", \"(type='Insert', node=OR, parent=all, position=1)\", \"(type='TreeInsert', tree='{={.{var5/Grade}{field{~{.{ordering/Ord}{field/Next{->{sig/Grade}{sig/Grade}}}}}}}{var4/Grade}}', parent=OR, position=0)\", \"(type='TreeInsert', tree='{={.{var4/Grade}{field{~{.{ordering/Ord}{field/Next{->{sig/Grade}{sig/Grade}}}}}}}{var5/Grade}}', parent=OR, position=1)\", \"(type='Move', tree='{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{->{var0/Person}{var4/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{<={#{->{var3/Course}{->{var1/Person}{var4/Grade}}}}{1}}}', parent=OR, position=2)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Insert', node==, parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=1)\", \"(type='TreeInsert', tree='{in{->{var3/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var3/Course}{->{var0/Person}{var4/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=AND, position=3)\", \"(type='Update', node=#, value=in)\", \"(type='Move', tree='{#{->{var3/Course}{->{var1/Person}{var4/Grade}}}}', parent=AND, position=4)\", \"(type='Update', node=1, value=var4/Grade)\", \"(type='Move', tree='{1}', parent==, position=0)\", \"(type='Insert', node=var5/Grade, parent==, position=1)\", \"(type='TreeInsert', tree='{field/grades{->{sig/Person}{sig/Grade}}}', parent=#, position=1)\", \"(type='Update', node=var4/Grade, value=var5/Grade)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=-)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=)\"]","hint":"Keep going! It seems like the signature of type Student is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Course}}{all{one of{var4}{sig/Grade}}{all{one of{var5}{sig/Grade}}{OR{={.{var5/Grade}{field{~{.{ordering/Ord}{field/Next{->{sig/Grade}{sig/Grade}}}}}}}{var4/Grade}}{={.{var4/Grade}{field{~{.{ordering/Ord}{field/Next{->{sig/Grade}{sig/Grade}}}}}}}{var5/Grade}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{->{var0/Person}{var4/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var3/Course}{->{var1/Person}{var5/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{={var4/Grade}{var5/Grade}}}}}}}}}}","totalTED":50,"challenge":"JDKw8yJZF5fiP3jv3","time":135339400,"targetExpr":"all s1,s2: Student | all p: Project | all c: Course | all g1,g2: Grade | s1->p in projects and s2->p in projects and c->p in projects and c->s1->g1 in grades and c->s2->g2 in grades => g1 = g2 or g1 = prev[g2] or g2 = prev[g1]","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course, p: Professor | p in c.~teaches } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Professor}}{in{var1/Person}{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}}}}","nextExpr":"all c: Course | some p : Professor | c in p.teaches","sourceExpr":"all c: Course, p: Professor | p in c.~teaches","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=var1/Person, value=var0/Course)\", \"(type='Update', node=var0/Course, value=var1/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","totalTED":4,"challenge":"JDKw8yJZF5fiP3jv3","time":123976100,"targetExpr":"all c: Course | some p : Professor | c in p.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c: Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course, p:Person | c in p.teaches } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Person}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","nextExpr":"all c:Course | some p:Person | c in p.teaches","sourceExpr":"all c : Course, p : Person | c in p.teaches","predicate":"inv3","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Person}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\"]","hint":"One step away from the solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Person}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","totalTED":1,"challenge":"JDKw8yJZF5fiP3jv3","time":86206800,"targetExpr":"all c:Course | some p:Person | c in p.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { some x:Person|all c:Course| x->c in teaches } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"all c1: Course | some p1 : Person | p1->c1 in teaches","sourceExpr":"some u:Person|all c:Course| u->c in teaches","predicate":"inv3","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Person)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Course, value=var0/Course)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":46432400,"targetExpr":"all c1: Course | some p1 : Person | p1->c1 in teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { some x:Professor|all c:Course| x->c in teaches } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"all c:Course| (some x:Professor| x->c in teaches)","sourceExpr":"some p:Professor| all c:Course|p->c in teaches","predicate":"inv3","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Course, value=var0/Course)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":40795500,"targetExpr":"all c:Course| (some x:Professor| x->c in teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course, p: Professor | #c.~teaches>0 } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Professor}}{>{#{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}}{0}}}}","nextExpr":"all y: Course | #(y.~teaches)>0","sourceExpr":"all c: Course, p: Professor | #c.~teaches>0","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Course}}{>{#{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}}{0}}}","operations":"[\"(type='Move', tree='{>{#{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}}{0}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Professor}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the greater than operator ('>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Course}}{>{#{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}}{0}}}","totalTED":4,"challenge":"JDKw8yJZF5fiP3jv3","time":38575900,"targetExpr":"all y: Course | #(y.~teaches)>0","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { some x:Person, c:Course| x->c in teaches } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"all c:Course| (some x:Professor| x->c in teaches)","sourceExpr":"some x:Person, c:Course| x->c in teaches","predicate":"inv3","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Course, value=var0/Course)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":38078500,"targetExpr":"all c:Course| (some x:Professor| x->c in teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all p: Professor | #p.teaches > 0 } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{>{#{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{0}}}","nextExpr":"all c : Course | #(teaches.c) > 0","sourceExpr":"all p: Professor | #p.teaches > 0","predicate":"inv3","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Course}}{>{#{.{field/teaches{set of{sig/Course}}}{var0/Course}}}{0}}}","operations":"[\"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Insert', node=var0/Course, parent=., position=2)\", \"(type='Delete', node=var0/Person)\"]","hint":"Near a solution! Instead of using signature of type Professor, try using signature of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Course}}{>{#{.{field/teaches{set of{sig/Course}}}{var0/Course}}}{0}}}","totalTED":3,"challenge":"JDKw8yJZF5fiP3jv3","time":50137600,"targetExpr":"all c : Course | #(teaches.c) > 0","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { some p:Project| (one c:Course| c->p in projects) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all p:Project| one c:Course| c->p in projects","sourceExpr":"some p:Project|one c:Course| c->p in projects","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","totalTED":1,"challenge":"JDKw8yJZF5fiP3jv3","time":100118600,"targetExpr":"all p:Project| one c:Course| c->p in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches > 0 } pred inv4 { all pr: Project | one c : Course | pr in Course.projects } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{var0/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all p : Project | one c : Course | p in c.projects","sourceExpr":"all pr: Project | one c : Course | pr in Course.projects","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{var0/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Update', node=sig/Course, value=var1/Course)\"]","hint":"One step away from the solution! Instead of using signature of type Course, try using variable of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{var0/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","totalTED":1,"challenge":"JDKw8yJZF5fiP3jv3","time":74872000,"targetExpr":"all p : Project | one c : Course | p in c.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches > 0 } pred inv4 { all pr: Project | pr in Course.projects } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{in{var0/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all p : Project | one c : Course | p in c.projects","sourceExpr":"all p:Project | p in Course.projects","predicate":"inv4","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{var0/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Insert', node=one, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Course}}', parent=one, position=0)\", \"(type='Move', tree='{in{var0/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}', parent=one, position=1)\", \"(type='Update', node=sig/Course, value=var1/Course)\"]","hint":"Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{var0/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":63433000,"targetExpr":"all p : Project | one c : Course | p in c.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person, pr: Project | (p not in Student => pr not in p.projects) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{!in{var0/Person}{sig/Student}}{!in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","nextExpr":"all s : Person - Student| no s.projects all p : Project | some s : Student | p in s.projects","sourceExpr":"all p: Person, pr: Project | (p not in Student => pr not in p.projects)","predicate":"inv5","isNewNode":true,"srcDstTED":14,"targetAST":"{AND{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{all{one of{var1}{sig/Project}}{some{one of{var0}{sig/Student}}{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='TreeInsert', tree='{no{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent=all, position=1)\", \"(type='Update', node==>, value=some)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=!in, value=one of)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{sig/Person}', parent=-, position=0)\", \"(type='Insert', node=sig/Student, parent=-, position=1)\", \"(type='Update', node=var0/Person, value=var0)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{all{one of{var1}{sig/Project}}{some{one of{var0}{sig/Student}}{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","totalTED":14,"challenge":"JDKw8yJZF5fiP3jv3","time":115397300,"targetExpr":"all s : Person - Student| no s.projects all p : Project | some s : Student | p in s.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | p not in Student => p.projects = none all p: Project | some m: Person | m.projects = p } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{=>{!in{var0/Person}{sig/Student}}{={.{var0/Person}{field/projects{set of{sig/Project}}}}{none}}}}{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{={.{var1/Person}{field/projects{set of{sig/Project}}}}{var0/Project}}}}}","nextExpr":"all x:Person | x not in Student implies #(x.projects)=0 all x:Project | some y:Person | x in y.projects","sourceExpr":"all p: Person | p not in Student => p.projects = none all p: Project | some m: Person | m.projects = p","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{AND{all{one of{var0}{sig/Person}}{=>{!in{var0/Person}{sig/Student}}{={#{.{var0/Person}{field/projects{set of{sig/Project}}}}}{0}}}}{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{var0/Project}{.{var1/Person}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=#, parent==, position=0)\", \"(type='Update', node=none, value=0)\", \"(type='Insert', node=var0/Project, parent==, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/projects{set of{sig/Project}}}}', parent=#, position=0)\", \"(type='Delete', node=var0/Project)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{AND{all{one of{var0}{sig/Person}}{=>{!in{var0/Person}{sig/Student}}{={#{.{var0/Person}{field/projects{set of{sig/Project}}}}}{0}}}}{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{var0/Project}{.{var1/Person}{field/projects{set of{sig/Project}}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":81776000,"targetExpr":"all x:Person | x not in Student implies #(x.projects)=0 all x:Project | some y:Person | x in y.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | proj in p.projects implies p in Student and (some p1:Person | proj in p1.enrolled) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var0/Person}{sig/Student}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","sourceExpr":"all p:Person, proj:Project | proj in p.projects implies p in Student and (some p1:Person | proj in p1.enrolled)","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\", \"(type='Insert', node==>, parent==>, position=0)\", \"(type='Move', tree='{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent==>, position=1)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":49530600,"targetExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Student| (some p:Project| x->p in projects) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{some{one of{var1}{sig/Project}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}","nextExpr":"no (Person - Student).projects && Project in Student.projects","sourceExpr":"all x:Student| (some p:Project| x->p in projects)","predicate":"inv5","isNewNode":true,"srcDstTED":14,"targetAST":"{AND{in{sig/Project}{.{sig/Student}{field/projects{set of{sig/Project}}}}}{no{.{-{sig/Person}{sig/Student}}{field/projects{set of{sig/Project}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=in, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=var0, value=sig/Project)\", \"(type='Move', tree='{var0}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}', parent=no, position=0)\", \"(type='Move', tree='{sig/Student}', parent=., position=0)\", \"(type='Insert', node=field/projects, parent=., position=1)\", \"(type='Update', node=->, value=-)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var1}{sig/Project}}', parent=field/projects, position=0)\", \"(type='Update', node=var0/Person, value=sig/Person)\", \"(type='Update', node=var1/Project, value=sig/Student)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{sig/Project}{.{sig/Student}{field/projects{set of{sig/Project}}}}}{no{.{-{sig/Person}{sig/Student}}{field/projects{set of{sig/Project}}}}}}","totalTED":14,"challenge":"JDKw8yJZF5fiP3jv3","time":37236400,"targetExpr":"no (Person - Student).projects && Project in Student.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | proj in p.projects implies p in Student and (some p1:Person | proj in p1.projects) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var0/Person}{sig/Student}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","sourceExpr":"all p:Person, proj:Project | proj in p.projects implies p in Student and (some p1:Person | proj in p1.projects)","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\", \"(type='Insert', node==>, parent==>, position=0)\", \"(type='Move', tree='{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent==>, position=1)\", \"(type='Delete', node=AND)\"]","hint":"Near a solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":3,"challenge":"JDKw8yJZF5fiP3jv3","time":44262100,"targetExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Student, p:Project| x->p in projects } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}","nextExpr":"no (Person - Student).projects && Project in Student.projects","sourceExpr":"all x:Student, p:Project| x->p in projects","predicate":"inv5","isNewNode":true,"srcDstTED":14,"targetAST":"{AND{in{sig/Project}{.{sig/Student}{field/projects{set of{sig/Project}}}}}{no{.{-{sig/Person}{sig/Student}}{field/projects{set of{sig/Project}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=in, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=var0, value=sig/Project)\", \"(type='Move', tree='{var0}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}', parent=no, position=0)\", \"(type='Move', tree='{sig/Student}', parent=., position=0)\", \"(type='Insert', node=field/projects, parent=., position=1)\", \"(type='Update', node=->, value=-)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var1}{sig/Project}}', parent=field/projects, position=0)\", \"(type='Update', node=var0/Person, value=sig/Person)\", \"(type='Update', node=var1/Project, value=sig/Student)\", \"(type='Delete', node=var1)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{in{sig/Project}{.{sig/Student}{field/projects{set of{sig/Project}}}}}{no{.{-{sig/Person}{sig/Student}}{field/projects{set of{sig/Project}}}}}}","totalTED":14,"challenge":"JDKw8yJZF5fiP3jv3","time":43315800,"targetExpr":"no (Person - Student).projects && Project in Student.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person, pr: Project | (p in Student => pr in p.projects) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{var0/Person}{sig/Student}}{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","nextExpr":"all s : Person - Student| no s.projects all p : Project | some s : Student | p in s.projects","sourceExpr":"all p: Person, pr: Project | (p in Student => pr in p.projects)","predicate":"inv5","isNewNode":true,"srcDstTED":13,"targetAST":"{AND{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{all{one of{var1}{sig/Project}}{some{one of{var0}{sig/Student}}{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='TreeInsert', tree='{no{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent=all, position=1)\", \"(type='Update', node==>, value=some)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=in, value=one of)\", \"(type='Move', tree='{sig/Person}', parent=-, position=0)\", \"(type='Insert', node=sig/Student, parent=-, position=1)\", \"(type='Update', node=var0/Person, value=var0)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{all{one of{var1}{sig/Project}}{some{one of{var0}{sig/Student}}{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","totalTED":13,"challenge":"JDKw8yJZF5fiP3jv3","time":43208500,"targetExpr":"all s : Person - Student| no s.projects all p : Project | some s : Student | p in s.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | proj in p.projects implies p in Student and (some p1:Person | proj in p.enrolled) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var0/Person}{sig/Student}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","sourceExpr":"all p:Person, proj:Project | proj in p.projects implies p in Student and (some p1:Person | proj in p.enrolled)","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\", \"(type='Insert', node==>, parent==>, position=0)\", \"(type='Move', tree='{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent==>, position=1)\", \"(type='Update', node=var0/Person, value=var2/Person)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":42310800,"targetExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student some x:Student| all p:Project| x->p in projects } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{var0/Person}{sig/Student}}}}}{some{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all x:Person| all p:Project| x->p in projects implies x in Student all p:Project| (some x:Student | x->p in projects)","sourceExpr":"all x:Person, p:Project| x->p in projects implies x in Student some x:Student| all p:Project| x->p in projects","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{AND{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{var0/Person}{sig/Student}}}}}{all{one of{var1}{sig/Project}}{some{one of{var0}{sig/Student}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=var0, value=var1)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=sig/Project, value=sig/Student)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{AND{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{var0/Person}{sig/Student}}}}}{all{one of{var1}{sig/Project}}{some{one of{var0}{sig/Student}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":51700100,"targetExpr":"all x:Person| all p:Project| x->p in projects implies x in Student all p:Project| (some x:Student | x->p in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | proj in p.projects implies p in Student and (some p:Person | proj in p.enrolled) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var0/Person}{sig/Student}}{some{one of{var0}{sig/Person}}{in{var1/Project}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","sourceExpr":"all p:Person, proj:Project | proj in p.projects implies p in Student and (some p:Person | proj in p.enrolled)","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\", \"(type='Insert', node==>, parent==>, position=0)\", \"(type='Move', tree='{some{one of{var0}{sig/Person}}{in{var1/Project}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent==>, position=1)\", \"(type='Update', node=var0, value=var2)\", \"(type='Update', node=var0/Person, value=var2/Person)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{AND{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{sig/Student}}}{some{one of{var2}{sig/Person}}{in{var1/Project}{.{var2/Person}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":39396600,"targetExpr":"all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p2 : Person | proj in p2.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p1:Person | proj in p1.projects) } pred inv6 { all s:Student, c:Course, p:Project | p in s.projects implies p in c.projects and c in s.enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","sourceExpr":"all s:Student, c:Course, p:Project | p in s.projects implies p in c.projects and c in s.enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Project, value=var1/Course)\", \"(type='Update', node=var1/Course, value=var2/Project)\", \"(type='Update', node=var1/Course, value=var0/Person)\", \"(type='Update', node=field/projects, value=field/enrolled)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=AND)\"]","hint":"Near a solution! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":2,"challenge":"JDKw8yJZF5fiP3jv3","time":117098500,"targetExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c: Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course |some p:Person | c in p.teaches } pred inv4 { all p:Project |one c:Course | p in c.projects } pred inv5 { all x: Person - Student | no x.projects all p: Project | (some s: Student | p in s.projects) } pred inv6 { all s:Person-Professor | all c:Course | all p:c.projects | p in s.projects implies c in p.enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{-{sig/Person}{sig/Professor}}}{all{one of{var1}{sig/Course}}{all{one of{var2}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{=>{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var2/Project}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all per : Person | all c : Course | all pro : Project | (pro in per.projects and pro in c.projects) implies c in per.enrolled","sourceExpr":"all s:Person-Professor | all c:Course | all p:c.projects | p in s.projects implies c in p.enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{sig/Person}', parent=one of, position=1)\", \"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{var2}', parent=one of, position=0)\", \"(type='Insert', node=sig/Project, parent=one of, position=1)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{var1/Course}{.{var2/Project}{field/enrolled{set of{sig/Course}}}}}', parent==>, position=1)\", \"(type='Insert', node=in, parent=AND, position=0)\", \"(type='Move', tree='{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent=AND, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var1/Course}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\", \"(type='Update', node=var2/Project, value=var0/Person)\", \"(type='Update', node=var1/Course, value=var0/Person)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Delete', node=sig/Professor)\", \"(type='Delete', node=-)\", \"(type='Delete', node=one of)\", \"(type='Delete', node==>)\"]","hint":"Keep going! It seems like the signature of type Person is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":13,"challenge":"JDKw8yJZF5fiP3jv3","time":41988700,"targetExpr":"all per : Person | all c : Course | all pro : Project | (pro in per.projects and pro in c.projects) implies c in per.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student, c: Course | s.projects in c.projects => s in c.~enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","sourceExpr":"all s: Student, c: Course | s.projects in c.projects => s in c.~enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Project}}', parent=all, position=0)\", \"(type='Move', tree='{=>{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var0/Person}{.{var1/Course}{~{field/enrolled{set of{sig/Course}}}}}}}', parent=all, position=1)\", \"(type='Update', node=in, value=AND)\", \"(type='Insert', node=in, parent=in, position=0)\", \"(type='Insert', node=in, parent=in, position=1)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var1/Course}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\", \"(type='Update', node=var1/Course, value=var0/Person)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=~)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Project\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":12,"challenge":"JDKw8yJZF5fiP3jv3","time":37707700,"targetExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c: Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course |some p:Person | c in p.teaches } pred inv4 { all p:Project |one c:Course | p in c.projects } pred inv5 { all x: Person - Student | no x.projects all p: Project | (some s: Student | p in s.projects) } pred inv6 { all s:Person-Professor | all c:Course | all p:Project | p in s.projects implies p in c.projects and c in s.enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{-{sig/Person}{sig/Professor}}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all per : Person | all c : Course | all pro : Project | (pro in per.projects and pro in c.projects) implies c in per.enrolled","sourceExpr":"all s:Person-Professor | all c:Course | all p:Project | p in s.projects implies p in c.projects and c in s.enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{sig/Person}', parent=one of, position=1)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Project, value=var1/Course)\", \"(type='Update', node=var1/Course, value=var2/Project)\", \"(type='Update', node=var1/Course, value=var0/Person)\", \"(type='Update', node=field/projects, value=field/enrolled)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=sig/Professor)\", \"(type='Delete', node=-)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the signature of type Person is not in the right place. Try moving it to the inside of the unique quantifier ('one') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":4,"challenge":"JDKw8yJZF5fiP3jv3","time":53534500,"targetExpr":"all per : Person | all c : Course | all pro : Project | (pro in per.projects and pro in c.projects) implies c in per.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all pe:Student | all c:Course | (pe.projects=c.projects) implies c in pe.enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{={.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","sourceExpr":"all pe:Student | all c:Course | (pe.projects=c.projects) implies c in pe.enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Project}}', parent=all, position=0)\", \"(type='Move', tree='{=>{={.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}', parent=all, position=1)\", \"(type='Update', node==, value=AND)\", \"(type='Insert', node=in, parent==, position=0)\", \"(type='Insert', node=in, parent==, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var1/Course}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Project\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":9,"challenge":"JDKw8yJZF5fiP3jv3","time":73885500,"targetExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all p:Student | all c:Course | p.projects in c.projects implies c in p.enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","sourceExpr":"all s : Student, c : Course | s.projects in c.projects implies c in s.enrolled","predicate":"inv6","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Project}}', parent=all, position=0)\", \"(type='Move', tree='{=>{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}', parent=all, position=1)\", \"(type='Update', node=in, value=AND)\", \"(type='Insert', node=in, parent=in, position=0)\", \"(type='Insert', node=in, parent=in, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Move', tree='{.{var1/Course}{field/projects{set of{sig/Project}}}}', parent=in, position=1)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Project\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":9,"challenge":"JDKw8yJZF5fiP3jv3","time":111885700,"targetExpr":"all s: Student | all c: Course | all p: Project | p in s.projects && p in c.projects => c in s.enrolled","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { all s:Student|(all c:s.enrolled|one c.projects) } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{one{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all s : Student | all c: s.enrolled | lone c.projects","sourceExpr":"all x : Student | all y : x.enrolled | one y.projects","predicate":"inv7","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{lone{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=one, value=lone)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{lone{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":106735600,"targetExpr":"all s: Student | (all c : s.enrolled | lone (c.projects & s.projects) )","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p1:Person | proj in p1.projects) } pred inv6 { all s:Student, p:Project | p in s.projects implies (some c:Course | p in c.projects and c in s.enrolled) } pred inv7 { all s:Student, c:Course | lone p:Project | p in s.projects implies p in c.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{one of{var2}{sig/Project}}{=>{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","nextExpr":"all s:Student, c:Course | lone proj:Project | proj in s.projects and proj in c.projects","sourceExpr":"all s:Student, c:Course | lone p:Project | p in s.projects implies p in c.projects","predicate":"inv7","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{one of{var2}{sig/Project}}{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{one of{var2}{sig/Project}}{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":1,"challenge":"JDKw8yJZF5fiP3jv3","time":76201400,"targetExpr":"all s:Student, c:Course | lone proj:Project | proj in s.projects and proj in c.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | one p: Project | p in s.enrolled.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{one{one of{var1}{sig/Project}}{in{var1/Project}{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all s: Student | (all c : s.enrolled | lone (c.projects & s.projects) )","sourceExpr":"all s : Student | one p : Project | p in s.enrolled.projects","predicate":"inv7","isNewNode":false,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{lone{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=in, value=lone)\", \"(type='Insert', node=., parent=one of, position=1)\", \"(type='Update', node=., value=&)\", \"(type='Update', node=sig/Project, value=var0/Person)\", \"(type='Move', tree='{sig/Project}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Insert', node=var0/Person, parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=var1/Project)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{lone{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}}}","totalTED":14,"challenge":"JDKw8yJZF5fiP3jv3","time":57720700,"targetExpr":"all s: Student | (all c : s.enrolled | lone (c.projects & s.projects) )","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | lone p: Project | s.enrolled.projects in p } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{lone{one of{var1}{sig/Project}}{in{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}{var1/Project}}}}","nextExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","sourceExpr":"all s: Student | lone p: Project | s.enrolled.projects in p","predicate":"inv7","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=lone, value=all)\", \"(type='Update', node=in, value=lone)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=., value=&)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Insert', node=var1/Course, parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=var1/Project)\"]","hint":"Keep going! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","totalTED":9,"challenge":"JDKw8yJZF5fiP3jv3","time":62225500,"targetExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | lone c: Course | s.projects in c.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{lone{one of{var1}{sig/Course}}{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","sourceExpr":"all s: Student | lone c: Course | s.projects in c.projects","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=lone, value=all)\", \"(type='Insert', node=lone, parent=lone, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}', parent=lone, position=0)\"]","hint":"Near a solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","totalTED":3,"challenge":"JDKw8yJZF5fiP3jv3","time":42030400,"targetExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | lone s.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{lone{.{var0/Person}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","sourceExpr":"all s: Student | lone s.projects","predicate":"inv7","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Course}}', parent=all, position=0)\", \"(type='Move', tree='{lone{.{var0/Person}{field/projects{set of{sig/Project}}}}}', parent=all, position=1)\", \"(type='Insert', node=&, parent=lone, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/projects{set of{sig/Project}}}}', parent=&, position=0)\", \"(type='TreeInsert', tree='{.{var1/Course}{field/projects{set of{sig/Project}}}}', parent=&, position=1)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","totalTED":10,"challenge":"JDKw8yJZF5fiP3jv3","time":50591700,"targetExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | #s.projects<2 } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{<{#{.{var0/Person}{field/projects{set of{sig/Project}}}}}{2}}}","nextExpr":"all p : Student, c : Course | #c.projects&p.projects<2","sourceExpr":"all s: Student | #s.projects<2","predicate":"inv7","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{<{#{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{2}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Course}}', parent=all, position=0)\", \"(type='Move', tree='{<{#{.{var0/Person}{field/projects{set of{sig/Project}}}}}{2}}', parent=all, position=1)\", \"(type='Insert', node=&, parent=#, position=0)\", \"(type='TreeInsert', tree='{.{var1/Course}{field/projects{set of{sig/Project}}}}', parent=&, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/projects{set of{sig/Project}}}}', parent=&, position=1)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{<{#{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{2}}}}","totalTED":10,"challenge":"JDKw8yJZF5fiP3jv3","time":45185900,"targetExpr":"all p : Student, c : Course | #c.projects&p.projects<2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | lone p: Project | p in s.enrolled.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{lone{one of{var1}{sig/Project}}{in{var1/Project}{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","sourceExpr":"all s:Student | lone p:Project | p in s.enrolled.projects","predicate":"inv7","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=lone, value=all)\", \"(type='Update', node=in, value=lone)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=., value=&)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Insert', node=var1/Course, parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=var1/Project)\"]","hint":"Keep going! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","totalTED":9,"challenge":"JDKw8yJZF5fiP3jv3","time":80101400,"targetExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | lone s.enrolled.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{lone{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","sourceExpr":"all s : Student | lone(s.enrolled.projects)","predicate":"inv7","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Course}}', parent=all, position=0)\", \"(type='Move', tree='{lone{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}', parent=all, position=1)\", \"(type='Update', node=., value=&)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Insert', node=var1/Course, parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","totalTED":9,"challenge":"JDKw8yJZF5fiP3jv3","time":59182600,"targetExpr":"all s:Student, c:Course | lone(s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | lone c: s.enrolled | s.projects in c.projects } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{lone{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all s : Student, c : s.enrolled | lone (s.projects & c.projects)","sourceExpr":"all s: Student | lone c: s.enrolled | s.projects in c.projects","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=lone, value=all)\", \"(type='Insert', node=lone, parent=lone, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}', parent=lone, position=0)\"]","hint":"Near a solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{lone{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}","totalTED":3,"challenge":"JDKw8yJZF5fiP3jv3","time":37066900,"targetExpr":"all s : Student, c : s.enrolled | lone (s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student | #s.enrolled.projects<2 } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{<{#{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}{2}}}","nextExpr":"all p : Student, c : Course | #c.projects&p.projects<2","sourceExpr":"all s: Student | #s.enrolled.projects<2","predicate":"inv7","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{<{#{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{2}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Course}}', parent=all, position=0)\", \"(type='Move', tree='{<{#{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}{2}}', parent=all, position=1)\", \"(type='Update', node=., value=&)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Insert', node=var0/Person, parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{<{#{&{.{var1/Course}{field/projects{set of{sig/Project}}}}{.{var0/Person}{field/projects{set of{sig/Project}}}}}}{2}}}}","totalTED":10,"challenge":"JDKw8yJZF5fiP3jv3","time":39773700,"targetExpr":"all p : Student, c : Course | #c.projects&p.projects<2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { no p: Professor | p in p.teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Professor}}{in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"no p : Professor | p in p.(teaches.~enrolled)","sourceExpr":"no p : Professor | p in p.teaches","predicate":"inv8","isNewNode":false,"srcDstTED":5,"targetAST":"{no{one of{var0}{sig/Professor}}{in{var0/Person}{.{var0/Person}{.{field/teaches{set of{sig/Course}}}{~{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Insert', node=., parent=., position=1)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{~{field/enrolled{set of{sig/Course}}}}', parent=., position=1)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{no{one of{var0}{sig/Professor}}{in{var0/Person}{.{var0/Person}{.{field/teaches{set of{sig/Course}}}{~{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":131133300,"targetExpr":"no p : Professor | p in p.(teaches.~enrolled)","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor | p not in p.teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{!in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"all p:Professor| p.enrolled not in p.teaches","sourceExpr":"all p : Professor | p not in p.teaches","predicate":"inv8","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Professor}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","operations":"[\"(type='Insert', node=., parent=!in, position=0)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the exclusion operator ('!in') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":50144700,"targetExpr":"all t : Professor | no t.enrolled & t.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor | p in p.teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"all p : Professor | p not in enrolled.(p.teaches)","sourceExpr":"all p: Professor | p in p.teaches","predicate":"inv8","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Professor}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Move', tree='{.{var0/Person}{field/teaches{set of{sig/Course}}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Professor}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":74974500,"targetExpr":"all p : Professor | p not in enrolled.(p.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c: Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course |some p:Person | c in p.teaches } pred inv4 { all p:Project |one c:Course | p in c.projects } pred inv5 { all x: Person - Student | no x.projects all p: Project | (some s: Student | p in s.projects) } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { } pred inv8 { all p:Person | p in Professor implies (p not in p.teaches) } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","nextExpr":"all p : Person, c : Course | p in Professor && c in p.teaches implies c not in p.enrolled","sourceExpr":"all x : Person | x in Professor implies x not in x.teaches","predicate":"inv8","isNewNode":false,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{AND{in{var0/Person}{sig/Professor}}{in{var1/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Course}}', parent=all, position=0)\", \"(type='Move', tree='{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}', parent=all, position=1)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='TreeInsert', tree='{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{var0/Person}{sig/Professor}}', parent=AND, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=AND, position=1)\", \"(type='Update', node=var0/Person, value=var1/Course)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{AND{in{var0/Person}{sig/Professor}}{in{var1/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":14,"challenge":"JDKw8yJZF5fiP3jv3","time":39572300,"targetExpr":"all p : Person, c : Course | p in Professor && c in p.teaches implies c not in p.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,pp: Person | lone (p.teaches & pp.teaches) => (p.enrolled not in pp.teaches && pp.enrolled not in p.teaches) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{lone{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{AND{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{!in{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","nextExpr":"all disj p,p1:Professor | #p.teaches&p1.teaches>0 implies (#p.enrolled&p1.teaches=0 and #p1.enrolled&p.teaches=0)","sourceExpr":"all disj p,pp: Person | lone (p.teaches & pp.teaches) => (p.enrolled not in pp.teaches && pp.enrolled not in p.teaches)","predicate":"inv9","isNewNode":true,"srcDstTED":13,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{>{#{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{AND{={#{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{={#{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{0}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=>, parent==>, position=0)\", \"(type='Update', node=lone, value=#)\", \"(type='Move', tree='{lone{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}', parent=>, position=0)\", \"(type='Insert', node=0, parent=>, position=1)\", \"(type='Insert', node==, parent=AND, position=0)\", \"(type='Insert', node==, parent=AND, position=1)\", \"(type='Insert', node=#, parent==, position=0)\", \"(type='Insert', node=0, parent==, position=1)\", \"(type='Insert', node=#, parent==, position=0)\", \"(type='Insert', node=0, parent==, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=#, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=#, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Person, value=var1/Person)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{>{#{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{AND{={#{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{={#{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{0}}}}}}","totalTED":13,"challenge":"JDKw8yJZF5fiP3jv3","time":123621400,"targetExpr":"all disj p,p1:Professor | #p.teaches&p1.teaches>0 implies (#p.enrolled&p1.teaches=0 and #p1.enrolled&p.teaches=0)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,pp: Person | some (p.teaches & pp.teaches) => (p.enrolled not in pp.teaches && pp.enrolled not in p.teaches) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{AND{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{!in{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","nextExpr":"all x, y : Professor | some (x.teaches & y.teaches) implies no (x.teaches & y.enrolled) and no (y.teaches & x.enrolled)","sourceExpr":"all disj p,pp: Person | some (p.teaches & pp.teaches) => (p.enrolled not in pp.teaches && pp.enrolled not in p.teaches)","predicate":"inv9","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{AND{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=no, parent=AND, position=0)\", \"(type='Insert', node=no, parent=AND, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{AND{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":12,"challenge":"JDKw8yJZF5fiP3jv3","time":45687500,"targetExpr":"all x, y : Professor | some (x.teaches & y.teaches) implies no (x.teaches & y.enrolled) and no (y.teaches & x.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => (#(p1.enrolled & p2.enrolled)=0) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{={#{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}{0}}}}}","nextExpr":"all p1 : Professor | all p2 : Professor | (some p2.teaches & p1.teaches) implies (no p1.teaches & p2.enrolled)","sourceExpr":"all disj p1, p2: Person | some (p2.teaches & p1.teaches) => (#(p1.enrolled & p2.enrolled)=0)","predicate":"inv9","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=#, value=no)\", \"(type='Move', tree='{#{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=0)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":8,"challenge":"JDKw8yJZF5fiP3jv3","time":54036100,"targetExpr":"all p1 : Professor | all p2 : Professor | (some p2.teaches & p1.teaches) implies (no p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Professor |all c:s.teaches | c not in j.enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches))","sourceExpr":"all disj p1, p2 : Professor | all c : p1.teaches | c not in p2.enrolled","predicate":"inv9","isNewNode":false,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=some, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{sig/Professor}', parent=-, position=0)\", \"(type='Insert', node=var0/Person, parent=-, position=1)\", \"(type='Update', node=one of, value=&)\", \"(type='Move', tree='{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Insert', node=., parent=one of, position=0)\", \"(type='TreeInsert', tree='{.{var0/Person}{field/teaches{set of{sig/Course}}}}', parent=!in, position=2)\", \"(type='Update', node=var2, value=var1/Person)\", \"(type='Move', tree='{var2}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2/Course)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":20,"challenge":"JDKw8yJZF5fiP3jv3","time":90417200,"targetExpr":"all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches))","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,pp: Professor | all c: Course | p in c.~teaches && pp in c.~teaches => p not in c.~enrolled && pp not in c.~enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var0/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}{in{var1/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}}{AND{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}{!in{var1/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}}}","nextExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","sourceExpr":"all disj p,pp: Professor | all c: Course | p in c.~teaches && pp in c.~teaches => p not in c.~enrolled && pp not in c.~enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=AND, value=&)\", \"(type='Move', tree='{AND{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}{!in{var1/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}', parent=no, position=0)\", \"(type='Update', node=var0/Person, value=var2/Course)\", \"(type='Update', node=var1/Person, value=var2/Course)\", \"(type='Move', tree='{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var1/Person)\", \"(type='Delete', node=!in)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":19,"challenge":"JDKw8yJZF5fiP3jv3","time":44393200,"targetExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => ((p1.enrolled & p2.enrolled)=0) && p1.enrolled != p2.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{AND{!={.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{0}}}}}}","nextExpr":"all disj p,p1:Professor | #p.teaches&p1.teaches>0 implies (#p.enrolled&p1.teaches=0 and #p1.enrolled&p.teaches=0)","sourceExpr":"all disj p1, p2: Person | some (p2.teaches & p1.teaches) => ((p1.enrolled & p2.enrolled)=0) && p1.enrolled != p2.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":15,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{>{#{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{AND{={#{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{={#{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{0}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=>, parent==>, position=0)\", \"(type='Update', node=some, value=#)\", \"(type='Move', tree='{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}', parent=>, position=0)\", \"(type='Insert', node=0, parent=>, position=1)\", \"(type='Insert', node==, parent=AND, position=0)\", \"(type='Insert', node=#, parent==, position=0)\", \"(type='Insert', node=0, parent==, position=1)\", \"(type='Insert', node=#, parent==, position=0)\", \"(type='Update', node=!=, value=&)\", \"(type='Move', tree='{!={.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=#, position=0)\", \"(type='Move', tree='{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}', parent=#, position=0)\", \"(type='Update', node=field/enrolled, value=field/teaches)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{>{#{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{AND{={#{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{0}}{={#{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{0}}}}}}","totalTED":15,"challenge":"JDKw8yJZF5fiP3jv3","time":48701700,"targetExpr":"all disj p,p1:Professor | #p.teaches&p1.teaches>0 implies (#p.enrolled&p1.teaches=0 and #p1.enrolled&p.teaches=0)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,pp: Person | all c: Course | p in c.~teaches && pp in c.~teaches => p not in c.~enrolled && pp not in c.~enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{all{one of{var2}{sig/Course}}{=>{AND{in{var0/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}{in{var1/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}}{AND{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}{!in{var1/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}}}","nextExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","sourceExpr":"all disj p,pp: Person | all c: Course | p in c.~teaches && pp in c.~teaches => p not in c.~enrolled && pp not in c.~enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=AND, value=&)\", \"(type='Move', tree='{AND{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}{!in{var1/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}', parent=no, position=0)\", \"(type='Update', node=var0/Person, value=var2/Course)\", \"(type='Update', node=var1/Person, value=var2/Course)\", \"(type='Move', tree='{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}', parent=AND, position=0)\", \"(type='Move', tree='{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=var1/Person)\", \"(type='Delete', node=!in)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":21,"challenge":"JDKw8yJZF5fiP3jv3","time":46836900,"targetExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x: Person - Student | no x.enrolled } pred inv2 { all x: Person - Professor | no x.teaches } pred inv3 { all c: Course | (some p : Professor | c in p.teaches ) } pred inv4 { all p : Project | (one c : Course | p in c.projects) } pred inv5 { all x: Person - Student | no x.projects all p: Project | (some s: Student | p in s.projects) } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student|all c:s.enrolled|lone (c.projects & s.projects) } pred inv8 { all p:Professor|all c:p.enrolled | c not in p.teaches } pred inv9 { all p,p1 : Professor | all c:p.teaches | c not in p1.enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches))","sourceExpr":"all p, s: Professor | all c: p.teaches | c not in s.enrolled","predicate":"inv9","isNewNode":false,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=some, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{sig/Professor}', parent=-, position=0)\", \"(type='Insert', node=var0/Person, parent=-, position=1)\", \"(type='Update', node=one of, value=&)\", \"(type='Move', tree='{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Insert', node=., parent=one of, position=0)\", \"(type='TreeInsert', tree='{.{var0/Person}{field/teaches{set of{sig/Course}}}}', parent=!in, position=2)\", \"(type='Update', node=var2, value=var1/Person)\", \"(type='Move', tree='{var2}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=var2/Course)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":18,"challenge":"JDKw8yJZF5fiP3jv3","time":42567300,"targetExpr":"all p : Professor | (all col : Professor - p | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches))","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,pp: Person | lone (p.teaches & pp.teaches) => p.enrolled not in pp.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{lone{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}","nextExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","sourceExpr":"all disj p,pp: Person | lone (p.teaches & pp.teaches) => p.enrolled not in pp.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=lone, value=some)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":64330300,"targetExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,p1: Professor | p.teaches in p1.teaches => p.enrolled not in p1.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{in{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}","nextExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","sourceExpr":"all disj p,p1: Professor | p.teaches in p1.teaches => p.enrolled not in p1.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":39467300,"targetExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,p1: Professor | all c: Course | p in c.~teaches => p1.enrolled not in p.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{in{var0/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}{!in{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","nextExpr":"all p, col : Professor | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches)","sourceExpr":"all disj p,p1: Professor | all c: Course | p in c.~teaches => p1.enrolled not in p.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Insert', node=some, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var2}{sig/Course}}', parent=&, position=0)\", \"(type='Move', tree='{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}', parent=&, position=1)\", \"(type='Update', node=var2, value=var1/Person)\", \"(type='Insert', node=field/teaches, parent=one of, position=1)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Move', tree='{sig/Course}', parent=set of, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=~)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=in)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":16,"challenge":"JDKw8yJZF5fiP3jv3","time":44463800,"targetExpr":"all p, col : Professor | some (col.teaches & p.teaches) implies no (col.enrolled & p.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => ((p1.enrolled & p2.enrolled)=0) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{0}}}}}","nextExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","sourceExpr":"all disj p1, p2: Person | some (p2.teaches & p1.teaches) => ((p1.enrolled & p2.enrolled)=0)","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node==, value=no)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Delete', node=0)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":47919100,"targetExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p,p1: Professor | all c: Course | p.teaches = p1.teaches => p.enrolled not in p1.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{={.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","nextExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","sourceExpr":"all disj p,p1: Professor | all c: Course | p.teaches = p1.teaches => p.enrolled not in p1.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{=>{={.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}', parent=all, position=2)\", \"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node==, value=&)\", \"(type='Move', tree='{={.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Course}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":10,"challenge":"JDKw8yJZF5fiP3jv3","time":40327400,"targetExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => ((p1.enrolled & p2.teaches)=0) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{0}}}}}","nextExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","sourceExpr":"all disj p1, p2: Person | some (p2.teaches & p1.teaches) => ((p1.enrolled & p2.teaches)=0)","predicate":"inv9","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node==, value=no)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=0)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":8,"challenge":"JDKw8yJZF5fiP3jv3","time":44564200,"targetExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Professor |all c:s.teaches | j not in c.enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var1/Person}{.{var2/Course}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","sourceExpr":"all disj s,j:Professor |all c:s.teaches | j not in c.enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":17,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Insert', node=some, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=one of, value=&)\", \"(type='Move', tree='{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{var1/Person}{.{var2/Course}{field/enrolled{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='TreeInsert', tree='{.{var1/Person}{field/teaches{set of{sig/Course}}}}', parent=one of, position=2)\", \"(type='Insert', node=., parent=!in, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Delete', node=var2)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":17,"challenge":"JDKw8yJZF5fiP3jv3","time":40727100,"targetExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | c in p.enrolled implies p in Student } pred inv2 { all p:Person, c:Course | c in p.teaches implies p in Professor } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person, proj:Project | (proj in p.projects implies p in Student) and (some p1:Person | proj in p1.projects) } pred inv6 { all s:Student, p:Project | p in s.projects implies (some c:Course | p in c.projects and c in s.enrolled) } pred inv7 { all s:Student, c:Course | lone p:Project | p in s.projects and p in c.projects } pred inv8 { all p:Professor, c:Course | c in p.teaches implies c not in p.enrolled } pred inv9 { all p1, p2 : Professor, c:Course | c in p1.teaches implies c not in p2.teaches and p1!=p2 } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{AND{!={var0/Person}{var1/Person}}{!in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","nextExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","sourceExpr":"all p1, p2 : Professor, c:Course | c in p1.teaches implies c not in p2.teaches and p1!=p2","predicate":"inv9","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Move', tree='{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=AND, position=0)\", \"(type='Update', node=!=, value=in)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Update', node=var0/Person, value=var2/Course)\", \"(type='Insert', node=., parent=!=, position=1)\", \"(type='Insert', node=., parent=!in, position=0)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Move', tree='{var2/Course}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":16,"challenge":"JDKw8yJZF5fiP3jv3","time":41490000,"targetExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { no p1, p2: Professor | p1 != p2 && p2 in p1.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Professor}}{no{one of{var1}{sig/Professor}}{AND{!={var0/Person}{var1/Person}}{in{var1/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","nextExpr":"all p : Professor| enrolled.(p.teaches)&teaches.(p.teaches)= none","sourceExpr":"no p1, p2: Professor | p1 != p2 && p2 in p1.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/Professor}}{={&{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{none}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Insert', node==, parent=no, position=1)\", \"(type='Update', node=no, value=&)\", \"(type='Move', tree='{no{one of{var1}{sig/Professor}}{AND{!={var0/Person}{var1/Person}}{in{var1/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}', parent==, position=0)\", \"(type='Insert', node=none, parent==, position=1)\", \"(type='Insert', node=., parent=no, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var1/Person}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=1)\", \"(type='Insert', node=field/enrolled, parent=., position=0)\", \"(type='Update', node=!=, value=.)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=., position=1)\", \"(type='Insert', node=field/teaches, parent=in, position=0)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var1}{sig/Professor}}', parent=field/enrolled, position=0)\", \"(type='Insert', node=field/teaches, parent=!=, position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var1, value=sig/Course)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var1/Person, value=sig/Course)\", \"(type='Move', tree='{var1/Person}', parent=set of, position=0)\", \"(type='Update', node=var1/Person, value=sig/Course)\", \"(type='Move', tree='{var1/Person}', parent=set of, position=0)\", \"(type='Delete', node=sig/Professor)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{={&{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{none}}}","totalTED":18,"challenge":"JDKw8yJZF5fiP3jv3","time":45454300,"targetExpr":"all p : Professor| enrolled.(p.teaches)&teaches.(p.teaches)= none","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Professor | some (p2.teaches & p1.teaches) => p1.enrolled & p2.enrolled = none } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{none}}}}}","nextExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","sourceExpr":"all disj p1, p2: Professor | some (p2.teaches & p1.teaches) => p1.enrolled & p2.enrolled = none","predicate":"inv9","isNewNode":true,"srcDstTED":5,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node==, value=no)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":5,"challenge":"JDKw8yJZF5fiP3jv3","time":47471300,"targetExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student all p:Project| (some x:Student| x->p in projects) } pred inv6 { all x:Student, c:Course, p:Project| x->p in projects and c->p in projects implies x->c in enrolled } pred inv7 { all x:Student, c:Course, p,y:Project| x->p in projects and x->y in projects and c->p in projects and c->y in projects implies p=y } pred inv8 { all x:Professor, c:Course| x->c in teaches implies x->c not in enrolled } pred inv9 { all x:Professor, c:Course|(some y:Professor-x| x->c in teaches implies y->c not in enrolled) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{some{one of{var2}{-{sig/Professor}{var0/Person}}}{=>{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var2/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all p:Professor, p2:Professor-p | (some (p.teaches & p2.teaches)) => (no p.teaches & p2.enrolled)","sourceExpr":"all x:Professor, c:Course|(some y:Professor-x| x->c in teaches implies y->c not in enrolled)","predicate":"inv9","isNewNode":true,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{one of{var2}{-{sig/Professor}{var0/Person}}}', parent=all, position=0)\", \"(type='Move', tree='{=>{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var2/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}', parent=all, position=1)\", \"(type='Update', node=var2, value=var1)\", \"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{->{var2/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}', parent=no, position=0)\", \"(type='Update', node=->, value=.)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=->, value=.)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Insert', node=field/teaches, parent=->, position=1)\", \"(type='Insert', node=var1/Person, parent=., position=0)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Insert', node=field/teaches, parent=->, position=1)\", \"(type='Insert', node=var1/Person, parent=., position=0)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{var1/Course}', parent=set of, position=0)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{var1/Course}', parent=set of, position=0)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Course}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! It seems like the one of is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":22,"challenge":"JDKw8yJZF5fiP3jv3","time":40488700,"targetExpr":"all p:Professor, p2:Professor-p | (some (p.teaches & p2.teaches)) => (no p.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all x:Person, c:Course| x->c in enrolled implies x in Student } pred inv2 { all x:Person, c:Course| x->c in teaches implies x in Professor } pred inv3 { all c:Course| (some x:Professor| x->c in teaches) } pred inv4 { all p:Project| (one c:Course| c->p in projects) } pred inv5 { all x:Person, p:Project| x->p in projects implies x in Student all p:Project| (some x:Student| x->p in projects) } pred inv6 { all x:Student, c:Course, p:Project| x->p in projects and c->p in projects implies x->c in enrolled } pred inv7 { all x:Student, c:Course, p,y:Project| x->p in projects and x->y in projects and c->p in projects and c->y in projects implies p=y } pred inv8 { all x:Professor, c:Course| x->c in teaches implies x->c not in enrolled } pred inv9 { all x:Professor, c:Course, y:Professor-x| x->c in teaches implies y->c not in enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{all{one of{var2}{-{sig/Professor}{var0/Person}}}{=>{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var2/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all p:Professor, p2:Professor-p | (some (p.teaches & p2.teaches)) => (no p.teaches & p2.enrolled)","sourceExpr":"all x:Professor, c:Course, y:Professor-x| x->c in teaches implies y->c not in enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var2}{-{sig/Professor}{var0/Person}}}{=>{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var2/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}', parent=all, position=1)\", \"(type='Update', node=var2, value=var1)\", \"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}', parent=some, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{->{var2/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}', parent=no, position=0)\", \"(type='Update', node=->, value=.)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=->, value=.)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Insert', node=field/teaches, parent=->, position=1)\", \"(type='Insert', node=var1/Person, parent=., position=0)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Insert', node=field/teaches, parent=->, position=1)\", \"(type='Insert', node=var1/Person, parent=., position=0)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{var1/Course}', parent=set of, position=0)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{var1/Course}', parent=set of, position=0)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Course}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":22,"challenge":"JDKw8yJZF5fiP3jv3","time":35488600,"targetExpr":"all p:Professor, p2:Professor-p | (some (p.teaches & p2.teaches)) => (no p.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { no p1, p2: Professor | p1 != p2 && p1 in p2.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Professor}}{no{one of{var1}{sig/Professor}}{AND{!={var0/Person}{var1/Person}}{in{var0/Person}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}","nextExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","sourceExpr":"no p1, p2: Professor | p1 != p2 && p1 in p2.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=no, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=some, parent=AND, position=0)\", \"(type='Insert', node=no, parent=AND, position=1)\", \"(type='Update', node=!=, value=&)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=some, position=0)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{var0/Person}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Insert', node=., parent=!=, position=0)\", \"(type='Insert', node=., parent=!=, position=1)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":19,"challenge":"JDKw8yJZF5fiP3jv3","time":34169400,"targetExpr":"all p1,p2 : Professor | some p1.teaches & p2.teaches implies no p1.enrolled & p2.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all p1: Professor | all disj c,cc: Course | p1 in c.~teaches => p1 not in cc.~enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Course}}{all{disj}{one of{var2}{sig/Course}}{=>{in{var0/Person}{.{var1/Course}{~{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","sourceExpr":"all p1: Professor | all disj c,cc: Course | p1 in c.~teaches => p1 not in cc.~enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Move', tree='{in{var0/Person}{.{var1/Course}{~{field/teaches{set of{sig/Course}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=AND, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{var0/Person}{.{var2/Course}{~{field/enrolled{set of{sig/Course}}}}}}', parent=no, position=0)\", \"(type='Update', node=var0/Person, value=var2/Course)\", \"(type='Insert', node=., parent=!in, position=0)\", \"(type='Update', node=var1/Course, value=var0/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using signature of type Course, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":22,"challenge":"JDKw8yJZF5fiP3jv3","time":36043000,"targetExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1,p2: Professor | all c: Course | c in p1.teaches && c in p2.teaches => p1.enrolled not in p2.teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}","nextExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","sourceExpr":"all disj p1,p2: Professor | all c: Course | c in p1.teaches && c in p2.teaches => p1.enrolled not in p2.teaches","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=no, position=0)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":6,"challenge":"JDKw8yJZF5fiP3jv3","time":37276500,"targetExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all p1, p2: Professor | p1 != p2 => p1.teaches & p2.teaches = none } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{!={var0/Person}{var1/Person}}{={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}}}}","nextExpr":"all p1, p2: Professor | p1.enrolled & p2.teaches != none implies p1.teaches & p2.teaches = none","sourceExpr":"all p1 : Professor | all p2 : Professor | (p1 != p2) => (p1.teaches & p2.teaches = none)","predicate":"inv9","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{!={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}{={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}}}}","operations":"[\"(type='Insert', node=&, parent=!=, position=0)\", \"(type='Insert', node=none, parent=!=, position=1)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='Insert', node=., parent=&, position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\"]","hint":"Keep going! Consider adding a intersection operator ('&') to find the common elements between two sets. Think about how you can incorporate this within the not equal operator ('!=') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{!={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}{={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}}}}","totalTED":10,"challenge":"JDKw8yJZF5fiP3jv3","time":60829300,"targetExpr":"all p1, p2: Professor | p1.enrolled & p2.teaches != none implies p1.teaches & p2.teaches = none","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Person | some (p2.teaches & p1.teaches) => p1.enrolled & p2.enrolled = none } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{none}}}}}","nextExpr":"all p1 : Professor | all p2 : Professor | (some p2.teaches & p1.teaches) implies (no p1.teaches & p2.enrolled)","sourceExpr":"all disj p1, p2: Person | some (p2.teaches & p1.teaches) => p1.enrolled & p2.enrolled = none","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node==, value=no)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var1/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":7,"challenge":"JDKw8yJZF5fiP3jv3","time":47332800,"targetExpr":"all p1 : Professor | all p2 : Professor | (some p2.teaches & p1.teaches) implies (no p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Professor | p1.teaches & p2.teaches = none } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}}}","nextExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","sourceExpr":"all disj p1, p2: Professor | p1.teaches & p2.teaches = none","predicate":"inv9","isNewNode":true,"srcDstTED":14,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node==, value==>)\", \"(type='Insert', node=some, parent==, position=0)\", \"(type='Insert', node=no, parent==, position=1)\", \"(type='Move', tree='{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}', parent=some, position=0)\", \"(type='Insert', node=&, parent=no, position=0)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='TreeInsert', tree='{.{var1/Person}{field/enrolled{set of{sig/Course}}}}', parent=&, position=1)\", \"(type='Update', node=none, value=var0/Person)\", \"(type='Move', tree='{none}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":14,"challenge":"JDKw8yJZF5fiP3jv3","time":51611900,"targetExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all s:Professor |all c:s.teaches | c not in s.enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","nextExpr":"all p : Professor| enrolled.(p.teaches)&teaches.(p.teaches)= none","sourceExpr":"all p: Professor | all c: p.teaches | c not in p.enrolled","predicate":"inv9","isNewNode":false,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Professor}}{={&{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{none}}}","operations":"[\"(type='Insert', node==, parent=all, position=1)\", \"(type='Update', node=all, value=&)\", \"(type='Move', tree='{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}', parent==, position=0)\", \"(type='Insert', node=none, parent==, position=1)\", \"(type='Update', node=one of, value=.)\", \"(type='Update', node=!in, value=.)\", \"(type='Insert', node=field/enrolled, parent=one of, position=0)\", \"(type='Insert', node=field/teaches, parent=!in, position=0)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=var1, value=sig/Course)\", \"(type='Move', tree='{var1}', parent=set of, position=0)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{var1/Course}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a equal operator ('=') to specify that the left side is equal to the right side. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{={&{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{none}}}","totalTED":12,"challenge":"JDKw8yJZF5fiP3jv3","time":60849200,"targetExpr":"all p : Professor| enrolled.(p.teaches)&teaches.(p.teaches)= none","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Person |all c:s.teaches | c in j.enrolled implies j not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Person}}{all{disj}{one of{var1}{sig/Person}}{all{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{=>{in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}}}}","nextExpr":"all p: Professor | all c: teaches.(p.teaches) | no (c.enrolled & p.teaches)","sourceExpr":"all disj s,j:Person |all c:s.teaches | c in j.enrolled implies j not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{var1}', parent=one of, position=0)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=one of, position=1)\", \"(type='Update', node==>, value=&)\", \"(type='Move', tree='{=>{in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}', parent=no, position=0)\", \"(type='Insert', node=field/teaches, parent=one of, position=0)\", \"(type='Move', tree='{.{var1/Person}{field/enrolled{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Insert', node=field/teaches, parent=!in, position=1)\", \"(type='Update', node=var2, value=sig/Course)\", \"(type='Move', tree='{var2}', parent=set of, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=in)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=sig/Person)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","totalTED":20,"challenge":"JDKw8yJZF5fiP3jv3","time":38526600,"targetExpr":"all p: Professor | all c: teaches.(p.teaches) | no (c.enrolled & p.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { all disj p1, p2: Professor | some c: Course| p1 in c.~teaches && p2 in c.~teaches => p1.enrolled & p2.enrolled = none } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{=>{AND{in{var0/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}{in{var1/Person}{.{var2/Course}{~{field/teaches{set of{sig/Course}}}}}}}{={&{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{none}}}}}}","nextExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","sourceExpr":"all disj p1, p2: Professor | some c: Course| p1 in c.~teaches && p2 in c.~teaches => p1.enrolled & p2.enrolled = none","predicate":"inv9","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node==, value=no)\", \"(type='Update', node=var0/Person, value=var2/Course)\", \"(type='Update', node=var1/Person, value=var2/Course)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=var2/Course, value=var1/Person)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=~)\", \"(type='Delete', node=~)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":12,"challenge":"JDKw8yJZF5fiP3jv3","time":44777700,"targetExpr":"all p1, p2 : Professor | all c: Course | c in p1.teaches and c in p2.teaches implies no p1.teaches & p2.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { no disj p1, p2: Professor | p1.teaches & p2.teaches != none and p1 != p2 } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{disj}{one of{var0}{sig/Professor}}{no{disj}{one of{var1}{sig/Professor}}{AND{!={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}{!={var0/Person}{var1/Person}}}}}","nextExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","sourceExpr":"no disj p1, p2: Professor | p1.teaches & p2.teaches != none and p1 != p2","predicate":"inv9","isNewNode":true,"srcDstTED":15,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=no, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=!=, value=some)\", \"(type='Insert', node=no, parent=AND, position=1)\", \"(type='Update', node=!=, value=&)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=no, position=0)\", \"(type='Insert', node=., parent=!=, position=0)\", \"(type='Insert', node=., parent=!=, position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":15,"challenge":"JDKw8yJZF5fiP3jv3","time":36526200,"targetExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p: Person | p not in Student => p not in Course.~enrolled } pred inv2 { all p: Person | p not in Professor => p not in Course.~teaches } pred inv3 { all c: Course | #c.~teaches>0 } pred inv4 { all p: Project | one c: Course | p in c.projects } pred inv5 { all p: Person | (p not in Student => p.projects = none) && (all pr:Project | some s: Student | pr in s.projects ) } pred inv6 { all s: Student | s.projects in s.enrolled.projects } pred inv7 { all s: Student, c: s.enrolled | lone p: s.projects | p in c.projects } pred inv8 { all p: Professor, c: Course | p in c.~teaches => p not in c.~enrolled } pred inv9 { no disj p1, p2: Professor | p1.teaches & p2.teaches != none => p1 not in p2.teaches.~enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{disj}{one of{var0}{sig/Professor}}{no{disj}{one of{var1}{sig/Professor}}{=>{!={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}{none}}{!in{var0/Person}{.{.{var1/Person}{field/teaches{set of{sig/Course}}}}{~{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","sourceExpr":"no disj p1, p2: Professor | p1.teaches & p2.teaches != none => p1 not in p2.teaches.~enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":10,"targetAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=no, value=all)\", \"(type='Update', node=!=, value=some)\", \"(type='Update', node=!in, value=no)\", \"(type='Update', node=., value=&)\", \"(type='Update', node=~, value=.)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Insert', node=var1/Person, parent=~, position=0)\", \"(type='Delete', node=none)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":10,"challenge":"JDKw8yJZF5fiP3jv3","time":46571200,"targetExpr":"all disj p1, p2: Professor | some p1.teaches & p2.teaches implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person-Student | no p.enrolled } pred inv2 { all p:Person-Professor | no p.teaches } pred inv3 { all c:Course | some p:Professor | c in p.teaches } pred inv4 { all p:Project | one c:Course | p in c.projects } pred inv5 { all p:Person-Student | no p.projects all p:Project | some pe:Person | p in pe.projects } pred inv6 { all u : Student | (all p: u.projects | (some c : Course | c in u.enrolled and p in c.projects ) ) } pred inv7 { all s:Student | all p :s.enrolled | lone (p.projects & s.projects) } pred inv8 { all s:Professor | all c:s.teaches | c not in s.enrolled } pred inv9 { all disj s,j:Professor |all c:s.teaches | c in j.enrolled implies j not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{disj}{one of{var0}{sig/Professor}}{all{disj}{one of{var1}{sig/Professor}}{all{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{=>{in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}}}}","nextExpr":"all p: Professor | all c: teaches.(p.teaches) | no (c.enrolled & p.teaches)","sourceExpr":"all disj s,j:Professor |all c:s.teaches | c in j.enrolled implies j not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","operations":"[\"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Insert', node=no, parent=all, position=1)\", \"(type='Move', tree='{var1}', parent=one of, position=0)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var2}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}', parent=one of, position=1)\", \"(type='Update', node==>, value=&)\", \"(type='Move', tree='{=>{in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}', parent=no, position=0)\", \"(type='Insert', node=field/teaches, parent=one of, position=0)\", \"(type='Move', tree='{.{var1/Person}{field/enrolled{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Insert', node=field/teaches, parent=!in, position=1)\", \"(type='Update', node=var2, value=sig/Course)\", \"(type='Move', tree='{var2}', parent=set of, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=in)\", \"(type='Delete', node=disj)\", \"(type='Delete', node=sig/Professor)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var1/Person}{field/enrolled{set of{sig/Course}}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","totalTED":19,"challenge":"JDKw8yJZF5fiP3jv3","time":36147500,"targetExpr":"all p: Professor | all c: teaches.(p.teaches) | no (c.enrolled & p.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Position] sig Position {} sig Product {} sig Component extends Product { parts : set Product, position : one Position } sig Resource extends Product {} sig Robot { position : one Position } pred Inv1 { } pred Inv2 { Component not in Component.(^parts) } pred Inv3 { } pred Inv4 { }","sourceAST":"{!in{sig/Component}{.{sig/Component}{^{field/parts{set of{sig/Product}}}}}}","nextExpr":"no ^parts & iden","sourceExpr":"Component not in Component.(^parts)","predicate":"Inv2","isNewNode":true,"srcDstTED":5,"targetAST":"{no{&{^{field/parts{set of{sig/Product}}}}{iden}}}","operations":"[\"(type='Update', node=!in, value=no)\", \"(type='Update', node=., value=&)\", \"(type='Insert', node=iden, parent=., position=2)\", \"(type='Delete', node=sig/Component)\", \"(type='Delete', node=sig/Component)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{no{&{^{field/parts{set of{sig/Product}}}}{iden}}}","totalTED":5,"challenge":"jyS8Bmceejj9pLbTW","time":109460200,"targetExpr":"no ^parts & iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link = none } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Trash}}{={.{var0/File}{field/link{set of{sig/File}}}}{none}}}","nextExpr":"all t:Trash | t in none","sourceExpr":"all t: Trash | t.link = none","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Trash}}{in{var0/File}{none}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{var0/File}', parent==, position=0)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Trash}}{in{var0/File}{none}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":117173300,"targetExpr":"all t:Trash | t in none","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Trash}}{!={.{var0/File}{field/link{set of{sig/File}}}}{sig/File}}}","nextExpr":"all t : Trash | t not in univ","sourceExpr":"all t: Trash | t.link != File","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Trash}}{!in{var0/File}{univ}}}","operations":"[\"(type='Update', node=., value=!in)\", \"(type='Move', tree='{.{var0/File}{field/link{set of{sig/File}}}}', parent=all, position=1)\", \"(type='Update', node=sig/File, value=univ)\", \"(type='Move', tree='{sig/File}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/link)\", \"(type='Delete', node=sig/File)\", \"(type='Delete', node=!=)\"]","hint":"Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Trash}}{!in{var0/File}{univ}}}","totalTED":6,"challenge":"PQAJE67kz8w5NWJuM","time":38426200,"targetExpr":"all t : Trash | t not in univ","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | Trash.link = none } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Trash}}{={.{sig/Trash}{field/link{set of{sig/File}}}}{none}}}","nextExpr":"all t:Trash | t in none","sourceExpr":"all t: Trash | Trash.link = none","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Trash}}{in{var0/File}{none}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Update', node=sig/Trash, value=var0/File)\", \"(type='Move', tree='{sig/Trash}', parent==, position=0)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Trash}}{in{var0/File}{none}}}","totalTED":6,"challenge":"PQAJE67kz8w5NWJuM","time":30184400,"targetExpr":"all t:Trash | t in none","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash.link } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{.{sig/Trash}{field/link{set of{sig/File}}}}}","nextExpr":"no Trash","sourceExpr":"no Trash.link","predicate":"inv1","isNewNode":false,"srcDstTED":4,"targetAST":"{no{sig/Trash}}","operations":"[\"(type='Move', tree='{sig/Trash}', parent=no, position=0)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the signature of type Trash is not in the right place. Try moving it to the inside of the no quantifier ('no') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{no{sig/Trash}}","totalTED":4,"challenge":"PQAJE67kz8w5NWJuM","time":80800400,"targetExpr":"no Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all l : File.link | no l.link } pred inv10 { all f : File | (f.link in Trash) implies f in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f: File | f in Trash => f.link in Trash","sourceExpr":"all f: File | f.link in Trash implies f in Trash","predicate":"inv10","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='TreeInsert', tree='{in{var0/File}{sig/Trash}}', parent==>, position=0)\", \"(type='TreeDelete', tree='{in{var0/File}{sig/Trash}}')\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":6,"challenge":"PQAJE67kz8w5NWJuM","time":94892200,"targetExpr":"all f: File | f in Trash => f.link in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all t:Trash | t.link = none } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link != none } pred inv10 { all f:File | (f.link in Trash) => (f.link.link in Trash) }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}{in{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}{sig/Trash}}}}","nextExpr":"all f: File | f in Trash => f.link in Trash","sourceExpr":"all f: File | f.link in Trash implies f.link.link in Trash","predicate":"inv10","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Move', tree='{var0/File}', parent=in, position=0)\", \"(type='Move', tree='{.{var0/File}{field/link{set of{sig/File}}}}', parent=in, position=0)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the variable of type File is not in the right place. Try moving it to the inside of the inclusion operator ('in') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":8,"challenge":"PQAJE67kz8w5NWJuM","time":115416600,"targetExpr":"all f: File | f in Trash => f.link in Trash","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all l : File.link | no l.link } pred inv10 { all f : File | all l : f.link | l in Trash implies f in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{.{var0/File}{field/link{set of{sig/File}}}}}{=>{in{var1/File}{sig/Trash}}{in{var0/File}{sig/Trash}}}}}","nextExpr":"all f : File | all l : f.link | f in Trash implies l in Trash","sourceExpr":"all f : File, l : f.link | l in Trash => f in Trash","predicate":"inv10","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{.{var0/File}{field/link{set of{sig/File}}}}}{=>{in{var0/File}{sig/Trash}}{in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=var1/File, value=var0/File)\", \"(type='Update', node=var0/File, value=var1/File)\"]","hint":"Near a solution! Instead of using variable of type File, try using variable of type File to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{.{var0/File}{field/link{set of{sig/File}}}}}{=>{in{var0/File}{sig/Trash}}{in{var1/File}{sig/Trash}}}}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":52401300,"targetExpr":"all f : File | all l : f.link | f in Trash implies l in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { not some f:Protected | f in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { all f1,f2,f3 : File | f1->f2 in link and f1->f3 in link implies f2=f3 } pred inv7 { not some f1,f2:File | f1->f2 in link and f2 in Trash } pred inv8 { not some f1,f2:File | f1->f2 in link } pred inv9 { not some f1,f2,f3:File | f1->f2 in link and f2->f3 in link } pred inv10 { all f1,f2, f3: File | f1->f2 in link and f2->f3 in link and f2 in Trash implies f3 in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}{in{var1/File}{sig/Trash}}}{in{var2/File}{sig/Trash}}}}}}","nextExpr":"all f:File | all f1:File | f->f1 in link and f in Trash implies f1 in Trash","sourceExpr":"all f1,f2, f3: File | f1->f2 in link and f2->f3 in link and f2 in Trash implies f3 in Trash","predicate":"inv10","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var0/File}{sig/Trash}}}{in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Move', tree='{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}{in{var1/File}{sig/Trash}}}{in{var2/File}{sig/Trash}}}', parent=all, position=1)\", \"(type='Update', node=var2/File, value=var1/File)\", \"(type='Update', node=var1/File, value=var0/File)\", \"(type='TreeDelete', tree='{in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/File}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var0/File}{sig/Trash}}}{in{var1/File}{sig/Trash}}}}}","totalTED":13,"challenge":"PQAJE67kz8w5NWJuM","time":77467300,"targetExpr":"all f:File | all f1:File | f->f1 in link and f in Trash implies f1 in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all l : File.link | no l.link } pred inv10 { all f : File | (some f.link and (f.link in Trash)) implies f in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{=>{AND{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}{some{.{var0/File}{field/link{set of{sig/File}}}}}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f : File | some f.link and f in Trash implies f.link in Trash","sourceExpr":"all f : File | (some f.link and (f.link in Trash)) implies f in Trash","predicate":"inv10","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{=>{AND{in{var0/File}{sig/Trash}}{some{.{var0/File}{field/link{set of{sig/File}}}}}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{var0/File}', parent=in, position=0)\", \"(type='Move', tree='{var0/File}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/link{set of{sig/File}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/File}}{=>{AND{in{var0/File}{sig/Trash}}{some{.{var0/File}{field/link{set of{sig/File}}}}}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":8,"challenge":"PQAJE67kz8w5NWJuM","time":33980200,"targetExpr":"all f : File | some f.link and f in Trash implies f.link in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all l : File.link | no l.link } pred inv10 { all f : File | (no f.link or (f.link in Trash)) implies f in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{=>{OR{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}{no{.{var0/File}{field/link{set of{sig/File}}}}}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f: File | f in Trash => f.link in Trash","sourceExpr":"all f : File | (no f.link or (f.link in Trash)) implies f in Trash","predicate":"inv10","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Move', tree='{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}', parent==>, position=0)\", \"(type='Insert', node=in, parent==>, position=1)\", \"(type='Move', tree='{var0/File}', parent=in, position=0)\", \"(type='Move', tree='{.{var0/File}{field/link{set of{sig/File}}}}', parent=in, position=0)\", \"(type='Move', tree='{sig/Trash}', parent=in, position=1)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=no)\", \"(type='Delete', node=OR)\", \"(type='Delete', node=var0/File)\", \"(type='Delete', node=in)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the implication operator ('=>') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":9,"challenge":"PQAJE67kz8w5NWJuM","time":55300700,"targetExpr":"all f: File | f in Trash => f.link in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File, t:Trash | f not in t } pred inv2 { all f:File, t:Trash | f in t } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"all f:File | f in Trash","sourceExpr":"all f : File, t : Trash | f in t","predicate":"inv2","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}","operations":"[\"(type='Move', tree='{in{var0/File}{var1/File}}', parent=all, position=1)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":110158900,"targetExpr":"all f:File | f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { File in Trash } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{sig/File}{sig/Trash}}","nextExpr":"some Trash","sourceExpr":"File in Trash","predicate":"inv3","isNewNode":false,"srcDstTED":2,"targetAST":"{some{sig/Trash}}","operations":"[\"(type='Update', node=in, value=some)\", \"(type='Delete', node=sig/File)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{sig/Trash}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":97350300,"targetExpr":"some Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Protected}}{in{-{var0/File}{var1/File}}{sig/Trash}}}}","nextExpr":"all v : File | v not in Protected implies v in Trash","sourceExpr":"all f:File | all p:Protected | (f-p) in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Update', node=one of, value=!in)\", \"(type='Update', node=var1, value=var0/File)\", \"(type='Move', tree='{var0/File}', parent=in, position=0)\", \"(type='Delete', node=var1/File)\", \"(type='Delete', node=-)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":129202700,"targetExpr":"all v : File | v not in Protected implies v in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { not some f:Protected | f in Trash } pred inv5 { not some f:Protected | f not in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!{some{one of{var0}{sig/Protected}}{!in{var0/File}{sig/Trash}}}}","nextExpr":"all f: File - Protected |f in Trash","sourceExpr":"not some f:Protected | f not in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{-{sig/File}{sig/Protected}}}{in{var0/File}{sig/Trash}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Protected}}{!in{var0/File}{sig/Trash}}}', parent=root, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=sig/File, parent=-, position=0)\", \"(type='Move', tree='{sig/Protected}', parent=-, position=1)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{-{sig/File}{sig/Protected}}}{in{var0/File}{sig/Trash}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":53331000,"targetExpr":"all f: File - Protected |f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no f:File | f in Trash } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:(File-Protected) | f in Trash } pred inv6 { all f:File | f.link = none } pred inv7 { all f:File | (f in Trash) => (f.link = none) } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link.link = none } pred inv10 { all f:File | (f in Trash) => (f.link in Trash) }","sourceAST":"{all{one of{var0}{sig/File}}{={.{var0/File}{field/link{set of{sig/File}}}}{none}}}","nextExpr":"all f: File | lone f.link","sourceExpr":"all f:File | f.link = none","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Update', node==, value=lone)\", \"(type='Delete', node=none)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":118827300,"targetExpr":"all f: File | lone f.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no f:File | f in Trash } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:(File-Protected) | f in Trash } pred inv6 { lone f:File | f.link = f } pred inv7 { all f:File | (f in Trash) => (f.link = none) } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link.link = none } pred inv10 { all f:File | (f in Trash) => (f.link in Trash) }","sourceAST":"{lone{one of{var0}{sig/File}}{={.{var0/File}{field/link{set of{sig/File}}}}{var0/File}}}","nextExpr":"all file: File | lone file.link","sourceExpr":"lone f:File | f.link = f","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Update', node=lone, value=all)\", \"(type='Update', node==, value=lone)\", \"(type='Delete', node=var0/File)\"]","hint":"Near a solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","totalTED":3,"challenge":"PQAJE67kz8w5NWJuM","time":34923500,"targetExpr":"all file: File | lone file.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { not some f:Protected | f in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { link in File lone -> lone File } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/link{set of{sig/File}}}{lone->lone{sig/File}{sig/File}}}","nextExpr":"all file: File | lone file.link","sourceExpr":"link in File lone -> lone File","predicate":"inv6","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Update', node=in, value=all)\", \"(type='Update', node=set of, value=one of)\", \"(type='Move', tree='{set of{sig/File}}', parent=in, position=0)\", \"(type='Insert', node=lone, parent=in, position=1)\", \"(type='Insert', node=var0, parent=set of, position=0)\", \"(type='Update', node=lone->lone, value=.)\", \"(type='Move', tree='{lone->lone{sig/File}{sig/File}}', parent=lone, position=0)\", \"(type='Update', node=sig/File, value=var0/File)\", \"(type='Insert', node=field/link, parent=lone->lone, position=1)\", \"(type='Insert', node=set of, parent=field/link, position=0)\", \"(type='Move', tree='{sig/File}', parent=set of, position=0)\", \"(type='Delete', node=field/link)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","totalTED":9,"challenge":"PQAJE67kz8w5NWJuM","time":102716900,"targetExpr":"all file: File | lone file.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{lone{one of{var1}{sig/File}}{={.{var0/File}{field/link{set of{sig/File}}}}{var1/File}}}}","nextExpr":"all f: File | lone l: File | l in f.link","sourceExpr":"all f: File | lone g: File | f.link = g","predicate":"inv6","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/File}}{lone{one of{var1}{sig/File}}{in{var1/File}{.{var0/File}{field/link{set of{sig/File}}}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=var1/File, parent==, position=0)\", \"(type='Delete', node=var1/File)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/File}}{lone{one of{var1}{sig/File}}{in{var1/File}{.{var0/File}{field/link{set of{sig/File}}}}}}}","totalTED":3,"challenge":"PQAJE67kz8w5NWJuM","time":60733600,"targetExpr":"all f: File | lone l: File | l in f.link","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | one l: File | f.link = l } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{one{one of{var1}{sig/File}}{={.{var0/File}{field/link{set of{sig/File}}}}{var1/File}}}}","nextExpr":"all f: File | lone l: File | l in f.link","sourceExpr":"all f:File | one l: File | f.link = l","predicate":"inv6","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{lone{one of{var1}{sig/File}}{in{var1/File}{.{var0/File}{field/link{set of{sig/File}}}}}}}","operations":"[\"(type='Update', node=one, value=lone)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var1/File, parent==, position=0)\", \"(type='Delete', node=var1/File)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/File}}{lone{one of{var1}{sig/File}}{in{var1/File}{.{var0/File}{field/link{set of{sig/File}}}}}}}","totalTED":4,"challenge":"PQAJE67kz8w5NWJuM","time":35969600,"targetExpr":"all f: File | lone l: File | l in f.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all t:Trash | t.link = none } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Trash}}{={.{var0/File}{field/link{set of{sig/File}}}}{none}}}","nextExpr":"all f: File | no f.link&Trash","sourceExpr":"all t:Trash | t.link = none","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=sig/Trash, value=sig/File)\", \"(type='Update', node==, value=&)\", \"(type='Move', tree='{={.{var0/File}{field/link{set of{sig/File}}}}{none}}', parent=no, position=0)\", \"(type='Update', node=none, value=sig/Trash)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":4,"challenge":"PQAJE67kz8w5NWJuM","time":113978200,"targetExpr":"all f: File | no f.link&Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { no t:Trash | t.link != none } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{one of{var0}{sig/Trash}}{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}}","nextExpr":"all f: File | no f.link&Trash","sourceExpr":"no t:Trash | t.link != none","predicate":"inv7","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Insert', node=no, parent=no, position=1)\", \"(type='Update', node=sig/Trash, value=sig/File)\", \"(type='Update', node=!=, value=&)\", \"(type='Move', tree='{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}', parent=no, position=0)\", \"(type='Update', node=none, value=sig/Trash)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":30908800,"targetExpr":"all f: File | no f.link&Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all f:File | f.link not in Trash } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{!in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}","nextExpr":"all f: File | no f.link&Trash","sourceExpr":"all f: File | f.link not in Trash","predicate":"inv7","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}', parent=no, position=0)\"]","hint":"Near a solution! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":115772600,"targetExpr":"all f: File | no f.link&Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no f:File | f in Trash } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:(File-Protected) | f in Trash } pred inv6 { lone f:File | f.link = f } pred inv7 { all f:File | (f in Trash) => (f.link = none) } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link.link = none } pred inv10 { all f:File | (f in Trash) => (f.link in Trash) }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{={.{var0/File}{field/link{set of{sig/File}}}}{none}}}}","nextExpr":"all f: File | f in Trash => no link.f","sourceExpr":"all f:File | (f in Trash) => (f.link = none)","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{no{.{field/link{set of{sig/File}}}{var0/File}}}}}","operations":"[\"(type='Update', node==, value=no)\", \"(type='Insert', node=var0/File, parent=., position=2)\", \"(type='Delete', node=var0/File)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{no{.{field/link{set of{sig/File}}}{var0/File}}}}}","totalTED":4,"challenge":"PQAJE67kz8w5NWJuM","time":49211500,"targetExpr":"all f: File | f in Trash => no link.f","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all f:File | f.^link not in Trash } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{!in{.{var0/File}{^{field/link{set of{sig/File}}}}}{sig/Trash}}}","nextExpr":"all f: File | no (f.^link & Trash)","sourceExpr":"all f:File | f.^link not in Trash","predicate":"inv7","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{^{field/link{set of{sig/File}}}}}{sig/Trash}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/File}{^{field/link{set of{sig/File}}}}}{sig/Trash}}', parent=no, position=0)\"]","hint":"Near a solution! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{^{field/link{set of{sig/File}}}}}{sig/Trash}}}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":31448000,"targetExpr":"all f: File | no (f.^link & Trash)","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all f:File | (f.link != none) => f.link not in Trash } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link.link = none } pred inv10 { all f:File | (f in Trash) => (f.link in Trash) }","sourceAST":"{all{one of{var0}{sig/File}}{=>{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}{!in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","nextExpr":"all f:File | some link.f implies f not in Trash","sourceExpr":"all f:File | (f.link != none) => f.link not in Trash","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{=>{some{.{field/link{set of{sig/File}}}{var0/File}}}{!in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=!=, value=some)\", \"(type='Move', tree='{var0/File}', parent=!in, position=0)\", \"(type='Insert', node=var0/File, parent=., position=2)\", \"(type='Delete', node=var0/File)\", \"(type='Delete', node=none)\", \"(type='TreeDelete', tree='{field/link{set of{sig/File}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using not equal operator ('!=') to specify that the left side is not equal to the right side, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{some{.{field/link{set of{sig/File}}}{var0/File}}}{!in{var0/File}{sig/Trash}}}}","totalTED":8,"challenge":"PQAJE67kz8w5NWJuM","time":42795300,"targetExpr":"all f:File | some link.f implies f not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all f:File | (f.link != none) => f not in Trash } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link.link = none } pred inv10 { all f:File | (f in Trash) => (f.link in Trash) }","sourceAST":"{all{one of{var0}{sig/File}}{=>{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}{!in{var0/File}{sig/Trash}}}}","nextExpr":"all f:File | some link.f implies f not in Trash","sourceExpr":"all f:File | (f.link != none) => f not in Trash","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{=>{some{.{field/link{set of{sig/File}}}{var0/File}}}{!in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=!=, value=some)\", \"(type='Insert', node=var0/File, parent=., position=2)\", \"(type='Delete', node=var0/File)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using not equal operator ('!=') to specify that the left side is not equal to the right side, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{some{.{field/link{set of{sig/File}}}{var0/File}}}{!in{var0/File}{sig/Trash}}}}","totalTED":4,"challenge":"PQAJE67kz8w5NWJuM","time":45998200,"targetExpr":"all f:File | some link.f implies f not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all f : File | not (f.link in Trash) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{!{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","nextExpr":"all f: File | no f.link&Trash","sourceExpr":"all f:File | not (f.link in Trash)","predicate":"inv7","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","operations":"[\"(type='Update', node=!, value=no)\", \"(type='Update', node=in, value=&)\"]","hint":"Near a solution! Instead of using negation operator ('!') to specify that the expression is false, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{one of{var0}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":58384900,"targetExpr":"all f: File | no f.link&Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no f:File | f in Trash } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:(File-Protected) | f in Trash } pred inv6 { lone f:File | f.link = f } pred inv7 { no f:File | (f in Trash) => (f.link != none) } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link.link = none } pred inv10 { all f:File | (f in Trash) => (f.link in Trash) }","sourceAST":"{no{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}}}","nextExpr":"all f: File | f in Trash => no link.f","sourceExpr":"no f:File | (f in Trash) => (f.link != none)","predicate":"inv7","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{no{.{field/link{set of{sig/File}}}{var0/File}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=!=, value=no)\", \"(type='Insert', node=var0/File, parent=., position=2)\", \"(type='Delete', node=var0/File)\", \"(type='Delete', node=none)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{no{.{field/link{set of{sig/File}}}{var0/File}}}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":35240000,"targetExpr":"all f: File | f in Trash => no link.f","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { not (File.link in Trash) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!{in{.{sig/File}{field/link{set of{sig/File}}}}{sig/Trash}}}","nextExpr":"no File.link & Trash","sourceExpr":"not (File.link in Trash)","predicate":"inv7","isNewNode":true,"srcDstTED":2,"targetAST":"{no{&{.{sig/File}{field/link{set of{sig/File}}}}{sig/Trash}}}","operations":"[\"(type='Update', node=!, value=no)\", \"(type='Update', node=in, value=&)\"]","hint":"Near a solution! Instead of using negation operator ('!') to specify that the expression is false, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{no{&{.{sig/File}{field/link{set of{sig/File}}}}{sig/Trash}}}","totalTED":2,"challenge":"PQAJE67kz8w5NWJuM","time":31594700,"targetExpr":"no File.link & Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all f1, f2 : File | f1.link != f2.link } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{!={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}}}","nextExpr":"all f1, f2 : File | no f1.link & f2.~link","sourceExpr":"all a,b : File| a.link != b.link","predicate":"inv9","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=!=, value=&)\", \"(type='Move', tree='{!={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}', parent=no, position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=~, position=0)\"]","hint":"Near a solution! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","totalTED":3,"challenge":"PQAJE67kz8w5NWJuM","time":153364900,"targetExpr":"all f1, f2 : File | no f1.link & f2.~link","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all f1, f2 : File | f1 != f2 implies (no f1.link & f2.link) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{!={var0/File}{var1/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}}}}}","nextExpr":"all f1, f2 : File | no f1.link & f2.~link","sourceExpr":"all a,b : File| a != b => no (a.link & b.link)","predicate":"inv9","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","operations":"[\"(type='Move', tree='{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}}', parent=all, position=1)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=~, position=0)\", \"(type='TreeDelete', tree='{!={var0/File}{var1/File}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! It seems like the no quantifier ('no') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":65827500,"targetExpr":"all f1, f2 : File | no f1.link & f2.~link","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all f1, f2 : File | f1 != f2 implies f1.link != f2.link } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{!={var0/File}{var1/File}}{!={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}}}}","nextExpr":"all f1, f2 : File | no f1.link & f2.~link","sourceExpr":"all a,b : File| a != b => a.link != b.link","predicate":"inv9","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","operations":"[\"(type='Update', node==>, value=no)\", \"(type='Update', node=!=, value=&)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=~, position=0)\", \"(type='TreeDelete', tree='{!={var0/File}{var1/File}}')\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","totalTED":6,"challenge":"PQAJE67kz8w5NWJuM","time":52749800,"targetExpr":"all f1, f2 : File | no f1.link & f2.~link","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all f1, f2 : File | some f1.link implies f1.link != f2.link } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{some{.{var0/File}{field/link{set of{sig/File}}}}}{!={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}}}}","nextExpr":"all f : File | some f.link implies no f.link.link","sourceExpr":"all f1, f2 : File | some f1.link implies f1.link != f2.link","predicate":"inv9","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{=>{some{.{var0/File}{field/link{set of{sig/File}}}}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}}","operations":"[\"(type='Move', tree='{=>{some{.{var0/File}{field/link{set of{sig/File}}}}}{!={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}}', parent=all, position=1)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!=, value=.)\", \"(type='Move', tree='{!={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}', parent=no, position=0)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=!=, position=1)\", \"(type='Delete', node=var1/File)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var1}{sig/File}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the implication operator ('=>') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{=>{some{.{var0/File}{field/link{set of{sig/File}}}}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}}","totalTED":8,"challenge":"PQAJE67kz8w5NWJuM","time":72552700,"targetExpr":"all f : File | some f.link implies no f.link.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { File = Trash } pred inv3 { some Trash } pred inv4 { Protected - Trash = Protected } pred inv5 { File - Protected in Trash } pred inv6 { all f : File | lone f.link } pred inv7 { all l : File.link | not (l in Trash) } pred inv8 { no File.link } pred inv9 { all f1, f2 : File | f1.link = f2.link implies f1 = f2 } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{={.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{field/link{set of{sig/File}}}}}{={var0/File}{var1/File}}}}}","nextExpr":"all f1, f2 : File | no f1.link & f2.~link","sourceExpr":"all f1, f2 : File | f1.link = f2.link implies f1 = f2","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","operations":"[\"(type='Update', node==>, value=no)\", \"(type='Update', node==, value=&)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=~, position=0)\", \"(type='TreeDelete', tree='{={var0/File}{var1/File}}')\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using no quantifier ('no') to specify that there are no elements in a set.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{no{&{.{var0/File}{field/link{set of{sig/File}}}}{.{var1/File}{~{field/link{set of{sig/File}}}}}}}}}","totalTED":6,"challenge":"PQAJE67kz8w5NWJuM","time":37887000,"targetExpr":"all f1, f2 : File | no f1.link & f2.~link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all t: Trash | t.link != File } pred inv2 { File in Trash } pred inv3 { some f: File | f in Trash } pred inv4 { no p: Protected| p in Trash } pred inv5 { all f:File | all p:Protected | (f-p) in Trash } pred inv6 { all f:File | lone l: File | f.link = l } pred inv7 { all t:Trash | t.link = none } pred inv8 { all f:File | f.link = none } pred inv9 { all f:File | f.link != none } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}}","nextExpr":"all f:File | no f.link.link","sourceExpr":"all f:File | f.link != none","predicate":"inv9","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=!=, value=.)\", \"(type='Move', tree='{!={.{var0/File}{field/link{set of{sig/File}}}}{none}}', parent=no, position=0)\", \"(type='Insert', node=field/link, parent=!=, position=1)\", \"(type='Insert', node=set of, parent=field/link, position=0)\", \"(type='Update', node=none, value=sig/File)\", \"(type='Move', tree='{none}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","totalTED":5,"challenge":"PQAJE67kz8w5NWJuM","time":42535600,"targetExpr":"all f:File | no f.link.link","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { Course.enrolled in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{.{sig/Course}{field/enrolled{set of{sig/Course}}}}{sig/Student}}","nextExpr":"enrolled.Course in Student","sourceExpr":"Course.enrolled in Student","predicate":"inv1","isNewNode":false,"srcDstTED":2,"targetAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","operations":"[\"(type='Insert', node=sig/Course, parent=., position=2)\", \"(type='Delete', node=sig/Course)\"]","hint":"Near a solution! Consider adding a signature of type Course to help satisfy the required property. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":131119900,"targetExpr":"enrolled.Course in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person | p in Person.enrolled implies p in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{sig/Person}{field/enrolled{set of{sig/Course}}}}}{in{var0/Person}{sig/Student}}}}","nextExpr":"all p: Person | p in enrolled.Course => p in Student","sourceExpr":"all p: Person | p in Person.enrolled implies p in Student","predicate":"inv1","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{sig/Course}}}{in{var0/Person}{sig/Student}}}}","operations":"[\"(type='Insert', node=sig/Course, parent=., position=2)\", \"(type='Delete', node=sig/Person)\"]","hint":"Near a solution! Consider adding a signature of type Course to help satisfy the required property. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{sig/Course}}}{in{var0/Person}{sig/Student}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":145337100,"targetExpr":"all p: Person | p in enrolled.Course => p in Student","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all c : Course | c.enrolled in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{in{.{var0/Course}{field/enrolled{set of{sig/Course}}}}{sig/Student}}}","nextExpr":"all c : Course | c.~enrolled in Student","sourceExpr":"all c: Course | c.enrolled in Student","predicate":"inv1","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Course}}{in{.{var0/Course}{~{field/enrolled{set of{sig/Course}}}}}{sig/Student}}}","operations":"[\"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=~, position=0)\"]","hint":"One step away from the solution! Consider adding a transpose operator ('~') to transpose a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Course}}{in{.{var0/Course}{~{field/enrolled{set of{sig/Course}}}}}{sig/Student}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":93149600,"targetExpr":"all c : Course | c.~enrolled in Student","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { some p:Person | some(p.enrolled) iff p in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{<=>{in{var0/Person}{sig/Student}}{some{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","nextExpr":"all x : Person | x in (Person-Student) implies no x.enrolled","sourceExpr":"some p:Person | some(p.enrolled) iff p in Student","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='Update', node=some, value=no)\", \"(type='Insert', node=-, parent=in, position=1)\", \"(type='Insert', node=sig/Person, parent=-, position=0)\", \"(type='Move', tree='{sig/Student}', parent=-, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{-{sig/Person}{sig/Student}}}{no{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","totalTED":5,"challenge":"PSqwzYAfW9dFAa9im","time":80458300,"targetExpr":"all x : Person | x in (Person-Student) implies no x.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Person some -> Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/enrolled{set of{sig/Course}}}{some->{sig/Person}{sig/Student}}}","nextExpr":"enrolled.Course in Student","sourceExpr":"enrolled in Person some -> Student","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{sig/Student}', parent=in, position=1)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Move', tree='{sig/Person}', parent=., position=1)\", \"(type='Delete', node=some->)\"]","hint":"Near a solution! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":39636000,"targetExpr":"enrolled.Course in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { some p:Person | some(p.enrolled) implies p in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{=>{some{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var0/Person}{sig/Student}}}}","nextExpr":"all p:Person | some (p.enrolled) implies (p in Student)","sourceExpr":"some p:Person | some(p.enrolled) implies p in Student","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{=>{some{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var0/Person}{sig/Student}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{=>{some{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var0/Person}{sig/Student}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":50298400,"targetExpr":"all p:Person | some (p.enrolled) implies (p in Student)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person | p in Person.enrolled iff p in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{<=>{in{var0/Person}{.{sig/Person}{field/enrolled{set of{sig/Course}}}}}{in{var0/Person}{sig/Student}}}}","nextExpr":"all p: Person | p in enrolled.Course => p in Student","sourceExpr":"all p:Person | p in Person.enrolled iff p in Student","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{sig/Course}}}{in{var0/Person}{sig/Student}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=sig/Course, parent=., position=2)\", \"(type='Delete', node=sig/Person)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{sig/Course}}}{in{var0/Person}{sig/Student}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":38181000,"targetExpr":"all p: Person | p in enrolled.Course => p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student some -> one Course } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/enrolled{set of{sig/Course}}}{some->one{sig/Student}{sig/Course}}}","nextExpr":"enrolled in (Student -> Course)","sourceExpr":"enrolled in Student some -> one Course","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/enrolled{set of{sig/Course}}}{->{sig/Student}{sig/Course}}}","operations":"[\"(type='Update', node=some->one, value=->)\"]","hint":"One step away from the solution! Instead of using some->one, try using arrow operator ('->') to map a relation.","nextAST":"{in{field/enrolled{set of{sig/Course}}}{->{sig/Student}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":32067700,"targetExpr":"enrolled in (Student -> Course)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { Person.enrolled in Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{.{sig/Person}{field/enrolled{set of{sig/Course}}}}{sig/Student}}","nextExpr":"enrolled.Course in Student","sourceExpr":"Person.enrolled in Student","predicate":"inv1","isNewNode":false,"srcDstTED":2,"targetAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","operations":"[\"(type='Insert', node=sig/Course, parent=., position=2)\", \"(type='Delete', node=sig/Person)\"]","hint":"Near a solution! Consider adding a signature of type Course to help satisfy the required property. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":97459000,"targetExpr":"enrolled.Course in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { Person.enrolled= Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{={.{sig/Person}{field/enrolled{set of{sig/Course}}}}{sig/Student}}","nextExpr":"enrolled.Course in Student","sourceExpr":"Person.enrolled = Student","predicate":"inv1","isNewNode":false,"srcDstTED":3,"targetAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=sig/Course, parent=., position=2)\", \"(type='Delete', node=sig/Person)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{.{field/enrolled{set of{sig/Course}}}{sig/Course}}{sig/Student}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":102007900,"targetExpr":"enrolled.Course in Student","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all s:Student, c:Course | s -> c in enrolled implies s not in Professor } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{!in{var0/Person}{sig/Professor}}}}}","nextExpr":"all p : Person ,c : Course | p->c in enrolled implies p in Student","sourceExpr":"all s:Student, c:Course | s -> c in enrolled implies s not in Professor","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{in{var0/Person}{sig/Student}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=sig/Professor, value=sig/Student)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{in{var0/Person}{sig/Student}}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":43826100,"targetExpr":"all p : Person ,c : Course | p->c in enrolled implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student one -> some Course } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/enrolled{set of{sig/Course}}}{one->some{sig/Student}{sig/Course}}}","nextExpr":"enrolled in (Student -> Course)","sourceExpr":"enrolled in Student one -> some Course","predicate":"inv1","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/enrolled{set of{sig/Course}}}{->{sig/Student}{sig/Course}}}","operations":"[\"(type='Update', node=one->some, value=->)\"]","hint":"One step away from the solution! Instead of using one->some, try using arrow operator ('->') to map a relation.","nextAST":"{in{field/enrolled{set of{sig/Course}}}{->{sig/Student}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":33287300,"targetExpr":"enrolled in (Student -> Course)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all s:Student | s not in Professor } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{!in{var0/Person}{sig/Professor}}}","nextExpr":"all p : enrolled.Course | p in Student","sourceExpr":"all s:Student | s not in Professor","predicate":"inv1","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{.{field/enrolled{set of{sig/Course}}}{sig/Course}}}{in{var0/Person}{sig/Student}}}","operations":"[\"(type='Update', node=!in, value=in)\", \"(type='Insert', node=., parent=one of, position=1)\", \"(type='Update', node=sig/Professor, value=sig/Student)\", \"(type='Insert', node=field/enrolled, parent=., position=0)\", \"(type='Insert', node=sig/Course, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Move', tree='{sig/Student}', parent=set of, position=0)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{.{field/enrolled{set of{sig/Course}}}{sig/Course}}}{in{var0/Person}{sig/Student}}}","totalTED":7,"challenge":"PSqwzYAfW9dFAa9im","time":33300500,"targetExpr":"all p : enrolled.Course | p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled = Student -> Course } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{={->{sig/Student}{sig/Course}}{field/enrolled{set of{sig/Course}}}}","nextExpr":"Student <: enrolled = enrolled","sourceExpr":"enrolled = Student -> Course","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{={<:{sig/Student}{field/enrolled{set of{sig/Course}}}}{field/enrolled{set of{sig/Course}}}}","operations":"[\"(type='Update', node=->, value=<:)\", \"(type='Insert', node=field/enrolled, parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Move', tree='{sig/Course}', parent=set of, position=0)\"]","hint":"Near a solution! Instead of using arrow operator ('->') to map a relation, try using restriction operator ('<:') to restrict the domain of a relation.","nextAST":"{={<:{sig/Student}{field/enrolled{set of{sig/Course}}}}{field/enrolled{set of{sig/Course}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":31294200,"targetExpr":"Student <: enrolled = enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all s:Student, c:Course | s -> c in enrolled } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}","nextExpr":"all p : Person ,c : Course | p->c in enrolled implies p in Student","sourceExpr":"all s: Student, c: Course | s -> c in enrolled","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{in{var0/Person}{sig/Student}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Person}{sig/Student}}', parent==>, position=1)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{in{var0/Person}{sig/Student}}}}}","totalTED":5,"challenge":"PSqwzYAfW9dFAa9im","time":98329500,"targetExpr":"all p : Person ,c : Course | p->c in enrolled implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { no p:Person | p in Professor & Student all p:Person | p.enrolled != none } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{!={.{var0/Person}{field/enrolled{set of{sig/Course}}}}{none}}}{no{one of{var0}{sig/Person}}{in{var0/Person}{&{sig/Professor}{sig/Student}}}}}","nextExpr":"all p:Person | some p.(Course.grades) implies p in Student","sourceExpr":"no p:Person | p in Professor & Student all p:Person | p.enrolled != none","predicate":"inv10","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Person}}{=>{some{.{var0/Person}{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}{in{var0/Person}{sig/Student}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=AND, position=0)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=!=, value=some)\", \"(type='Move', tree='{!={.{var0/Person}{field/enrolled{set of{sig/Course}}}}{none}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/Person}{&{sig/Professor}{sig/Student}}}', parent==>, position=1)\", \"(type='Move', tree='{sig/Student}', parent=in, position=1)\", \"(type='Update', node=set of, value=.)\", \"(type='Move', tree='{set of{sig/Course}}', parent=., position=1)\", \"(type='TreeInsert', tree='{field/grades{->{sig/Person}{sig/Grade}}}', parent=set of, position=1)\", \"(type='Delete', node=field/enrolled)\", \"(type='Delete', node=none)\", \"(type='Delete', node=sig/Professor)\", \"(type='Delete', node=&)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Person}}')\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{=>{some{.{var0/Person}{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}{in{var0/Person}{sig/Student}}}}","totalTED":17,"challenge":"PSqwzYAfW9dFAa9im","time":123531000,"targetExpr":"all p:Person | some p.(Course.grades) implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Person,c:Course | p1->c in enrolled and p2->c in teaches implies (p1 + p2) not in Professor } pred inv10 { all p:Person,c:Course,g:Grade | p->c->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var0/Person}{->{var1/Course}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","nextExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","sourceExpr":"all p : Person | all c : Course | all g : Grade | (p->c->g in grades) implies (p in Student)","predicate":"inv10","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=var1/Course, value=var0/Person)\"]","hint":"Near a solution! Instead of using variable of type Person, try using variable of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":85821200,"targetExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { all p : Person, c: Course, g: Grade | c -> p -> g in grades and p -> c in enrolled <=> p not in Professor } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{<=>{!in{var0/Person}{sig/Professor}}{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","sourceExpr":"all p : Person, c: Course, g: Grade | c -> p -> g in grades and p -> c in enrolled <=> p not in Professor","predicate":"inv10","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}', parent=all, position=1)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Update', node=var1/Course, value=sig/Student)\", \"(type='Move', tree='{var1/Course}', parent=in, position=1)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/enrolled{set of{sig/Course}}}')\", \"(type='TreeDelete', tree='{!in{var0/Person}{sig/Professor}}')\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":72559000,"targetExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { all p: Person | all c: p.enrolled | c.grades[p] in Grade all s: Student | all c: s.enrolled | c.grades[s] in Grade all p: Professor | all c: p.teaches | no c.grades[p] all o: Person - Student - Professor | all c: o.enrolled | no c.grades[o] } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}}}{all{one of{var2}{sig/Student}}{all{one of{var1}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var2/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}}}{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}{all{one of{var3}{-{-{sig/Person}{sig/Student}}{sig/Professor}}}{all{one of{var1}{.{var3/Person}{field/enrolled{set of{sig/Course}}}}}{no{.{var3/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}}","nextExpr":"Course.grades.Grade in Student all p : Person | p in Course.grades.Grade implies p in Student","sourceExpr":"all p: Person | all c: p.enrolled | c.grades[p] in Grade all s: Student | all c: s.enrolled | c.grades[s] in Grade all p: Professor | all c: p.teaches | no c.grades[p] all o: Person - Student - Professor | all c: o.enrolled | no c.grades[o]","predicate":"inv10","isNewNode":true,"srcDstTED":75,"targetAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}{in{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}{sig/Student}}}","operations":"[\"(type='Insert', node=all, parent=AND, position=0)\", \"(type='Move', tree='{in{.{var2/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}', parent=AND, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=sig/Grade, value=sig/Student)\", \"(type='Move', tree='{in{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}', parent==>, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Student}}', parent==>, position=1)\", \"(type='Insert', node=sig/Grade, parent=., position=2)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=var2, value=var0/Person)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Grade}', parent=., position=1)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Person)\", \"(type='TreeDelete', tree='{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{one of{var1}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}')\", \"(type='TreeDelete', tree='{all{one of{var3}{-{-{sig/Person}{sig/Student}}{sig/Professor}}}{all{one of{var1}{.{var3/Person}{field/enrolled{set of{sig/Course}}}}}{no{.{var3/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}')\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the conjunction operator ('and') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}{in{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}{sig/Student}}}","totalTED":75,"challenge":"PSqwzYAfW9dFAa9im","time":47123100,"targetExpr":"Course.grades.Grade in Student all p : Person | p in Course.grades.Grade implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { no p: Person | p in Professor & Student all p: Person | all c: p.enrolled | c.grades[p] in Grade all s: Student | all c: s.enrolled | c.grades[s] in Grade all p: Professor | all c: p.teaches | no c.grades[p] all c: Course | no c.enrolled implies all p: Professor | no c.grades[p] } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}}}{all{one of{var2}{sig/Student}}{all{one of{var1}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var2/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}}}{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}{all{one of{var1}{sig/Course}}{=>{no{.{var1/Course}{field/enrolled{set of{sig/Course}}}}}{all{one of{var0}{sig/Professor}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}}{no{one of{var0}{sig/Person}}{in{var0/Person}{&{sig/Professor}{sig/Student}}}}}","nextExpr":"Course.grades.Grade in Student all p : Person | p in Course.grades.Grade implies p in Student","sourceExpr":"no p: Person | p in Professor & Student all p: Person | all c: p.enrolled | c.grades[p] in Grade all s: Student | all c: s.enrolled | c.grades[s] in Grade all p: Professor | all c: p.teaches | no c.grades[p] all c: Course | no c.enrolled implies all p: Professor | no c.grades[p]","predicate":"inv10","isNewNode":true,"srcDstTED":83,"targetAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}{in{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}{sig/Student}}}","operations":"[\"(type='Insert', node=all, parent=AND, position=0)\", \"(type='Move', tree='{in{.{var2/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}', parent=AND, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=sig/Grade, value=sig/Student)\", \"(type='Move', tree='{in{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}', parent==>, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Student}}', parent==>, position=1)\", \"(type='Insert', node=sig/Grade, parent=., position=2)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=var2, value=var0/Person)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Grade}', parent=., position=1)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Person)\", \"(type='TreeDelete', tree='{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{one of{var1}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}')\", \"(type='TreeDelete', tree='{all{one of{var1}{sig/Course}}{=>{no{.{var1/Course}{field/enrolled{set of{sig/Course}}}}}{all{one of{var0}{sig/Professor}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}}')\", \"(type='TreeDelete', tree='{no{one of{var0}{sig/Person}}{in{var0/Person}{&{sig/Professor}{sig/Student}}}}')\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the conjunction operator ('and') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}{in{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}{sig/Student}}}","totalTED":83,"challenge":"PSqwzYAfW9dFAa9im","time":43027800,"targetExpr":"Course.grades.Grade in Student all p : Person | p in Course.grades.Grade implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { } pred inv10 { all p: Person | some g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Grade}}{some{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{->{var0/Person}{var1/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","nextExpr":"all p: Person | all g: Grade | all c: Course | c->p->g in grades implies p in Student","sourceExpr":"all p: Person | some g: Grade, c: Course | c->p->g in grades implies p in Student","predicate":"inv10","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Grade}}{all{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{->{var0/Person}{var1/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Grade}}{all{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{->{var0/Person}{var1/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":84092600,"targetExpr":"all p: Person | all g: Grade | all c: Course | c->p->g in grades implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { all p : Person, c: Course, g: Grade | c -> p -> g in grades <=> p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{<=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","nextExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","sourceExpr":"all p : Person, c: Course, g: Grade | c -> p -> g in grades <=> p in Student","predicate":"inv10","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\"]","hint":"One step away from the solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":28121500,"targetExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { all t:Professor, c:Course | c in t.teaches implies (all p:Person | c in p.enrolled and p not in Professor) } pred inv10 { all c:Course, g:Grade | some p:Person | c -> p -> g in grades implies p not in Professor } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Grade}}{some{one of{var2}{sig/Person}}{=>{in{->{var0/Course}{->{var2/Person}{var1/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{!in{var2/Person}{sig/Professor}}}}}}","nextExpr":"all c: Course | all p: Person | all g: Grade | c->p->g in grades implies p in Student","sourceExpr":"all c:Course, g:Grade | some p:Person | c -> p -> g in grades implies p not in Professor","predicate":"inv10","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Grade}}{=>{in{->{var0/Course}{->{var1/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Grade, value=sig/Person)\", \"(type='Update', node=sig/Person, value=sig/Grade)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=sig/Professor, value=sig/Student)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var1/Grade, value=var2/Grade)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Grade}}{=>{in{->{var0/Course}{->{var1/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var1/Person}{sig/Student}}}}}}","totalTED":8,"challenge":"PSqwzYAfW9dFAa9im","time":31817600,"targetExpr":"all c: Course | all p: Person | all g: Grade | c->p->g in grades implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { all p : Person, c: Course, g: Grade | c -> p -> g in grades and p -> c in enrolled <=> p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{<=>{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}{in{var0/Person}{sig/Student}}}}}}","nextExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","sourceExpr":"all p : Person, c: Course, g: Grade | c -> p -> g in grades and p -> c in enrolled <=> p in Student","predicate":"inv10","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Move', tree='{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=<=>, position=0)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":80385600,"targetExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { all p : Person, c: Course, g: Grade | c -> p -> g in grades => p not in Professor } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{!in{var0/Person}{sig/Professor}}}}}}","nextExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","sourceExpr":"all p : Person, c : Course, g : Grade | (c->p->g in grades) implies p not in Professor","predicate":"inv10","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=!in, value=in)\", \"(type='Update', node=sig/Professor, value=sig/Student)\"]","hint":"Near a solution! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":43019800,"targetExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { all t:Professor, c:Course | c in t.teaches implies (all p:Person | c in p.enrolled and p not in Professor) } pred inv10 { all c:Course, p:Person, g:Grade | c -> p -> g in grades implies p not in Professor } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Grade}}{=>{in{->{var0/Course}{->{var1/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{!in{var1/Person}{sig/Professor}}}}}}","nextExpr":"all c: Course | all p: Person | all g: Grade | c->p->g in grades implies p in Student","sourceExpr":"all c:Course, p:Person, g:Grade | c -> p -> g in grades implies p not in Professor","predicate":"inv10","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Grade}}{=>{in{->{var0/Course}{->{var1/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=!in, value=in)\", \"(type='Update', node=sig/Professor, value=sig/Student)\"]","hint":"Near a solution! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Grade}}{=>{in{->{var0/Course}{->{var1/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var1/Person}{sig/Student}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":37406700,"targetExpr":"all c: Course | all p: Person | all g: Grade | c->p->g in grades implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { no p: Person | p in Professor & Student all p: Person | all c: p.enrolled | c.grades[p] in Grade all s: Student | all c: s.enrolled | c.grades[s] in Grade all p: Professor | all c: p.teaches | no c.grades[p] all o: Person - Student - Professor | all c: o.enrolled | no c.grades[o] } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{all{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}}}{all{one of{var2}{sig/Student}}{all{one of{var1}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}{in{.{var2/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}}}{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}{all{one of{var3}{-{-{sig/Person}{sig/Student}}{sig/Professor}}}{all{one of{var1}{.{var3/Person}{field/enrolled{set of{sig/Course}}}}}{no{.{var3/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}{no{one of{var0}{sig/Person}}{in{var0/Person}{&{sig/Professor}{sig/Student}}}}}","nextExpr":"Course.grades.Grade in Student all p : Person | p in Course.grades.Grade implies p in Student","sourceExpr":"no p: Person | p in Professor & Student all p: Person | all c: p.enrolled | c.grades[p] in Grade all s: Student | all c: s.enrolled | c.grades[s] in Grade all p: Professor | all c: p.teaches | no c.grades[p] all o: Person - Student - Professor | all c: o.enrolled | no c.grades[o]","predicate":"inv10","isNewNode":true,"srcDstTED":84,"targetAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}{in{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}{sig/Student}}}","operations":"[\"(type='Insert', node=all, parent=AND, position=0)\", \"(type='Move', tree='{in{.{var2/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}', parent=AND, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=sig/Grade, value=sig/Student)\", \"(type='Move', tree='{in{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}{sig/Grade}}', parent==>, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Student}}', parent==>, position=1)\", \"(type='Insert', node=sig/Grade, parent=., position=2)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=var2, value=var0/Person)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Move', tree='{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Grade}', parent=., position=1)\", \"(type='Update', node=var1/Course, value=sig/Course)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Person)\", \"(type='TreeDelete', tree='{one of{var1}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{one of{var1}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{all{one of{var0}{sig/Professor}}{all{one of{var1}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{no{.{var0/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}')\", \"(type='TreeDelete', tree='{all{one of{var3}{-{-{sig/Person}{sig/Student}}{sig/Professor}}}{all{one of{var1}{.{var3/Person}{field/enrolled{set of{sig/Course}}}}}{no{.{var3/Person}{.{var1/Course}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}')\", \"(type='TreeDelete', tree='{no{one of{var0}{sig/Person}}{in{var0/Person}{&{sig/Professor}{sig/Student}}}}')\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the conjunction operator ('and') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}}{in{var0/Person}{sig/Student}}}}{in{.{.{sig/Course}{field/grades{->{sig/Person}{sig/Grade}}}}{sig/Grade}}{sig/Student}}}","totalTED":84,"challenge":"PSqwzYAfW9dFAa9im","time":51089500,"targetExpr":"Course.grades.Grade in Student all p : Person | p in Course.grades.Grade implies p in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { all p : Person, c: Course, g: Grade | c -> p -> g in grades <=> p not in Professor and p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{<=>{AND{!in{var0/Person}{sig/Professor}}{in{var0/Person}{sig/Student}}}{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","nextExpr":"all p : Person, c : Course, g : Grade | p not in Student implies c->p->g not in grades","sourceExpr":"all p : Person, c: Course, g: Grade | c -> p -> g in grades <=> p not in Professor and p in Student","predicate":"inv10","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{!in{var0/Person}{sig/Student}}{!in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Move', tree='{!in{var0/Person}{sig/Professor}}', parent=<=>, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Professor, value=sig/Student)\", \"(type='TreeDelete', tree='{in{var0/Person}{sig/Student}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{!in{var0/Person}{sig/Student}}{!in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","totalTED":7,"challenge":"PSqwzYAfW9dFAa9im","time":39219300,"targetExpr":"all p : Person, c : Course, g : Grade | p not in Student implies c->p->g not in grades","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { no p: Person | p in Professor & Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Person}}{in{var0/Person}{&{sig/Professor}{sig/Student}}}}","nextExpr":"grades in Course -> Student -> Grade","sourceExpr":"no p: Person | p in Professor & Student","predicate":"inv10","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->{sig/Student}{sig/Grade}}}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Insert', node=field/grades, parent=no, position=0)\", \"(type='Update', node=in, value=->)\", \"(type='Update', node=one of, value=->)\", \"(type='Move', tree='{one of{var0}{sig/Person}}', parent=field/grades, position=0)\", \"(type='Update', node=var0/Person, value=sig/Course)\", \"(type='Update', node=&, value=->)\", \"(type='Insert', node=sig/Grade, parent=one of, position=2)\", \"(type='Insert', node=sig/Grade, parent=&, position=2)\", \"(type='Delete', node=var0)\", \"(type='Delete', node=sig/Professor)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->{sig/Student}{sig/Grade}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":48478900,"targetExpr":"grades in Course -> Student -> Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { all p : Person, c: Course, g: Grade | c -> p -> g in grades <=> p not in Professor } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{<=>{!in{var0/Person}{sig/Professor}}{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","nextExpr":"all p : Person, c : Course, g : Grade | p not in Student implies c->p->g not in grades","sourceExpr":"all p : Person, c: Course, g: Grade | c -> p -> g in grades <=> p not in Professor","predicate":"inv10","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{!in{var0/Person}{sig/Student}}{!in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Professor, value=sig/Student)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{!in{var0/Person}{sig/Student}}{!in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":36023900,"targetExpr":"all p : Person, c : Course, g : Grade | p not in Student implies c->p->g not in grades","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Person,c:Course | p1->c in enrolled and p2->c in teaches implies (p1 + p2) not in Professor } pred inv10 { all p:Person,c:Course,g:Grade | c->p->g in grades and p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","nextExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","sourceExpr":"all p:Person,c:Course,g:Grade | c->p->g in grades and p in Student","predicate":"inv10","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{=>{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{var0/Person}{sig/Student}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":44300000,"targetExpr":"all s1: Person | all c1: Course | all g1: Grade | (c1->s1->g1 in grades) implies s1 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and s -> c in enrolled) } pred inv7 { all p1:Project,p2:Project,s:Student,c:Course | s -> p1 in Person <: projects and c -> p1 in Course <: projects and s -> p2 in Person <: projects and c -> p2 in Course <: projects implies p1 = p2 } pred inv8 { no p:Professor,c:Course | p -> c in teaches and p -> c in enrolled } pred inv9 { } pred inv10 { grades in Course -> Student -> Grade } pred inv11 { all c:Course,s:Student | (some g:Grade | c -> s -> g in grades) implies s -> c in enrolled } pred inv12 { grades in Course -> Person -> Grade } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->{sig/Person}{sig/Grade}}}}","nextExpr":"grades in Course -> Person -> lone Grade","sourceExpr":"grades in Course -> Person -> Grade","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Person}{sig/Grade}}}}","operations":"[\"(type='Update', node=->, value=->lone)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using ->lone to help satisfy the required property.","nextAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Person}{sig/Grade}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":82429500,"targetExpr":"grades in Course -> Person -> lone Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and s -> c in enrolled) } pred inv7 { all p1:Project,p2:Project,s:Student,c:Course | s -> p1 in Person <: projects and c -> p1 in Course <: projects and s -> p2 in Person <: projects and c -> p2 in Course <: projects implies p1 = p2 } pred inv8 { no p:Professor,c:Course | p -> c in teaches and p -> c in enrolled } pred inv9 { } pred inv10 { grades in Course -> Student -> Grade } pred inv11 { all c:Course,s:Student | (some g:Grade | c -> s -> g in grades) implies s -> c in enrolled } pred inv12 { grades in Course -> Person lone -> Grade } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{lone->{sig/Person}{sig/Grade}}}}","nextExpr":"grades in Course set -> set Person -> lone Grade","sourceExpr":"grades in Course -> Person lone -> Grade","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Person}{sig/Grade}}}}","operations":"[\"(type='Update', node=lone->, value=->lone)\"]","hint":"One step away from the solution! Instead of using lone->, try using ->lone to help satisfy the required property.","nextAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Person}{sig/Grade}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":38585800,"targetExpr":"grades in Course set -> set Person -> lone Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { grades in Course -> Student -> Grade } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->{sig/Student}{sig/Grade}}}}","nextExpr":"grades in Course -> Student -> lone Grade","sourceExpr":"grades in Course -> Student -> Grade","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Student}{sig/Grade}}}}","operations":"[\"(type='Update', node=->, value=->lone)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using ->lone to help satisfy the required property.","nextAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Student}{sig/Grade}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":38369500,"targetExpr":"grades in Course -> Student -> lone Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and s -> c in enrolled) } pred inv7 { all p1:Project,p2:Project,s:Student,c:Course | s -> p1 in Person <: projects and c -> p1 in Course <: projects and s -> p2 in Person <: projects and c -> p2 in Course <: projects implies p1 = p2 } pred inv8 { no p:Professor,c:Course | p -> c in teaches and p -> c in enrolled } pred inv9 { } pred inv10 { grades in Course -> Student -> Grade } pred inv11 { all c:Course,s:Student | (some g:Grade | c -> s -> g in grades) implies s -> c in enrolled } pred inv12 { grades in Course -> Person one -> Grade } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{one->{sig/Person}{sig/Grade}}}}","nextExpr":"grades in Course set -> set Person -> lone Grade","sourceExpr":"grades in Course -> Person one -> Grade","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Person}{sig/Grade}}}}","operations":"[\"(type='Update', node=one->, value=->lone)\"]","hint":"One step away from the solution! Instead of using one->, try using ->lone to help satisfy the required property.","nextAST":"{in{field/grades{->{sig/Person}{sig/Grade}}}{->{sig/Course}{->lone{sig/Person}{sig/Grade}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":33017900,"targetExpr":"grades in Course set -> set Person -> lone Grade","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Person,c:Course | p1->c in enrolled and p2->c in teaches implies (p1 + p2) not in Professor } pred inv10 { all p:Person,c:Course,g:Grade | c->p->g in grades implies p in Student } pred inv11 { all s:Student,c:Course,g:Grade | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student,c:Course | one g:Grade | c->s->g in grades } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{one{one of{var2}{sig/Grade}}{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}","nextExpr":"all s:Student, c:Course | lone g:Grade | c->s->g in grades","sourceExpr":"all x: Student, y:Course | one z:Grade | y->x->z in grades","predicate":"inv12","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{one of{var2}{sig/Grade}}{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}","operations":"[\"(type='Update', node=one, value=lone)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{lone{one of{var2}{sig/Grade}}{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":104903900,"targetExpr":"all s:Student, c:Course | lone g:Grade | c->s->g in grades","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s1, s2: Student | some p1, p2: Project| s1->p1 in Person <: projects and s2->p1 in Person <: projects and s1->p2 in Person <: projects and s2->p2 in Person <: projects and s1 != s2 } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Project}}{some{one of{var3}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s1,s2:Student, p1,p2:Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","sourceExpr":"not some s1, s2: Student | some p1, p2: Project| s1->p1 in Person <: projects and s2->p1 in Person <: projects and s1->p2 in Person <: projects and s2->p2 in Person <: projects and s1 != s2","predicate":"inv14","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Project}}{some{one of{var3}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Move', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=4)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":124475900,"targetExpr":"all s1,s2:Student, p1,p2:Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Person,c:Course | p1->c in enrolled and p2->c in teaches implies (p1 + p2) not in Professor } pred inv10 { all p:Person,c:Course,g:Grade | c->p->g in grades implies p in Student } pred inv11 { all s:Student,c:Course,g:Grade | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student,c:Course | lone g:Grade | c->s->g in grades } pred inv13 { } pred inv14 { all s1,s2:Student,p1,p2:Project | s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects implies p1=p2 } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Project}{var3/Project}}}}}}}","nextExpr":"all p1,p2:Person, j1,j2:Project | p1->j1 in projects and p2->j1 in projects and p1->j2 in projects and p2->j2 in projects implies p1 = p2 or j1 = j2","sourceExpr":"all s1,s2:Student,p1,p2:Project | s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects implies p1=p2","predicate":"inv14","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{OR{={var2/Project}{var3/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{={var0/Person}{var1/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Insert', node=OR, parent=all, position=1)\", \"(type='TreeInsert', tree='{={var2/Project}{var3/Project}}', parent=OR, position=0)\", \"(type='Move', tree='{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Project}{var3/Project}}}', parent=OR, position=1)\", \"(type='Update', node=var2/Project, value=var0/Person)\", \"(type='Update', node=var3/Project, value=var1/Person)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{OR{={var2/Project}{var3/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{={var0/Person}{var1/Person}}}}}}}}","totalTED":8,"challenge":"PSqwzYAfW9dFAa9im","time":86572000,"targetExpr":"all p1,p2:Person, j1,j2:Project | p1->j1 in projects and p2->j1 in projects and p1->j2 in projects and p2->j2 in projects implies p1 = p2 or j1 = j2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s1, s2: Student | some p1, p2: Project| s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Project}}{some{one of{var3}{sig/Project}}{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s1,s2:Student, p1,p2:Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","sourceExpr":"not some s1, s2: Student | some p1, p2: Project| s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects","predicate":"inv14","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Project}}{some{one of{var3}{sig/Project}}{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Move', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=4)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":14,"challenge":"PSqwzYAfW9dFAa9im","time":48436200,"targetExpr":"all s1,s2:Student, p1,p2:Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { all s1, s2: Student, p: Project | s1->p in Student <: projects and s2->p in Student <: projects implies (not some p2: Project| s1->p2 in Student <: projects and s2->p2 in Student <: projects and p!=p2) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}{in{->{var1/Person}{var2/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}}{!{some{one of{var3}{sig/Project}}{AND{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var3/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}{in{->{var1/Person}{var3/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}}}}}}}}","nextExpr":"all x,y:Student, p:Project | (x->p in projects and y->p in projects and x!=y) implies (all p1:Project-p | x->p1 not in projects or y->p1 not in projects)","sourceExpr":"all s1, s2: Student, p: Project | s1->p in Student <: projects and s2->p in Student <: projects implies (not some p2: Project| s1->p2 in Student <: projects and s2->p2 in Student <: projects and p!=p2)","predicate":"inv14","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{-{sig/Project}{var2/Project}}}{OR{!in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var3}{sig/Project}}{AND{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var3/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}{in{->{var1/Person}{var3/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}}}', parent==>, position=1)\", \"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='Update', node=AND, value=OR)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{sig/Project}', parent=-, position=0)\", \"(type='Insert', node=var2/Project, parent=-, position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='TreeDelete', tree='{!={var2/Project}{var3/Project}}')\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{-{sig/Project}{var2/Project}}}{OR{!in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":51403000,"targetExpr":"all x,y:Student, p:Project | (x->p in projects and y->p in projects and x!=y) implies (all p1:Project-p | x->p1 not in projects or y->p1 not in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s: Student | some c: Course| s->c in teaches not some s1, s2: Student | all p1, p2: Project| s1->p1 in Person <: projects and s2->p1 in Person <: projects and s1->p2 in Person <: projects and s2->p2 in Person <: projects and s1 != s2 all s1, s2: Student, p: Project | s1->p in Person <: projects and s2->p in Person <: projects implies (not some p2: Project| s1->p2 in Person <: projects and s2->p2 in Person <: projects and p!=p2) } pred inv15 { }","sourceAST":"{AND{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}}{!{some{one of{var2}{sig/Student}}{some{one of{var3}{sig/Student}}{all{one of{var4}{sig/Project}}{all{one of{var5}{sig/Project}}{AND{!={var2/Person}{var3/Person}}{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}}}}}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Student}}{all{one of{var6}{sig/Project}}{=>{AND{in{->{var2/Person}{var6/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var6/Project}}{field/projects{set of{sig/Project}}}}}{!{some{one of{var5}{sig/Project}}{AND{!={var5/Project}{var6/Project}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}}","nextExpr":"all p1, p2 : Project, s1, s2: Student | p1 != p2 and s1 != s2 => not (s1->p1 in projects and s1->p2 in projects and s2->p1 in projects and s2->p2 in projects)","sourceExpr":"not some s: Student | some c: Course| s->c in teaches not some s1, s2: Student | all p1, p2: Project| s1->p1 in Person <: projects and s2->p1 in Person <: projects and s1->p2 in Person <: projects and s2->p2 in Person <: projects and s1 != s2 all s1, s2: Student, p: Project | s1->p in Person <: projects and s2->p in Person <: projects implies (not some p2: Project| s1->p2 in Person <: projects and s2->p2 in Person <: projects and p!=p2)","predicate":"inv14","isNewNode":true,"srcDstTED":86,"targetAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Student}}{=>{AND{!={var0/Project}{var1/Project}}{!={var2/Person}{var3/Person}}}{!{AND{in{->{var2/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Student}}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Move', tree='{one of{var1}{sig/Course}}', parent=all, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var2}{sig/Student}}{some{one of{var3}{sig/Student}}{all{one of{var4}{sig/Project}}{all{one of{var5}{sig/Project}}{AND{!={var2/Person}{var3/Person}}{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=all, value==>)\", \"(type='Move', tree='{all{one of{var5}{sig/Project}}{AND{!={var2/Person}{var3/Person}}{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}}', parent=some, position=1)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Insert', node=!, parent=all, position=1)\", \"(type='Update', node=one of, value=!=)\", \"(type='Move', tree='{one of{var5}{sig/Project}}', parent=AND, position=0)\", \"(type='Move', tree='{!={var2/Person}{var3/Person}}', parent=AND, position=1)\", \"(type='Insert', node=AND, parent=!, position=0)\", \"(type='Update', node=var5, value=var0/Project)\", \"(type='Update', node=sig/Project, value=var1/Project)\", \"(type='Move', tree='{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var3/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Update', node=var4/Project, value=var0/Project)\", \"(type='Update', node=var3/Person, value=var2/Person)\", \"(type='Update', node=var4/Project, value=var1/Project)\", \"(type='Update', node=var2/Person, value=var3/Person)\", \"(type='Update', node=var5/Project, value=var0/Project)\", \"(type='Update', node=var5/Project, value=var1/Project)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{one of{var4}{sig/Project}}')\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\", \"(type='Delete', node=!)\", \"(type='Delete', node=!)\", \"(type='TreeDelete', tree='{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Student}}{all{one of{var6}{sig/Project}}{=>{AND{in{->{var2/Person}{var6/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var6/Project}}{field/projects{set of{sig/Project}}}}}{!{some{one of{var5}{sig/Project}}{AND{!={var5/Project}{var6/Project}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}')\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Student}}{=>{AND{!={var0/Project}{var1/Project}}{!={var2/Person}{var3/Person}}}{!{AND{in{->{var2/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","totalTED":86,"challenge":"PSqwzYAfW9dFAa9im","time":81509800,"targetExpr":"all p1, p2 : Project, s1, s2: Student | p1 != p2 and s1 != s2 => not (s1->p1 in projects and s1->p2 in projects and s2->p1 in projects and s2->p2 in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s1, s2: Student | all p1, p2: Project| s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects and s1 != s2 } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s1,s2 : Student | all p1,p2 : Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","sourceExpr":"not some s1, s2: Student | all p1, p2: Project| s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects and s1 != s2","predicate":"inv14","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Move', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=4)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":49272900,"targetExpr":"all s1,s2 : Student | all p1,p2 : Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s1, s2: Student | all p1, p2: Project| s1->p1 in Person <: projects and s2->p1 in Person <: projects and s1->p2 in Person <: projects and s2->p2 in Person <: projects and s1 != s2 all s1, s2: Student, p: Project | s1->p in Person <: projects and s2->p in Person <: projects implies (not some p2: Project| s1->p2 in Person <: projects and s2->p2 in Person <: projects and p!=p2) } pred inv15 { }","sourceAST":"{AND{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var4}{sig/Project}}{=>{AND{in{->{var0/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}}{!{some{one of{var3}{sig/Project}}{AND{!={var3/Project}{var4/Project}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}}","nextExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","sourceExpr":"not some s1, s2: Student | all p1, p2: Project| s1->p1 in Person <: projects and s2->p1 in Person <: projects and s1->p2 in Person <: projects and s2->p2 in Person <: projects and s1 != s2 all s1, s2: Student, p: Project | s1->p in Person <: projects and s2->p in Person <: projects implies (not some p2: Project| s1->p2 in Person <: projects and s2->p2 in Person <: projects and p!=p2)","predicate":"inv14","isNewNode":true,"srcDstTED":60,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Student}}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Student}}', parent=all, position=0)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Project}}', parent=all, position=0)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='Move', tree='{one of{var3}{sig/Project}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{!{some{one of{var3}{sig/Project}}{AND{!={var4/Project}{var3/Project}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}', parent==>, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Move', tree='{AND{!={var4/Project}{var3/Project}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}', parent=!, position=0)\", \"(type='Move', tree='{var2/Project}', parent=in, position=0)\", \"(type='Update', node=sig/Project, value=var3/Project)\", \"(type='Move', tree='{sig/Project}', parent=in, position=1)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var3/Project, value=var2/Project)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=->)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/projects)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}')\", \"(type='TreeDelete', tree='{!={var4/Project}{var3/Project}}')\", \"(type='TreeDelete', tree='{one of{var3}{sig/Project}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\", \"(type='Delete', node=!)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Student}}')\", \"(type='TreeDelete', tree='{one of{var1}{sig/Student}}')\", \"(type='TreeDelete', tree='{one of{var4}{sig/Project}}')\", \"(type='TreeDelete', tree='{AND{in{->{var0/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","totalTED":60,"challenge":"PSqwzYAfW9dFAa9im","time":70936600,"targetExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s: Student | some c: Course| s->c in teaches all s1, s2: Student, p: Project | s1->p in Student <: projects and s2->p in Student <: projects implies (not some p2: Project| s1->p2 in Student <: projects and s2->p2 in Student <: projects and p!=p2) } pred inv15 { }","sourceAST":"{AND{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Student}}{all{one of{var4}{sig/Project}}{=>{AND{in{->{var2/Person}{var4/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}{in{->{var3/Person}{var4/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}}{!{some{one of{var5}{sig/Project}}{AND{!={var4/Project}{var5/Project}}{in{->{var2/Person}{var5/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}{in{->{var3/Person}{var5/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}}}}}}}}}","nextExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","sourceExpr":"not some s: Student | some c: Course| s->c in teaches all s1, s2: Student, p: Project | s1->p in Student <: projects and s2->p in Student <: projects implies (not some p2: Project| s1->p2 in Student <: projects and s2->p2 in Student <: projects and p!=p2)","predicate":"inv14","isNewNode":true,"srcDstTED":47,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Student}}', parent=AND, position=0)\", \"(type='Update', node=var2, value=var1)\", \"(type='Update', node=var3, value=var2)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Update', node=var4, value=var3)\", \"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{AND{!={var4/Project}{var5/Project}}{in{->{var2/Person}{var5/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}{in{->{var3/Person}{var5/Project}}{<:{sig/Student}{field/projects{set of{sig/Project}}}}}}', parent=!, position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var4/Project, value=var2/Project)\", \"(type='Update', node=var3/Person, value=var1/Person)\", \"(type='Update', node=var4/Project, value=var2/Project)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=in, position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var5/Project, value=var3/Project)\", \"(type='Update', node=var3/Person, value=var1/Person)\", \"(type='Update', node=var5/Project, value=var3/Project)\", \"(type='TreeDelete', tree='{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=!)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='TreeDelete', tree='{!={var4/Project}{var5/Project}}')\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=<:)\", \"(type='TreeDelete', tree='{one of{var5}{sig/Project}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","totalTED":47,"challenge":"PSqwzYAfW9dFAa9im","time":64098200,"targetExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all p:Project | some s:Person | s->p in projects all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { } pred inv8 { all p1, p2: Professor, c:Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 } pred inv9 { all p:Person, c:Course| some pf:Professor | pf->c in teaches and p->c in enrolled implies p not in Professor } pred inv10 { all p:Person, c:Course, g:Grade | c->p->g in grades implies p in Student } pred inv11 { all s:Student, c:Course, g:Grade | c->s->g in grades implies s->c in enrolled } pred inv12 { } pred inv13 { } pred inv14 { all s1,s2: Student, p1,p2:Project | s1->p1 in projects and s2->p1 in projects implies not (s1->p2 in projects and s2->p2 in projects) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","nextExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","sourceExpr":"all s1,s2: Student, p1,p2:Project | s1->p1 in projects and s2->p1 in projects implies not (s1->p2 in projects and s2->p2 in projects)","predicate":"inv14","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","operations":"[\"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a not equal operator ('!=') to specify that the left side is not equal to the right side. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","totalTED":6,"challenge":"PSqwzYAfW9dFAa9im","time":48376100,"targetExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { all s1, s2: Student, p: Project | s1->p in projects and s2->p in projects implies (not some p2: Project| s1->p2 in projects and s2->p2 in projects and p!=p2) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{some{one of{var3}{sig/Project}}{AND{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","nextExpr":"all x,y:Student, p:Project | (x->p in projects and y->p in projects and x!=y) implies (all p1:Project-p | x->p1 not in projects or y->p1 not in projects)","sourceExpr":"all s1, s2: Student, p: Project | s1->p in projects and s2->p in projects implies (not some p2: Project| s1->p2 in projects and s2->p2 in projects and p!=p2)","predicate":"inv14","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{-{sig/Project}{var2/Project}}}{OR{!in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var3}{sig/Project}}{AND{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}', parent==>, position=1)\", \"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='Update', node=AND, value=OR)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{sig/Project}', parent=-, position=0)\", \"(type='Insert', node=var2/Project, parent=-, position=1)\", \"(type='TreeDelete', tree='{!={var2/Project}{var3/Project}}')\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{-{sig/Project}{var2/Project}}}{OR{!in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","totalTED":13,"challenge":"PSqwzYAfW9dFAa9im","time":52034500,"targetExpr":"all x,y:Student, p:Project | (x->p in projects and y->p in projects and x!=y) implies (all p1:Project-p | x->p1 not in projects or y->p1 not in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s1, s2: Student | all p1, p2: Project| s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s1,s2:Student, p1,p2:Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","sourceExpr":"not some s1, s2: Student | all p1, p2: Project| s1->p1 in projects and s2->p1 in projects and s1->p2 in projects and s2->p2 in projects","predicate":"inv14","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=2)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=3)\", \"(type='Move', tree='{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=4)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}{!in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":12,"challenge":"PSqwzYAfW9dFAa9im","time":44649200,"targetExpr":"all s1,s2:Student, p1,p2:Project | s1!=s2 and p1!=p2 and s1->p1 in projects and s2->p1 in projects and s1->p2 in projects implies s2->p2 not in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Grade}}{all{one of{var3}{sig/Grade}}{=>{AND{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}{in{->{var1/Course}{->{var0/Person}{var3/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}}{={var2/Grade}{var3/Grade}}}}}}}","nextExpr":"all s1,s2 : Student | lone p : Project | s1!=s2 and s1 -> p in projects and s2 -> p in projects","sourceExpr":"all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2","predicate":"inv14","isNewNode":true,"srcDstTED":27,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{lone{one of{var2}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node=all, value=lone)\", \"(type='Update', node=sig/Course, value=sig/Student)\", \"(type='Update', node=all, value=AND)\", \"(type='Update', node=sig/Grade, value=sig/Project)\", \"(type='Update', node=one of, value=!=)\", \"(type='Move', tree='{in{->{var1/Course}{->{var0/Person}{var2/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=all, position=1)\", \"(type='Move', tree='{in{->{var1/Course}{->{var0/Person}{var3/Grade}}}{field/grades{->{sig/Person}{sig/Grade}}}}', parent=all, position=2)\", \"(type='Update', node=var3, value=var0/Person)\", \"(type='Update', node=sig/Grade, value=var1/Person)\", \"(type='Move', tree='{->{var0/Person}{var2/Grade}}', parent=in, position=0)\", \"(type='Update', node=field/grades, value=field/projects)\", \"(type='Move', tree='{->{var0/Person}{var3/Grade}}', parent=in, position=0)\", \"(type='Update', node=field/grades, value=field/projects)\", \"(type='Update', node=var2/Grade, value=var2/Project)\", \"(type='Update', node=->, value=set of)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var3/Grade, value=var2/Project)\", \"(type='Update', node=->, value=set of)\", \"(type='Update', node=sig/Person, value=sig/Project)\", \"(type='Update', node=sig/Person, value=sig/Project)\", \"(type='Delete', node=var1/Course)\", \"(type='Delete', node=->)\", \"(type='Delete', node=sig/Grade)\", \"(type='Delete', node=var1/Course)\", \"(type='Delete', node=->)\", \"(type='Delete', node=sig/Grade)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{={var2/Grade}{var3/Grade}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{lone{one of{var2}{sig/Project}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}}}}","totalTED":27,"challenge":"PSqwzYAfW9dFAa9im","time":57435300,"targetExpr":"all s1,s2 : Student | lone p : Project | s1!=s2 and s1 -> p in projects and s2 -> p in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { all s: Student, g: Grade, c: Course | c->s->g in grades implies s->c in enrolled } pred inv12 { all s:Student, c: Course, g1,g2: Grade | c->s->g1 in grades and c->s->g2 in grades implies g1=g2 } pred inv13 { } pred inv14 { not some s: Student | some c: Course| s->c in teaches all s1, s2: Student, p: Project | s1->p in Person <: projects and s2->p in Person <: projects implies (not some p2: Project| s1->p2 in Person <: projects and s2->p2 in Person <: projects and p!=p2) } pred inv15 { }","sourceAST":"{AND{!{some{one of{var0}{sig/Student}}{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}}{all{one of{var2}{sig/Student}}{all{one of{var3}{sig/Student}}{all{one of{var4}{sig/Project}}{=>{AND{in{->{var2/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var4/Project}}{field/projects{set of{sig/Project}}}}}{!{some{one of{var5}{sig/Project}}{AND{!={var4/Project}{var5/Project}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}}","nextExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","sourceExpr":"not some s: Student | some c: Course| s->c in teaches all s1, s2: Student, p: Project | s1->p in Person <: projects and s2->p in Person <: projects implies (not some p2: Project| s1->p2 in Person <: projects and s2->p2 in Person <: projects and p!=p2)","predicate":"inv14","isNewNode":true,"srcDstTED":39,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Student}}', parent=AND, position=0)\", \"(type='Update', node=var2, value=var1)\", \"(type='Update', node=var3, value=var2)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Update', node=var4, value=var3)\", \"(type='TreeInsert', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{!={var2/Project}{var3/Project}}', parent=AND, position=1)\", \"(type='Move', tree='{AND{!={var4/Project}{var5/Project}}{in{->{var2/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var5/Project}}{field/projects{set of{sig/Project}}}}}', parent=!, position=0)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var4/Project, value=var2/Project)\", \"(type='Update', node=var3/Person, value=var1/Person)\", \"(type='Update', node=var4/Project, value=var2/Project)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var5/Project, value=var3/Project)\", \"(type='Update', node=var3/Person, value=var1/Person)\", \"(type='Update', node=var5/Project, value=var3/Project)\", \"(type='TreeDelete', tree='{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=!)\", \"(type='TreeDelete', tree='{!={var4/Project}{var5/Project}}')\", \"(type='TreeDelete', tree='{one of{var5}{sig/Project}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{!={var0/Person}{var1/Person}}{!={var2/Project}{var3/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{!{AND{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}}}}}}}}","totalTED":39,"challenge":"PSqwzYAfW9dFAa9im","time":52091000,"targetExpr":"all s1, s2 : Student, p1, p2 : Project | s1 != s2 && p1 != p2 && s1->p1 in projects && s2->p1 in projects => not (s1->p2 in projects && s2->p2 in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all c : Course | c.enrolled in Student } pred inv2 { all c : Course | c.teaches in Professor } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{in{.{var0/Course}{field/teaches{set of{sig/Course}}}}{sig/Professor}}}","nextExpr":"all c:Course | c.(~teaches) in Professor","sourceExpr":"all c : Course | c.teaches in Professor","predicate":"inv2","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Course}}{in{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}{sig/Professor}}}","operations":"[\"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=~, position=0)\"]","hint":"One step away from the solution! Consider adding a transpose operator ('~') to transpose a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Course}}{in{.{var0/Course}{~{field/teaches{set of{sig/Course}}}}}{sig/Professor}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":115393500,"targetExpr":"all c:Course | c.(~teaches) in Professor","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches = Professor -> Course } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{={->{sig/Professor}{sig/Course}}{field/teaches{set of{sig/Course}}}}","nextExpr":"Professor <: teaches = teaches","sourceExpr":"teaches = Professor -> Course","predicate":"inv2","isNewNode":true,"srcDstTED":3,"targetAST":"{={<:{sig/Professor}{field/teaches{set of{sig/Course}}}}{field/teaches{set of{sig/Course}}}}","operations":"[\"(type='Update', node=->, value=<:)\", \"(type='Insert', node=field/teaches, parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Move', tree='{sig/Course}', parent=set of, position=0)\"]","hint":"Near a solution! Instead of using arrow operator ('->') to map a relation, try using restriction operator ('<:') to restrict the domain of a relation.","nextAST":"{={<:{sig/Professor}{field/teaches{set of{sig/Course}}}}{field/teaches{set of{sig/Course}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":39913600,"targetExpr":"Professor <: teaches = teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches = Professor->Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{={->{sig/Professor}{sig/Course}}{field/teaches{set of{sig/Course}}}}","nextExpr":"Professor.teaches = Course","sourceExpr":"teaches = Professor->Course","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{={.{sig/Professor}{field/teaches{set of{sig/Course}}}}{sig/Course}}","operations":"[\"(type='Insert', node=., parent==, position=0)\", \"(type='Insert', node=sig/Course, parent==, position=1)\", \"(type='Move', tree='{sig/Professor}', parent=., position=0)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=sig/Course)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the equal operator ('=') expression.","nextAST":"{={.{sig/Professor}{field/teaches{set of{sig/Course}}}}{sig/Course}}","totalTED":4,"challenge":"PSqwzYAfW9dFAa9im","time":119147500,"targetExpr":"Professor.teaches = Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person | some(p.enrolled) implies p in Student } pred inv2 { all p:Person | some (p.teaches) implies p in Professor } pred inv3 { all p:Professor, c:Course | c in p.teaches } pred inv4 { all c:Course | one (c.projects) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{in{var1/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","nextExpr":"all a : Course | some b : Professor | a in b.teaches","sourceExpr":"all p:Professor,c:Course| c in p.teaches","predicate":"inv3","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Update', node=var1/Course, value=var0/Course)\", \"(type='Update', node=var0/Person, value=var1/Person)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","totalTED":5,"challenge":"PSqwzYAfW9dFAa9im","time":115744400,"targetExpr":"all a : Course | some b : Professor | a in b.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p : Person | (some c: Course | p -> c in teaches) => (p in Professor) } pred inv3 { teaches in Professor one -> set Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{one->{sig/Professor}{sig/Course}}}","nextExpr":"teaches in Professor some -> set Course","sourceExpr":"teaches in Professor one -> set Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","operations":"[\"(type='Update', node=one->, value=some->)\"]","hint":"One step away from the solution! Instead of using one->, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":32847200,"targetExpr":"teaches in Professor some -> set Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor -> Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{->{sig/Professor}{sig/Course}}}","nextExpr":"teaches in Professor some -> set Course","sourceExpr":"teaches in Professor -> Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","operations":"[\"(type='Update', node=->, value=some->)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":35839300,"targetExpr":"teaches in Professor some -> set Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Person set -> some Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{->some{sig/Person}{sig/Course}}}","nextExpr":"teaches in Person some -> Course","sourceExpr":"teaches in Person set -> some Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}","operations":"[\"(type='Update', node=->some, value=some->)\"]","hint":"One step away from the solution! Instead of using ->some, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":63969600,"targetExpr":"teaches in Person some -> Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Person->Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{->{sig/Person}{sig/Course}}}","nextExpr":"teaches in Person some -> Course","sourceExpr":"teaches in Person->Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}","operations":"[\"(type='Update', node=->, value=some->)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":32600800,"targetExpr":"teaches in Person some -> Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor set -> some Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{->some{sig/Professor}{sig/Course}}}","nextExpr":"teaches in Professor some -> set Course","sourceExpr":"teaches in Professor set -> some Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","operations":"[\"(type='Update', node=->some, value=some->)\"]","hint":"One step away from the solution! Instead of using ->some, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":56301100,"targetExpr":"teaches in Professor some -> set Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> some Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{some->some{sig/Professor}{sig/Course}}}","nextExpr":"teaches in Professor some -> set Course","sourceExpr":"teaches in Professor some -> some Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","operations":"[\"(type='Update', node=some->some, value=some->)\"]","hint":"One step away from the solution! Instead of using some->some, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":34232600,"targetExpr":"teaches in Professor some -> set Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p : Person | (some c: Course | p -> c in teaches) => (p in Professor) } pred inv3 { teaches in Person one -> set Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{one->{sig/Person}{sig/Course}}}","nextExpr":"teaches in Person some -> Course","sourceExpr":"teaches in Person one -> set Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}","operations":"[\"(type='Update', node=one->, value=some->)\"]","hint":"One step away from the solution! Instead of using one->, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":72699700,"targetExpr":"teaches in Person some -> Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person | some(p.enrolled) implies p in Student } pred inv2 { all p:Person | some (p.teaches) implies p in Professor } pred inv3 { all p:Professor, c:Course | lone p.teaches } pred inv4 { all c:Course | one (c.projects) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{lone{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}","nextExpr":"all a : Course | some b : Professor | a in b.teaches","sourceExpr":"all p:Professor, c:Course | lone p.teaches","predicate":"inv3","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Update', node=lone, value=in)\", \"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Insert', node=var0/Course, parent=lone, position=0)\", \"(type='Update', node=var0/Person, value=var1/Person)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{var0/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}","totalTED":6,"challenge":"PSqwzYAfW9dFAa9im","time":39467000,"targetExpr":"all a : Course | some b : Professor | a in b.teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p:Professor | c -> p in teaches } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var0/Course}{var1/Person}}{field/teaches{set of{sig/Course}}}}}}","nextExpr":"all c: Course | some p: Professor | p->c in teaches","sourceExpr":"all c: Course | some p: Professor | c->p in teaches","predicate":"inv3","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","operations":"[\"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Delete', node=var1/Person)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Person to correctly capture the property you want to specify. Think about how you can incorporate this within the arrow operator ('->') expression.","nextAST":"{all{one of{var0}{sig/Course}}{some{one of{var1}{sig/Professor}}{in{->{var1/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":55863300,"targetExpr":"all c: Course | some p: Professor | p->c in teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p : Person | (some c: Course | p -> c in enrolled) => (p in Student) } pred inv2 { all p : Person | (some c: Course | p -> c in teaches) => (p in Professor) } pred inv3 { teaches in Professor one -> lone Course } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/teaches{set of{sig/Course}}}{one->lone{sig/Professor}{sig/Course}}}","nextExpr":"teaches in Professor some -> set Course","sourceExpr":"teaches in Professor one -> lone Course","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","operations":"[\"(type='Update', node=one->lone, value=some->)\"]","hint":"One step away from the solution! Instead of using one->lone, try using some-> to help satisfy the required property.","nextAST":"{in{field/teaches{set of{sig/Course}}}{some->{sig/Professor}{sig/Course}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":29643600,"targetExpr":"teaches in Professor some -> set Course","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person, c:Course | p->c in enrolled implies p in Student } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { all c:Course | some p:Person | p->c in teaches } pred inv4 { all p:Project | some c:Course | c->p in projects } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Course}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all p: Project | one c: Course | c->p in projects","sourceExpr":"all p : Project | some c : Course | c->p in projects","predicate":"inv4","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","operations":"[\"(type='Update', node=some, value=one)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":103961400,"targetExpr":"all p: Project | one c: Course | c->p in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person | some(p.enrolled) implies p in Student } pred inv2 { all p:Person | some (p.teaches) implies p in Professor } pred inv3 { all c:Course | c in Professor.teaches } pred inv4 { all c:Course | one (c.projects) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{one{.{var0/Course}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all p:Project|one (Course<:projects).p","sourceExpr":"all c : Course | one c.projects","predicate":"inv4","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Project}}{one{.{field/projects{set of{sig/Project}}}{var0/Project}}}}","operations":"[\"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Insert', node=var0/Project, parent=., position=2)\", \"(type='Delete', node=var0/Course)\"]","hint":"Near a solution! Instead of using signature of type Course, try using signature of type Project to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Project}}{one{.{field/projects{set of{sig/Project}}}{var0/Project}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":58570500,"targetExpr":"all p:Project|one (Course<:projects).p","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { all p:Person | some(p.enrolled) implies p in Student } pred inv2 { all p:Person | some (p.teaches) implies p in Professor } pred inv3 { } pred inv4 { all c:Course | lone (c.projects) } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{lone{.{var0/Course}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all c : Course | one c.projects","sourceExpr":"all c : Course | lone c.projects","predicate":"inv4","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Project}}{one{.{field/projects{set of{sig/Project}}}{var0/Project}}}}","operations":"[\"(type='Update', node=lone, value=one)\"]","hint":"Keep going! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Course}}{one{.{var0/Course}{field/projects{set of{sig/Project}}}}}}","totalTED":4,"challenge":"PSqwzYAfW9dFAa9im","time":55550000,"targetExpr":"all p:Project|one (Course<:projects).p","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { all p:Project | one c1,c2:Course | no p1:Person | c1->p in projects and c2->p in projects implies c1=c2 and p1->p in projects } pred inv5 { all p:Project | some pe:Person | pe->p in projects and pe in Student } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{one{one of{var2}{sig/Course}}{no{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}{AND{={var1/Course}{var2/Course}}{in{->{var3/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all p : Project | some c : Course | c->p in projects and all c1,c2 : Course | c1->p in projects and c2->p in projects implies c1=c2","sourceExpr":"all p:Project | one c1,c2:Course | no p1:Person | c1->p in projects and c2->p in projects implies c1=c2 and p1->p in projects","predicate":"inv4","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Course}}{AND{all{one of{var2}{sig/Course}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Course}{var3/Course}}}}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Update', node=one, value=some)\", \"(type='Update', node=one, value=AND)\", \"(type='Insert', node=all, parent=one, position=0)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}', parent=one, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node=all, parent=all, position=1)\", \"(type='Move', tree='{one of{var3}{sig/Person}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=var3/Person, value=var1/Course)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Move', tree='{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{={var2/Course}{var1/Course}}', parent==>, position=1)\", \"(type='Update', node=var1/Course, value=var2/Course)\", \"(type='Insert', node=var3/Course, parent==, position=2)\", \"(type='Update', node=var1/Course, value=var3/Course)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=AND)\", \"(type='Delete', node==>)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Course}}{AND{all{one of{var2}{sig/Course}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Course}{var3/Course}}}}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","totalTED":14,"challenge":"PSqwzYAfW9dFAa9im","time":109486300,"targetExpr":"all p : Project | some c : Course | c->p in projects and all c1,c2 : Course | c1->p in projects and c2->p in projects implies c1=c2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { all c1, c2 : Course, p:Project | c1->p in projects and c2->p in projects implies c1=c2 } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{={var0/Course}{var1/Course}}}}}}","nextExpr":"all c1,c2: Course, p: Project | p in c1.projects and p in c2.projects implies c1=c2 Project in Course.projects","sourceExpr":"all c1, c2 : Course, p:Project | c1->p in projects and c2->p in projects implies c1=c2","predicate":"inv4","isNewNode":true,"srcDstTED":16,"targetAST":"{AND{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Course}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{={var0/Course}{var1/Course}}}}}}{in{sig/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{={var0/Course}{var1/Course}}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{sig/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}', parent=AND, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=var2/Project, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var0/Course}', parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Course}', parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Delete', node=var2/Project)\", \"(type='Delete', node=->)\", \"(type='Delete', node=var2/Project)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{var2/Project}{.{var0/Course}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{={var0/Course}{var1/Course}}}}}}{in{sig/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}}","totalTED":16,"challenge":"PSqwzYAfW9dFAa9im","time":44333800,"targetExpr":"all c1,c2: Course, p: Project | p in c1.projects and p in c2.projects implies c1=c2 Project in Course.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Project in Course.projects } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{sig/Project}{.{sig/Course}{field/projects{set of{sig/Project}}}}}","nextExpr":"all p : Project | one Course<:projects.p","sourceExpr":"Project in Course.projects","predicate":"inv4","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Project}}{one{<:{sig/Course}{.{field/projects{set of{sig/Project}}}{var0/Project}}}}}","operations":"[\"(type='Update', node=in, value=all)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Insert', node=one, parent=in, position=1)\", \"(type='Insert', node=var0, parent=one of, position=0)\", \"(type='Move', tree='{sig/Project}', parent=one of, position=1)\", \"(type='Update', node=., value=<:)\", \"(type='Move', tree='{.{sig/Course}{field/projects{set of{sig/Project}}}}', parent=one, position=0)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=0)\", \"(type='Insert', node=var0/Project, parent=., position=1)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Project}}{one{<:{sig/Course}{.{field/projects{set of{sig/Project}}}{var0/Project}}}}}","totalTED":7,"challenge":"PSqwzYAfW9dFAa9im","time":57651200,"targetExpr":"all p : Project | one Course<:projects.p","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { all p:Project | one c1,c2:Course | c1->p in projects and c2->p in projects implies c1=c2 } pred inv5 { all p:Project | some pe:Person | pe->p in projects and pe in Student } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{one{one of{var1}{sig/Course}}{one{one of{var2}{sig/Course}}{=>{AND{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}{={var1/Course}{var2/Course}}}}}}","nextExpr":"all p : Project | some c1 : Course | c1->p in Course<:projects and all c2 : Course | c2->p in Course<:projects implies c1 = c2","sourceExpr":"all p:Project | one c1,c2:Course | c1->p in projects and c2->p in projects implies c1=c2","predicate":"inv4","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Course}}{AND{all{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{={var1/Course}{var2/Course}}}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Update', node=one, value=some)\", \"(type='Update', node=one, value=AND)\", \"(type='Insert', node=all, parent=one, position=0)\", \"(type='Move', tree='{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}', parent=one, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{={var1/Course}{var2/Course}}', parent==>, position=1)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{={var1/Course}{var2/Course}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Course}}{AND{all{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{={var1/Course}{var2/Course}}}}{in{->{var1/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","totalTED":14,"challenge":"PSqwzYAfW9dFAa9im","time":92088400,"targetExpr":"all p : Project | some c1 : Course | c1->p in Course<:projects and all c2 : Course | c2->p in Course<:projects implies c1 = c2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Project = Course.projects } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{={.{sig/Course}{field/projects{set of{sig/Project}}}}{sig/Project}}","nextExpr":"Course <: projects in Course one -> Project","sourceExpr":"Course.projects = Project","predicate":"inv4","isNewNode":false,"srcDstTED":5,"targetAST":"{in{field/projects{set of{sig/Project}}}{one->{sig/Course}{sig/Project}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent==, position=0)\", \"(type='Insert', node=one->, parent==, position=1)\", \"(type='Insert', node=sig/Course, parent=one->, position=0)\", \"(type='Move', tree='{sig/Project}', parent=one->, position=1)\", \"(type='Delete', node=sig/Course)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{one->{sig/Course}{sig/Project}}}","totalTED":5,"challenge":"PSqwzYAfW9dFAa9im","time":89091800,"targetExpr":"Course <: projects in Course one -> Project","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { all p:Project | one c1,c2:Course | c1->p in projects and c2->p in projects implies c1=c2 } pred inv5 { all p:Project | some pe:Person | pe->p in projects and pe in Student } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{AND{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{var1/Person}{sig/Student}}}}}","nextExpr":"(Person<:projects).Project in Student all pr:Project | some p:Person | p->pr in Person<:projects","sourceExpr":"all p1 : Project | some pr1 : Person | pr1->p1 in projects and pr1 in Student","predicate":"inv5","isNewNode":false,"srcDstTED":10,"targetAST":"{AND{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}{in{.{field/projects{set of{sig/Project}}}{sig/Project}}{sig/Student}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{in{var1/Person}{sig/Student}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Project}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{one of{var1}{sig/Person}}', parent=some, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}', parent=some, position=1)\", \"(type='Insert', node=field/projects, parent=., position=0)\", \"(type='Insert', node=sig/Project, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/projects, position=0)\", \"(type='Update', node=var1/Person, value=sig/Project)\", \"(type='Move', tree='{var1/Person}', parent=set of, position=0)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}{in{.{field/projects{set of{sig/Project}}}{sig/Project}}{sig/Student}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":260870200,"targetExpr":"(Person<:projects).Project in Student all pr:Project | some p:Person | p->pr in Person<:projects","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Person one -> Project } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/projects{set of{sig/Project}}}{one->{sig/Person}{sig/Project}}}","nextExpr":"Person <: projects in Student some -> Project","sourceExpr":"Person <: projects in Person one -> Project","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}","operations":"[\"(type='Update', node=one->, value=some->)\", \"(type='Update', node=sig/Person, value=sig/Student)\"]","hint":"Near a solution! Instead of using one->, try using some-> to help satisfy the required property.","nextAST":"{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":114563600,"targetExpr":"Person <: projects in Student some -> Project","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{var0/Person}{sig/Student}}}}}","nextExpr":"Person <: projects in Student some -> Project","sourceExpr":"all p:Person | all pro:Project | p->pro in projects implies p in Student","predicate":"inv5","isNewNode":false,"srcDstTED":16,"targetAST":"{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}","operations":"[\"(type='Update', node==>, value=in)\", \"(type='Move', tree='{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{var0/Person}{sig/Student}}}', parent=root, position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent==>, position=0)\", \"(type='Update', node=in, value=some->)\", \"(type='Insert', node=sig/Project, parent=in, position=2)\", \"(type='TreeDelete', tree='{->{var0/Person}{var1/Project}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=var0/Person)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Person}}')\", \"(type='TreeDelete', tree='{one of{var1}{sig/Project}}')\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}","totalTED":16,"challenge":"PSqwzYAfW9dFAa9im","time":149819400,"targetExpr":"Person <: projects in Student some -> Project","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { all p:Project | some s:Student | s->p in projects } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Student}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}","nextExpr":"all p:Project | ((Person<:projects.p) in Student) and (some pe:Person | pe->p in projects)","sourceExpr":"(all p:Project | some s:Student | s->p in projects)","predicate":"inv5","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Project}}{AND{in{<:{sig/Person}{.{field/projects{set of{sig/Project}}}{var0/Project}}}{sig/Student}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{<:{sig/Person}{.{field/projects{set of{sig/Project}}}{var0/Project}}}{sig/Student}}', parent=AND, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Student}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}', parent=AND, position=1)\", \"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Project}}{AND{in{<:{sig/Person}{.{field/projects{set of{sig/Project}}}{var0/Project}}}{sig/Student}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":148690100,"targetExpr":"all p:Project | ((Person<:projects.p) in Student) and (some pe:Person | pe->p in projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { all p:Project, x:Person | x->p in projects implies x in Student } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{var1/Person}{sig/Student}}}}}","nextExpr":"all p : Project | all p2 : Person | p2->p in projects implies p2 in Student all p : Project | some p2 : Person | p2->p in projects","sourceExpr":"all p : Project | all p2 : Person | p2->p in projects implies p2 in Student","predicate":"inv5","isNewNode":false,"srcDstTED":16,"targetAST":"{AND{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{var1/Person}{sig/Student}}}}}{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{var1/Person}{sig/Student}}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}', parent=AND, position=1)\"]","hint":"Keep going! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{var1/Person}{sig/Student}}}}}{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}}","totalTED":16,"challenge":"PSqwzYAfW9dFAa9im","time":162235000,"targetExpr":"all p : Project | all p2 : Person | p2->p in projects implies p2 in Student all p : Project | some p2 : Person | p2->p in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { all p:Project | some x:Person | x->p in projects implies x in Student } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{var1/Person}{sig/Student}}}}}","nextExpr":"(Person<:projects).Project in Student all pr:Project | some p:Person | p->pr in Person<:projects","sourceExpr":"all p: Project | some s: Person | s->p in projects implies s in Student","predicate":"inv5","isNewNode":false,"srcDstTED":10,"targetAST":"{AND{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}{in{.{field/projects{set of{sig/Project}}}{sig/Project}}{sig/Student}}}","operations":"[\"(type='Update', node=all, value=AND)\", \"(type='Insert', node=all, parent=all, position=0)\", \"(type='Move', tree='{in{var1/Person}{sig/Student}}', parent=all, position=1)\", \"(type='Move', tree='{one of{var0}{sig/Project}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{one of{var1}{sig/Person}}', parent=some, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}', parent=some, position=1)\", \"(type='Insert', node=field/projects, parent=., position=0)\", \"(type='Insert', node=sig/Project, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/projects, position=0)\", \"(type='Update', node=var1/Person, value=sig/Project)\", \"(type='Move', tree='{var1/Person}', parent=set of, position=0)\", \"(type='Delete', node==>)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{AND{all{one of{var0}{sig/Project}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}}}{in{.{field/projects{set of{sig/Project}}}{sig/Project}}{sig/Student}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":176078000,"targetExpr":"(Person<:projects).Project in Student all pr:Project | some p:Person | p->pr in Person<:projects","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> some Project } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/projects{set of{sig/Project}}}{some->some{sig/Student}{sig/Project}}}","nextExpr":"Person <: projects in Student some -> Project","sourceExpr":"Person <: projects in Student some -> some Project","predicate":"inv5","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}","operations":"[\"(type='Update', node=some->some, value=some->)\"]","hint":"One step away from the solution! Instead of using some->some, try using some-> to help satisfy the required property.","nextAST":"{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":43253600,"targetExpr":"Person <: projects in Student some -> Project","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { some s:Student | enrolled in s -> Course Person <: projects in Student some -> Project } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}{some{one of{var0}{sig/Student}}{in{field/enrolled{set of{sig/Course}}}{->{var0/Person}{sig/Course}}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"some s:Student | enrolled in s -> Course Person <: projects in Student some -> Project","predicate":"inv6","isNewNode":true,"srcDstTED":14,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=AND, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{field/enrolled{set of{sig/Course}}}{->{var0/Person}{sig/Course}}}', parent=AND, position=1)\", \"(type='Insert', node=field/projects, parent=in, position=1)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{var0/Person}{sig/Course}}', parent=field/projects, position=0)\", \"(type='Update', node=var0/Person, value=sig/Project)\", \"(type='Delete', node=sig/Course)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Student}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":14,"challenge":"PSqwzYAfW9dFAa9im","time":128340900,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { Person <: projects in Student some -> Project implies enrolled in Student some -> Course } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{=>{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}{in{field/enrolled{set of{sig/Course}}}{some->{sig/Student}{sig/Course}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"Person <: projects in Student some -> Project implies enrolled in Student some -> Course","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node==>, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent==>, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/projects, parent=in, position=1)\", \"(type='Update', node=some->, value=set of)\", \"(type='Move', tree='{some->{sig/Student}{sig/Course}}', parent=field/projects, position=0)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=sig/Course)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":69270400,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Person | some p:Project | s -> p in projects implies some c:Course | s -> c in enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s1: Person | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","sourceExpr":"all s:Person | some p:Project | s -> p in projects implies some c:Course | s -> c in enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='TreeInsert', tree='{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":45644600,"targetExpr":"all s1: Person | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { Person <: projects in Student some -> Project implies enrolled in Student some -> Course and Course <: projects in Course -> Project } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{=>{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}{AND{in{field/enrolled{set of{sig/Course}}}{some->{sig/Student}{sig/Course}}}{in{field/projects{set of{sig/Project}}}{->{sig/Course}{sig/Project}}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"Person <: projects in Student some -> Project implies enrolled in Student some -> Course and Course <: projects in Course -> Project","predicate":"inv6","isNewNode":true,"srcDstTED":14,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node==>, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent==>, position=0)\", \"(type='Update', node=AND, value=.)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=AND, position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=AND, position=1)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Course}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{->{sig/Course}{sig/Project}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":14,"challenge":"PSqwzYAfW9dFAa9im","time":48725300,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student | some p:Project | s -> p in projects implies some c:Course | s -> c in enrolled and c -> p in projects } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{some{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","nextExpr":"all s : Student, p : Project | s->p in projects => some c : Course | s->c in enrolled && c->p in projects","sourceExpr":"all s:Student | some p:Project | s->p in projects implies some c:Course | s->c in enrolled and c->p in projects","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":115689600,"targetExpr":"all s : Student, p : Project | s->p in projects => some c : Course | s->c in enrolled && c->p in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects implies s -> c in enrolled) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all s1: Student | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","sourceExpr":"all s:Student,p:Project | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects implies s -> c in enrolled)","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":43515700,"targetExpr":"all s1: Student | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Person | (all c : Course | some p : Project | ((s -> p in projects or s -> p in teaches) and c -> p in projects) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Project}}{<=>{AND{OR{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Project}}{field/teaches{set of{sig/Course}}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Person | (all c : Course | some p : Project | ((s -> p in projects or s -> p in teaches) and c -> p in projects) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=0)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var2/Project}}{field/teaches{set of{sig/Course}}}}')\", \"(type='Delete', node=OR)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Student to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":48278500,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student | some p:Project | s -> p in projects implies some c:Course | s -> c in enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{some{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s : Student, p : Project | s->p in projects => some c : Course | s->c in enrolled && c->p in projects","sourceExpr":"all s:Student | some p:Project | s->p in projects implies some c:Course | s->c in enrolled","predicate":"inv6","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":98147500,"targetExpr":"all s : Student, p : Project | s->p in projects => some c : Course | s->c in enrolled && c->p in projects","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, c:Course | c in s.enrolled implies (some p:Project | p in s.projects and p in c.projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{some{one of{var2}{sig/Project}}{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s: Student, p: Project | p in s.projects implies some c: Course | c in s.enrolled and p in c.projects","sourceExpr":"all s:Student, c:Course | c in s.enrolled implies (some p:Project | p in s.projects and p in c.projects)","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{some{one of{var2}{sig/Course}}{AND{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=var1/Course, value=var1/Project)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=var2/Project, value=var2/Course)\", \"(type='Update', node=var2/Project, value=var1/Project)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=field/projects, value=field/enrolled)\", \"(type='Update', node=var1/Course, value=var2/Course)\", \"(type='Update', node=sig/Project, value=sig/Course)\"]","hint":"Keep going! Instead of using signature of type Course, try using signature of type Project to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{some{one of{var2}{sig/Course}}{AND{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":46495100,"targetExpr":"all s: Student, p: Project | p in s.projects implies some c: Course | c in s.enrolled and p in c.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p : Person | (some c: Course | p -> c in teaches) => (p in Professor) } pred inv3 { teaches in Person some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s: Student | all c : Course | ((all p: Project| s -> p in projects and c -> p in projects) => (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{all{one of{var2}{sig/Project}}{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s: Student | all c : Course | ((all p: Project| s -> p in projects and c -> p in projects) => (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Move', tree='{one of{var2}{sig/Project}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}', parent==>, position=1)\", \"(type='Delete', node=all)\"]","hint":"Near a solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":47836500,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { enrolled in Student some -> Course } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/enrolled{set of{sig/Course}}}{some->{sig/Student}{sig/Course}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"enrolled in Student some -> Course","predicate":"inv6","isNewNode":true,"srcDstTED":8,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='TreeInsert', tree='{field/projects{set of{sig/Project}}}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Insert', node=field/projects, parent=., position=1)\", \"(type='Update', node=some->, value=set of)\", \"(type='Move', tree='{some->{sig/Student}{sig/Course}}', parent=field/projects, position=0)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='Delete', node=sig/Course)\"]","hint":"Keep going! Consider adding a field \"projects\" to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":8,"challenge":"PSqwzYAfW9dFAa9im","time":40688000,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { some s:Person, c:Course | s.projects = c.projects } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Course}}{={.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all p:Person | p.projects in p.enrolled.projects","sourceExpr":"some s:Person, c:Course | s.projects = c.projects","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Person}}{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node==, value=in)\", \"(type='Move', tree='{={.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}', parent=some, position=1)\", \"(type='Insert', node=., parent=., position=0)\", \"(type='Update', node=var1/Course, value=var0/Person)\", \"(type='Move', tree='{var1/Course}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Course}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{in{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{.{var0/Person}{field/enrolled{set of{sig/Course}}}}{field/projects{set of{sig/Project}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":41907000,"targetExpr":"all p:Person | p.projects in p.enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { Person <: projects in Person some -> Project implies enrolled in Person some -> Course } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{=>{in{field/projects{set of{sig/Project}}}{some->{sig/Person}{sig/Project}}}{in{field/enrolled{set of{sig/Course}}}{some->{sig/Person}{sig/Course}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"Person <: projects in Person some -> Project implies enrolled in Person some -> Course","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node==>, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent==>, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/projects, parent=in, position=1)\", \"(type='Update', node=some->, value=set of)\", \"(type='Move', tree='{some->{sig/Person}{sig/Course}}', parent=field/projects, position=0)\", \"(type='Update', node=sig/Person, value=sig/Project)\", \"(type='TreeDelete', tree='{some->{sig/Person}{sig/Project}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=sig/Course)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":36917500,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student | enrolled in s -> Course Person <: projects in Student some -> Project } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Student}}{in{field/enrolled{set of{sig/Course}}}{->{var0/Person}{sig/Course}}}}{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"all s:Student | enrolled in s -> Course Person <: projects in Student some -> Project","predicate":"inv6","isNewNode":true,"srcDstTED":15,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Insert', node=field/projects, parent=AND, position=0)\", \"(type='Insert', node=., parent=AND, position=1)\", \"(type='Update', node=one of, value=set of)\", \"(type='Move', tree='{one of{var0}{sig/Student}}', parent=field/projects, position=0)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=var0, value=sig/Project)\", \"(type='Delete', node=sig/Student)\", \"(type='TreeDelete', tree='{->{var0/Person}{sig/Course}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":15,"challenge":"PSqwzYAfW9dFAa9im","time":42224000,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project | s -> p in Person <: projects iff (some c:Course | c -> p in Course <: projects implies s -> c in enrolled) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{<=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all s1: Student | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","sourceExpr":"all s:Student,p:Project | s -> p in Person <: projects iff (some c:Course | c -> p in Course <: projects implies s -> c in enrolled)","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Update', node==>, value=AND)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":45795200,"targetExpr":"all s1: Student | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and p -> c in enrolled) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Student}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Project}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p : Project | all s : Person | s->p in projects implies (some c : Course | c->p in projects and s->c in enrolled)","sourceExpr":"all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and p -> c in enrolled)","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=var0/Project, value=var1/Person)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Person}}{=>{in{->{var1/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":38166500,"targetExpr":"all p : Project | all s : Person | s->p in projects implies (some c : Course | c->p in projects and s->c in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, c:Course | s.projects & c.projects != none } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{!={&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{none}}}}","nextExpr":"all s : Student, c : Course | some s.projects & c.projects implies c in s.enrolled","sourceExpr":"all s:Student, c:Course | s.projects & c.projects != none","predicate":"inv6","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{some{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=!=, value==>)\", \"(type='Insert', node=some, parent=!=, position=0)\", \"(type='Insert', node=in, parent=!=, position=1)\", \"(type='Move', tree='{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}', parent=some, position=0)\", \"(type='Update', node=none, value=var1/Course)\", \"(type='Move', tree='{none}', parent=in, position=0)\", \"(type='TreeInsert', tree='{.{var0/Person}{field/enrolled{set of{sig/Course}}}}', parent=in, position=1)\"]","hint":"Keep going! Instead of using not equal operator ('!=') to specify that the left side is not equal to the right side, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{some{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":38964600,"targetExpr":"all s : Student, c : Course | some s.projects & c.projects implies c in s.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Person | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects and not s -> c in teaches) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Project}}{<=>{AND{!{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Person | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects and not s -> c in teaches) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='TreeDelete', tree='{!{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}')\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Student to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":47594300,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Person,p:Project | s in Student and s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects implies s -> c in enrolled) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{AND{in{var0/Person}{sig/Student}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}{some{one of{var2}{sig/Course}}{=>{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all s1: Person | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","sourceExpr":"all s:Person,p:Project | s in Student and s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects implies s -> c in enrolled)","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Move', tree='{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}', parent==>, position=0)\", \"(type='Update', node==>, value=AND)\", \"(type='TreeDelete', tree='{in{var0/Person}{sig/Student}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the implication operator ('=>') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":5,"challenge":"PSqwzYAfW9dFAa9im","time":52301100,"targetExpr":"all s1: Person | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student | some p:Project, c:Course | s.projects = c.projects } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{some{one of{var1}{sig/Project}}{some{one of{var2}{sig/Course}}{={.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var2/Course}{field/projects{set of{sig/Project}}}}}}}}","nextExpr":"all s : Student, c : Course | c not in s.enrolled implies no (s.projects & c.projects)","sourceExpr":"all s:Student | some p:Project, c:Course | s.projects = c.projects","predicate":"inv6","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{no{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value==>)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Insert', node=!in, parent=some, position=0)\", \"(type='Insert', node=no, parent=some, position=1)\", \"(type='Insert', node=var1/Course, parent=!in, position=0)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var2}{sig/Course}}', parent=!in, position=1)\", \"(type='Update', node==, value=&)\", \"(type='Move', tree='{={.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var2/Course}{field/projects{set of{sig/Project}}}}}', parent=no, position=0)\", \"(type='Update', node=var2, value=var0/Person)\", \"(type='Insert', node=field/enrolled, parent=one of, position=1)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Update', node=var2/Course, value=var1/Course)\", \"(type='Move', tree='{sig/Course}', parent=set of, position=0)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{no{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":12,"challenge":"PSqwzYAfW9dFAa9im","time":47826800,"targetExpr":"all s : Student, c : Course | c not in s.enrolled implies no (s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { Person <: projects in Student some -> Project and enrolled in Student -> Course } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}{in{field/enrolled{set of{sig/Course}}}{->{sig/Student}{sig/Course}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"Person <: projects in Student some -> Project and enrolled in Student -> Course","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=AND, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/projects, parent=in, position=1)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{sig/Student}{sig/Course}}', parent=field/projects, position=0)\", \"(type='Update', node=sig/Student, value=sig/Project)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=sig/Course)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":36676500,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Person, c:Course | c in s.enrolled implies (some p:Project | p in s.projects and p in c.projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{=>{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{some{one of{var2}{sig/Project}}{AND{in{var2/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var2/Project}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s: Student, p: Project | p in s.projects implies some c: Course | c in s.enrolled and p in c.projects","sourceExpr":"all s:Person, c:Course | c in s.enrolled implies (some p:Project | p in s.projects and p in c.projects)","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{some{one of{var2}{sig/Course}}{AND{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=var1/Course, value=var1/Project)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=var2/Project, value=var2/Course)\", \"(type='Update', node=var2/Project, value=var1/Project)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=field/projects, value=field/enrolled)\", \"(type='Update', node=var1/Course, value=var2/Course)\", \"(type='Update', node=sig/Project, value=sig/Course)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Student to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{some{one of{var2}{sig/Course}}{AND{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":39507100,"targetExpr":"all s: Student, p: Project | p in s.projects implies some c: Course | c in s.enrolled and p in c.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { enrolled in Student -> Course Person <: projects in Student some -> Project } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{in{field/enrolled{set of{sig/Course}}}{->{sig/Student}{sig/Course}}}{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"enrolled in Student -> Course Person <: projects in Student some -> Project","predicate":"inv6","isNewNode":true,"srcDstTED":12,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node=AND, value=in)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=AND, position=0)\", \"(type='Insert', node=., parent=AND, position=1)\", \"(type='Insert', node=field/enrolled, parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{sig/Student}{sig/Course}}', parent=field/enrolled, position=0)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":12,"challenge":"PSqwzYAfW9dFAa9im","time":40050800,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | some c:Course | c in s.enrolled implies (p in s.projects and p in c.projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{some{one of{var2}{sig/Course}}{=>{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{AND{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}}}}}}","nextExpr":"all s:Person, p:Project | some c:Course | p in s.projects implies p in c.projects and c in s.enrolled","sourceExpr":"all s:Student, p:Project | some c:Course | c in s.enrolled implies (p in s.projects and p in c.projects)","predicate":"inv6","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{some{one of{var2}{sig/Course}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=var2/Course, value=var1/Project)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=var1/Project, value=var2/Course)\", \"(type='Update', node=field/projects, value=field/enrolled)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=sig/Project, value=sig/Course)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{some{one of{var2}{sig/Course}}{=>{in{var1/Project}{.{var0/Person}{field/projects{set of{sig/Project}}}}}{AND{in{var1/Project}{.{var2/Course}{field/projects{set of{sig/Project}}}}}{in{var2/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":40338700,"targetExpr":"all s:Person, p:Project | some c:Course | p in s.projects implies p in c.projects and c in s.enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { some s:Person | some p:Project | s -> p in projects implies some c:Course | s -> c in enrolled } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s1: Person | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","sourceExpr":"some s:Person | some p:Project | s -> p in projects implies some c:Course | s -> c in enrolled","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='TreeInsert', tree='{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":40527600,"targetExpr":"all s1: Person | all p1: Project | s1->p1 in projects implies (some c1: Course | c1->p1 in projects and s1->c1 in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { some s:Person, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","nextExpr":"all s:Student, p:Project | s->p in projects implies some c:Course | s->c in enrolled and c->p in projects","sourceExpr":"some s:Person, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects)","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Person, value=sig/Student)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":42906700,"targetExpr":"all s:Student, p:Project | s->p in projects implies some c:Course | s->c in enrolled and c->p in projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, c:Course | c in s.enrolled implies (s.projects & c.projects != none) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{!={&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}{none}}}}}","nextExpr":"all s : Student, c : Course | c not in s.enrolled implies no (s.projects & c.projects)","sourceExpr":"all s:Student, c:Course | c in s.enrolled implies (s.projects & c.projects != none)","predicate":"inv6","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{no{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=!=, value=no)\", \"(type='Delete', node=none)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{=>{!in{var1/Course}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{no{&{.{var0/Person}{field/projects{set of{sig/Project}}}}{.{var1/Course}{field/projects{set of{sig/Project}}}}}}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":45360500,"targetExpr":"all s : Student, c : Course | c not in s.enrolled implies no (s.projects & c.projects)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Person | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects and not s -> p in teaches) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Project}}{<=>{AND{!{in{->{var0/Person}{var2/Project}}{field/teaches{set of{sig/Course}}}}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Person | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects and not s -> p in teaches) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='TreeDelete', tree='{!{in{->{var0/Person}{var2/Project}}{field/teaches{set of{sig/Course}}}}}')\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Student to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":54081600,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Student | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Project}}{<=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Student | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":2,"challenge":"PSqwzYAfW9dFAa9im","time":38663900,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all p : Person | (some c: Course | p -> c in enrolled) => (some pr: Project | p -> pr in projects) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{some{one of{var1}{sig/Course}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}{some{one of{var2}{sig/Project}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}}}","nextExpr":"all s:Person,p:Project | s->p in projects implies s->p in enrolled.projects","sourceExpr":"all p : Person | (some c: Course | p -> c in enrolled) => (some pr: Project | p -> pr in projects)","predicate":"inv6","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var1/Project}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Move', tree='{one of{var1}{sig/Course}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent==>, position=1)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Update', node=var1/Course, value=var1/Project)\", \"(type='Update', node=var2/Project, value=var1/Project)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=., position=1)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Delete', node=some)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Project}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Project}}{=>{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var1/Project}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}}}}","totalTED":16,"challenge":"PSqwzYAfW9dFAa9im","time":40520900,"targetExpr":"all s:Person,p:Project | s->p in projects implies s->p in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Student | (all p : Project, c : Course | (s -> p in projects and c -> p in projects) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Course}}{<=>{AND{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Student | (all p : Project, c : Course | (s -> p in projects and c -> p in projects) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\"]","hint":"One step away from the solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":1,"challenge":"PSqwzYAfW9dFAa9im","time":33223700,"targetExpr":"all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { Course <: projects in Student some -> Project implies enrolled in Student some -> Project } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{=>{in{field/projects{set of{sig/Project}}}{some->{sig/Student}{sig/Project}}}{in{field/enrolled{set of{sig/Course}}}{some->{sig/Student}{sig/Project}}}}","nextExpr":"Person<:projects in enrolled.projects","sourceExpr":"Course <: projects in Student some -> Project implies enrolled in Student some -> Project","predicate":"inv6","isNewNode":true,"srcDstTED":9,"targetAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","operations":"[\"(type='Update', node==>, value=in)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent==>, position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/projects, parent=in, position=1)\", \"(type='Update', node=some->, value=set of)\", \"(type='Move', tree='{some->{sig/Student}{sig/Project}}', parent=field/projects, position=0)\", \"(type='TreeDelete', tree='{some->{sig/Student}{sig/Project}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=sig/Student)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/projects{set of{sig/Project}}}{.{field/enrolled{set of{sig/Course}}}{field/projects{set of{sig/Project}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":45793300,"targetExpr":"Person<:projects in enrolled.projects","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Student | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects and not s -> p in teaches) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Project}}{<=>{AND{!{in{->{var0/Person}{var2/Project}}{field/teaches{set of{sig/Course}}}}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Student | (all c : Course | some p : Project | (s -> p in projects and c -> p in projects and not s -> p in teaches) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='TreeDelete', tree='{!{in{->{var0/Person}{var2/Project}}{field/teaches{set of{sig/Course}}}}}')\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":50951100,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all s : Person | (all c : Course | some p : Project | ((s -> p in projects or s -> c in teaches) and c -> p in projects) iff (s -> c in enrolled)) } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Project}}{<=>{AND{OR{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","sourceExpr":"all s : Person | (all c : Course | some p : Project | ((s -> p in projects or s -> c in teaches) and c -> p in projects) iff (s -> c in enrolled))","predicate":"inv6","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=0)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}')\", \"(type='Delete', node=OR)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Student to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":55748400,"targetExpr":"all s:Student, c:Course, p:Project | s->p in projects and c->p in projects implies s->c in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all p:Project | some s:Person | s->p in projects all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { this/Course <:projects in Course -> one Project } pred inv8 { all p1, p2: Professor, c:Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 } pred inv9 { all p:Person, c:Course| some pf:Professor | pf->c in teaches and p->c in enrolled implies p not in Professor } pred inv10 { all p:Person, c:Course, g:Grade | c->p->g in grades implies p in Student } pred inv11 { all s:Student, c:Course, g:Grade | c->s->g in grades implies s->c in enrolled } pred inv12 { } pred inv13 { } pred inv14 { all s1,s2: Student, p1,p2:Project | s1->p1 in projects and s2->p1 in projects implies not (s1->p2 in projects and s2->p2 in projects) } pred inv15 { }","sourceAST":"{in{field/projects{set of{sig/Project}}}{->one{sig/Course}{sig/Project}}}","nextExpr":"all c:Course | Person <: projects :> c.projects in Person -> lone Project","sourceExpr":"this/Course <:projects in Course -> one Project","predicate":"inv7","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Course}}{in{<:{sig/Person}{:>{field/projects{set of{sig/Project}}}{.{var0/Course}{field/projects{set of{sig/Project}}}}}}{->lone{sig/Person}{sig/Project}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Course}}', parent=all, position=0)\", \"(type='Move', tree='{in{field/projects{set of{sig/Project}}}{->one{sig/Course}{sig/Project}}}', parent=all, position=1)\", \"(type='Insert', node=<:, parent=in, position=0)\", \"(type='TreeInsert', tree='{->lone{sig/Person}{sig/Project}}', parent=in, position=1)\", \"(type='Insert', node=sig/Person, parent=<:, position=0)\", \"(type='Insert', node=:>, parent=<:, position=1)\", \"(type='Move', tree='{field/projects{set of{sig/Project}}}', parent=:>, position=0)\", \"(type='Update', node=->one, value=.)\", \"(type='Move', tree='{->one{sig/Course}{sig/Project}}', parent=:>, position=1)\", \"(type='Update', node=sig/Course, value=var0/Course)\", \"(type='Insert', node=field/projects, parent=->one, position=1)\", \"(type='Insert', node=set of, parent=field/projects, position=0)\", \"(type='Move', tree='{sig/Project}', parent=set of, position=0)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Course}}{in{<:{sig/Person}{:>{field/projects{set of{sig/Project}}}{.{var0/Course}{field/projects{set of{sig/Project}}}}}}{->lone{sig/Person}{sig/Project}}}}","totalTED":14,"challenge":"PSqwzYAfW9dFAa9im","time":117296900,"targetExpr":"all c:Course | Person <: projects :> c.projects in Person -> lone Project","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all p:Project | some s:Person | s->p in projects all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student, p1,p2:Project, c:Course | s->c in enrolled and c->p1 in projects and c->p2 in projects implies p1=p2 } pred inv8 { all p1, p2: Professor, c:Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 } pred inv9 { all p:Person, c:Course| some pf:Professor | pf->c in teaches and p->c in enrolled implies p not in Professor } pred inv10 { all p:Person, c:Course, g:Grade | c->p->g in grades implies p in Student } pred inv11 { all s:Student, c:Course, g:Grade | c->s->g in grades implies s->c in enrolled } pred inv12 { } pred inv13 { } pred inv14 { all s1,s2: Student, p1,p2:Project | s1->p1 in projects and s2->p1 in projects implies not (s1->p2 in projects and s2->p2 in projects) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var0/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var3/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{={var1/Project}{var2/Project}}}}}}}","nextExpr":"all s1 : Student | all p1,p2 : Project | all c1 : Course | ((s1->p1 in projects) and (s1->p2 in projects) and (c1->p1 in projects) and (c1->p2 in projects)) implies p1=p2","sourceExpr":"all s:Student, p1,p2:Project, c:Course | s->c in enrolled and c->p1 in projects and c->p2 in projects implies p1=p2","predicate":"inv7","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{={var1/Project}{var2/Project}}}}}}}","operations":"[\"(type='TreeInsert', tree='{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}', parent=AND, position=1)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=var3/Course, value=var1/Project)\", \"(type='Update', node=sig/Course, value=sig/Project)\"]","hint":"Keep going! Consider adding a inclusion operator ('in') to specify that some element(s) belong to a set. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}}{={var1/Project}{var2/Project}}}}}}}","totalTED":10,"challenge":"PSqwzYAfW9dFAa9im","time":79079100,"targetExpr":"all s1 : Student | all p1,p2 : Project | all c1 : Course | ((s1->p1 in projects) and (s1->p2 in projects) and (c1->p1 in projects) and (c1->p2 in projects)) implies p1=p2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects implies s -> c in enrolled) } pred inv7 { all p1,p2:Project | all s:Student | s->p1 in Person <: projects and s->p2 in Person <: projects implies (all c1,c2:Course | c1 -> p1 in Course <: projects and c2 -> p2 in Course <: projects implies c1 != c2) } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Student}}{=>{AND{in{->{var2/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{sig/Course}}{all{one of{var4}{sig/Course}}{=>{AND{in{->{var3/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var4/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{!={var3/Course}{var4/Course}}}}}}}}}","nextExpr":"all p1,p2 : Project | all c : Course | c->p1 in projects and c->p2 in projects implies (all s1 : Student | s1->p1 in projects and s1->p2 in projects implies p1=p2)","sourceExpr":"all p1,p2:Project | all s:Student | s->p1 in Person <: projects and s->p2 in Person <: projects implies (all c1,c2:Course | c1 -> p1 in Course <: projects and c2 -> p2 in Course <: projects implies c1 != c2)","predicate":"inv7","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{sig/Student}}{=>{AND{in{->{var3/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}{={var0/Project}{var1/Project}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Move', tree='{=>{AND{in{->{var3/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var4/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{!={var3/Course}{var4/Course}}}', parent=all, position=1)\", \"(type='Update', node=sig/Course, value=sig/Student)\", \"(type='Update', node=!=, value==)\", \"(type='Update', node=var2/Person, value=var2/Course)\", \"(type='Update', node=var2/Person, value=var2/Course)\", \"(type='Update', node=var3/Course, value=var0/Project)\", \"(type='Update', node=var4/Course, value=var1/Project)\", \"(type='Update', node=var3/Course, value=var3/Person)\", \"(type='Update', node=var4/Course, value=var3/Person)\", \"(type='TreeDelete', tree='{one of{var4}{sig/Course}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Project}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var2/Course}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}}{all{one of{var3}{sig/Student}}{=>{AND{in{->{var3/Person}{var0/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}{={var0/Project}{var1/Project}}}}}}}}","totalTED":13,"challenge":"PSqwzYAfW9dFAa9im","time":60214500,"targetExpr":"all p1,p2 : Project | all c : Course | c->p1 in projects and c->p2 in projects implies (all s1 : Student | s1->p1 in projects and s1->p2 in projects implies p1=p2)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all p:Project | some s:Person | s->p in projects all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s: Student, p:Project, c1,c2:Course | c1->p in projects and c2->p in projects and s->c1 in enrolled and s->c2 in enrolled and s->p in projects implies c1=c2 } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Project}}{all{one of{var2}{sig/Course}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var2/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var3/Course}{var1/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var0/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var0/Person}{var1/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Course}{var3/Course}}}}}}}","nextExpr":"all s: Student | all c: Course | all p1 : Project | all p2 : Project | s->p1 in Person<:projects and s->p2 in Person<:projects and s->c in enrolled and c->p1 in Course<:projects and c->p2 in Course<:projects implies p1=p2","sourceExpr":"all s: Student, p:Project, c1,c2:Course | c1->p in projects and c2->p in projects and s->c1 in enrolled and s->c2 in enrolled and s->p in projects implies c1=c2","predicate":"inv7","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var3/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Project}{var3/Project}}}}}}}","operations":"[\"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=sig/Course, value=sig/Project)\", \"(type='Update', node=var2/Course, value=var2/Project)\", \"(type='Update', node=var3/Course, value=var3/Project)\", \"(type='Update', node=field/enrolled, value=field/projects)\", \"(type='Update', node=var2/Course, value=var0/Person)\", \"(type='Update', node=var1/Project, value=var2/Project)\", \"(type='Update', node=var3/Course, value=var0/Person)\", \"(type='Update', node=var1/Project, value=var3/Project)\", \"(type='Update', node=var2/Course, value=var1/Course)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=var3/Course, value=var2/Project)\", \"(type='Update', node=var0/Person, value=var1/Course)\", \"(type='Update', node=var1/Project, value=var3/Project)\", \"(type='Update', node=sig/Course, value=sig/Project)\"]","hint":"Keep going! Instead of using signature of type Project, try using signature of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Project}}{all{one of{var3}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var3/Project}}{field/projects{set of{sig/Project}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Course}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Course}{var3/Project}}{field/projects{set of{sig/Project}}}}}{={var2/Project}{var3/Project}}}}}}}","totalTED":16,"challenge":"PSqwzYAfW9dFAa9im","time":62014000,"targetExpr":"all s: Student | all c: Course | all p1 : Project | all p2 : Project | s->p1 in Person<:projects and s->p2 in Person<:projects and s->c in enrolled and c->p1 in Course<:projects and c->p2 in Course<:projects implies p1=p2","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { Person.teaches & Person.enrolled = none } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{={&{.{sig/Person}{field/teaches{set of{sig/Course}}}}{.{sig/Person}{field/enrolled{set of{sig/Course}}}}}{none}}","nextExpr":"all p : Professor | p.teaches & p.enrolled = none","sourceExpr":"Person.teaches & Person.enrolled = none","predicate":"inv8","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Professor}}{={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{none}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Professor}}', parent=all, position=0)\", \"(type='Move', tree='{={&{.{sig/Person}{field/teaches{set of{sig/Course}}}}{.{sig/Person}{field/enrolled{set of{sig/Course}}}}}{none}}', parent=all, position=1)\", \"(type='Update', node=sig/Person, value=var0/Person)\", \"(type='Update', node=sig/Person, value=var0/Person)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Professor\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Professor}}{={&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}{none}}}","totalTED":6,"challenge":"PSqwzYAfW9dFAa9im","time":114067900,"targetExpr":"all p : Professor | p.teaches & p.enrolled = none","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { no p:Professor| all c:Course | p->c in teaches and p->c in enrolled } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{AND{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}","nextExpr":"all p1 : Professor | all c1:Course | p1->c1 in teaches implies p1->c1 not in enrolled","sourceExpr":"no p:Professor| all c:Course | p->c in teaches and p->c in enrolled","predicate":"inv8","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=in, value=!in)\"]","hint":"Near a solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{=>{in{->{var0/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}}}","totalTED":3,"challenge":"PSqwzYAfW9dFAa9im","time":35051200,"targetExpr":"all p1 : Professor | all c1:Course | p1->c1 in teaches implies p1->c1 not in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { no p:Professor | p->p in teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Professor}}{in{->{var0/Person}{var0/Person}}{field/teaches{set of{sig/Course}}}}}","nextExpr":"all p : Professor | p in Professor","sourceExpr":"no p:Professor | p->p in teaches","predicate":"inv8","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Professor}}{in{var0/Person}{sig/Professor}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Update', node=var0/Person, value=sig/Professor)\", \"(type='Move', tree='{var0/Person}', parent=in, position=1)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/teaches{set of{sig/Course}}}')\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{in{var0/Person}{sig/Professor}}}","totalTED":6,"challenge":"PSqwzYAfW9dFAa9im","time":35475200,"targetExpr":"all p : Professor | p in Professor","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Professor | p->p not in teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{!in{->{var0/Person}{var0/Person}}{field/teaches{set of{sig/Course}}}}}","nextExpr":"all p : Professor | p.teaches not in p.enrolled","sourceExpr":"all a : Professor | a->a not in teaches","predicate":"inv8","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Professor}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}}","operations":"[\"(type='Insert', node=., parent=!in, position=0)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the exclusion operator ('!in') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{!in{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var0/Person}{field/enrolled{set of{sig/Course}}}}}}","totalTED":9,"challenge":"PSqwzYAfW9dFAa9im","time":229501200,"targetExpr":"all p : Professor | no (p.teaches & p.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all x,x1: Professor | some c: Course | x->c in teaches and x1->c in enrolled and x!=x1 implies x1 not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}}}}","nextExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all x,x1: Professor | some c: Course | x->c in teaches and x1->c in enrolled and x!=x1 implies x1 not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=all, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='TreeInsert', tree='{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Move', tree='{!in{var1/Person}{sig/Professor}}', parent==>, position=1)\", \"(type='Insert', node=->, parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Move', tree='{var1/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Professor, value=var3/Course)\", \"(type='Move', tree='{sig/Professor}', parent=->, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":19,"challenge":"PSqwzYAfW9dFAa9im","time":132495600,"targetExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1:Person,p2:Professor,c:Course | p1->c in enrolled and p2->c in teaches implies p1 not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{!in{var0/Person}{sig/Professor}}}}}}","nextExpr":"all p1, p2 : Professor | all c:Course | (c in p1.teaches) and (c in p2.teaches) implies p1 not in enrolled.(p2.teaches)","sourceExpr":"all p1:Person,p2:Professor,c:Course | p1->c in enrolled and p2->c in teaches implies p1 not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Insert', node=var2/Course, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=var2/Course, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=field/enrolled, parent=., position=0)\", \"(type='TreeInsert', tree='{.{var1/Person}{field/teaches{set of{sig/Course}}}}', parent=., position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=->)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","totalTED":19,"challenge":"PSqwzYAfW9dFAa9im","time":50607700,"targetExpr":"all p1, p2 : Professor | all c:Course | (c in p1.teaches) and (c in p2.teaches) implies p1 not in enrolled.(p2.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { not some p1,p2: Professor, c: Course | p1->c in teaches and p2->c in enrolled and p1!=p2 } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Professor}}{some{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p1,p2 : Professor | all c : Course | p1->c + p2->c in teaches implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"not some p1,p2: Professor, c: Course | p1->c in teaches and p2->c in enrolled and p1!=p2","predicate":"inv9","isNewNode":true,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{in{+{->{var0/Person}{var2/Course}}{->{var1/Person}{var2/Course}}}{field/teaches{set of{sig/Course}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Professor}}{some{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=in, parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Update', node=!=, value=+)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=in, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Insert', node=->, parent=!=, position=0)\", \"(type='Insert', node=->, parent=!=, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}', parent==>, position=1)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Insert', node=var2/Course, parent=->, position=1)\", \"(type='Move', tree='{var1/Person}', parent=->, position=0)\", \"(type='Insert', node=var2/Course, parent=->, position=1)\", \"(type='Update', node=var2/Course, value=var3/Course)\", \"(type='Update', node=var2/Course, value=var3/Course)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{in{+{->{var0/Person}{var2/Course}}{->{var1/Person}{var2/Course}}}{field/teaches{set of{sig/Course}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":22,"challenge":"PSqwzYAfW9dFAa9im","time":53230600,"targetExpr":"all p1,p2 : Professor | all c : Course | p1->c + p2->c in teaches implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) <=> (p1 in Student and p1 not in Professor) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Course}}{<=>{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{AND{!in{var0/Person}{sig/Professor}}{in{var0/Person}{sig/Student}}}}}}}","nextExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) <=> (p1 in Student and p1 not in Professor)","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=<=>, value==>)\", \"(type='Update', node=AND, value=all)\", \"(type='Update', node=!in, value=one of)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=var0/Person, value=var3)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}', parent==>, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=in, position=1)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Student, value=var3/Course)\", \"(type='Move', tree='{sig/Student}', parent=->, position=1)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":48548200,"targetExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor, c: Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{!={var0/Person}{var1/Person}}}}}}","nextExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1,p2:Professor, c:Course| p1->c in teaches and p2->c in enrolled implies p1 != p2","predicate":"inv9","isNewNode":false,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Insert', node=all, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Update', node=!=, value==>)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=all, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Insert', node=in, parent=!=, position=0)\", \"(type='Insert', node=!in, parent=!=, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=in, position=1)\", \"(type='Insert', node=->, parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Insert', node=var3/Course, parent=->, position=1)\", \"(type='Move', tree='{var1/Person}', parent=->, position=0)\", \"(type='Insert', node=var3/Course, parent=->, position=1)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Course\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":18,"challenge":"PSqwzYAfW9dFAa9im","time":161993100,"targetExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Person,c:Course | p1->c in enrolled and p2->c in teaches implies (p1 + p2) not in Professor } pred inv10 { all p:Person,c:Course,g:Grade | p->c->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{!in{+{var0/Person}{var1/Person}}{sig/Professor}}}}}}","nextExpr":"all p1, p2 : Professor | all c:Course | (c in p1.teaches) and (c in p2.teaches) implies p1 not in enrolled.(p2.teaches)","sourceExpr":"all p1,p2:Person,c:Course | p1->c in enrolled and p2->c in teaches implies (p1 + p2) not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Move', tree='{var0/Person}', parent=!in, position=0)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Insert', node=var2/Course, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=var2/Course, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Insert', node=., parent=., position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='Insert', node=field/teaches, parent=., position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=->)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=->)\", \"(type='Delete', node=+)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","totalTED":20,"challenge":"PSqwzYAfW9dFAa9im","time":51093500,"targetExpr":"all p1, p2 : Professor | all c:Course | (c in p1.teaches) and (c in p2.teaches) implies p1 not in enrolled.(p2.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all p:Project | some s:Person | s->p in projects all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { } pred inv8 { all p1, p2: Professor, c:Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 } pred inv9 { all pf:Professor, p:Person, c:Course | pf->c in teaches and p->c in enrolled implies p not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}}}}","nextExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p2:Professor |all p:Person | all c1:Course | p2->c1 in teaches and p->c1 in enrolled implies p not in Professor","predicate":"inv9","isNewNode":false,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=all, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='TreeInsert', tree='{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Move', tree='{!in{var1/Person}{sig/Professor}}', parent==>, position=1)\", \"(type='Insert', node=->, parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Move', tree='{var1/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Professor, value=var3/Course)\", \"(type='Move', tree='{sig/Professor}', parent=->, position=1)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":19,"challenge":"PSqwzYAfW9dFAa9im","time":65508400,"targetExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Professor,c:Course | p1->c in enrolled implies p2->c not in teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}}}}","nextExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | p->c in teaches implies p2->c not in enrolled","sourceExpr":"all p1 , p2 : Professor, c : Course | p1->c in enrolled implies p2->c not in teaches","predicate":"inv9","isNewNode":false,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='TreeInsert', tree='{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{sig/Professor}', parent=-, position=0)\", \"(type='Insert', node=var0/Person, parent=-, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/teaches, value=field/enrolled)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":17,"challenge":"PSqwzYAfW9dFAa9im","time":82446900,"targetExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | p->c in teaches implies p2->c not in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor, c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (not (p1->c in teaches or p2->c in teaches) ) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{!{OR{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}}}}}}","nextExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1,p2: Professor, c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (not (p1->c in teaches or p2->c in teaches) )","predicate":"inv9","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=!, value=all)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=!, position=0)\", \"(type='Update', node=OR, value==>)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Update', node=var2/Course, value=var3/Course)\", \"(type='Update', node=var2/Course, value=var3/Course)\"]","hint":"Keep going! Instead of using negation operator ('!') to specify that the expression is false, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":11,"challenge":"PSqwzYAfW9dFAa9im","time":55995400,"targetExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and s -> c in enrolled) } pred inv7 { all p1:Project,p2:Project,s:Student,c:Course | s -> p1 in Person <: projects and c -> p1 in Course <: projects and s -> p2 in Person <: projects and c -> p2 in Course <: projects implies p1 = p2 } pred inv8 { no p:Professor,c:Course | p -> c in teaches and p -> c in enrolled } pred inv9 { all p1,p2:Professor,p:Project | p1 -> p in Person <: projects and p2 -> p in Person <: projects implies (no c:Course | (p1 -> c in teaches and p2 -> c in enrolled) or (p2 -> c in teaches and p1 -> c in enrolled)) } pred inv10 { grades in Course -> Student -> Grade } pred inv11 { all c:Course,s:Student | (some g:Grade | c -> s -> g in grades) implies s -> c in enrolled } pred inv12 { grades in Course -> Person -> lone Grade } pred inv13 { } pred inv14 { all s1,s2:Student,p1,p2:Project | s1 != s2 and s1 -> p1 in Person <: projects and s2 -> p1 in Person <: projects and s1 -> p2 in Person <: projects and s2 -> p2 in Person <: projects implies p1=p2 } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Project}}{=>{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}{no{one of{var3}{sig/Course}}{OR{AND{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}{AND{in{->{var1/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var0/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}}","nextExpr":"all p1,p2: Professor, c,c2:Course | p1->c in teaches and p2->c in teaches implies (p2->c2 in teaches implies p1->c2 not in enrolled)","sourceExpr":"all p1,p2:Professor,p:Project | p1 -> p in Person <: projects and p2 -> p in Person <: projects implies (no c:Course | (p1 -> c in teaches and p2 -> c in enrolled) or (p2 -> c in teaches and p1 -> c in enrolled))","predicate":"inv9","isNewNode":true,"srcDstTED":24,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{=>{in{->{var1/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var0/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Move', tree='{no{one of{var3}{sig/Course}}{OR{AND{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}{AND{in{->{var1/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var0/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Project, value=sig/Course)\", \"(type='Update', node=OR, value==>)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=var3/Course, value=var2/Course)\", \"(type='Update', node=var3/Course, value=var2/Course)\", \"(type='TreeDelete', tree='{AND{in{->{var0/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}{in{->{var1/Person}{var2/Project}}{field/projects{set of{sig/Project}}}}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{all{one of{var3}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{=>{in{->{var1/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var0/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":24,"challenge":"PSqwzYAfW9dFAa9im","time":55451000,"targetExpr":"all p1,p2: Professor, c,c2:Course | p1->c in teaches and p2->c in teaches implies (p2->c2 in teaches implies p1->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{AND{!in{var0/Person}{sig/Professor}}{in{var0/Person}{sig/Student}}}}}}}","nextExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 in Student and p1 not in Professor)","predicate":"inv9","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=AND, value=all)\", \"(type='Update', node=!in, value=one of)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=var0/Person, value=var3)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}', parent==>, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=in, position=1)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Student, value=var3/Course)\", \"(type='Move', tree='{sig/Student}', parent=->, position=1)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":20,"challenge":"PSqwzYAfW9dFAa9im","time":45326600,"targetExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and s -> c in enrolled) } pred inv7 { all p1:Project,p2:Project,s:Student,c:Course | s -> p1 in Person <: projects and c -> p1 in Course <: projects and s -> p2 in Person <: projects and c -> p2 in Course <: projects implies p1 = p2 } pred inv8 { no p:Professor,c:Course | p -> c in teaches and p -> c in enrolled } pred inv9 { all p:Person | (p in Student implies p not in Professor) or (p in Professor implies p not in Student) } pred inv10 { grades in Course -> Student -> Grade } pred inv11 { all c:Course,s:Student | (some g:Grade | c -> s -> g in grades) implies s -> c in enrolled } pred inv12 { grades in Course -> Person -> lone Grade } pred inv13 { } pred inv14 { all s1,s2:Student,p1,p2:Project | s1 != s2 and s1 -> p1 in Person <: projects and s2 -> p1 in Person <: projects and s1 -> p2 in Person <: projects and s2 -> p2 in Person <: projects implies p1=p2 } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{OR{=>{in{var0/Person}{sig/Student}}{!in{var0/Person}{sig/Professor}}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{sig/Student}}}}}","nextExpr":"all p : Professor | no (teaches.(p.teaches) & enrolled.(p.teaches))","sourceExpr":"all p:Person | (p in Student implies p not in Professor) or (p in Professor implies p not in Student)","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Professor}}{no{&{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=OR, value=&)\", \"(type='Move', tree='{OR{=>{in{var0/Person}{sig/Student}}{!in{var0/Person}{sig/Professor}}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{sig/Student}}}}', parent=no, position=0)\", \"(type='Update', node==>, value=.)\", \"(type='Update', node==>, value=.)\", \"(type='Insert', node=field/teaches, parent==>, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Insert', node=field/enrolled, parent==>, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Update', node=in, value=set of)\", \"(type='Move', tree='{in{var0/Person}{sig/Student}}', parent=field/teaches, position=0)\", \"(type='Insert', node=field/teaches, parent=!in, position=1)\", \"(type='Update', node=in, value=set of)\", \"(type='Move', tree='{in{var0/Person}{sig/Professor}}', parent=field/enrolled, position=0)\", \"(type='Insert', node=field/teaches, parent=!in, position=1)\", \"(type='Update', node=var0/Person, value=sig/Course)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=var0/Person, value=sig/Course)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Move', tree='{sig/Student}', parent=set of, position=0)\", \"(type='Delete', node=sig/Student)\", \"(type='Delete', node=sig/Professor)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{no{&{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":51818800,"targetExpr":"all p : Professor | no (teaches.(p.teaches) & enrolled.(p.teaches))","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all x,x1: Person | some c: Course | x->c in teaches and x1->c in enrolled and x!=x1 implies x1 not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{some{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{var1/Person}{sig/Professor}}}}}}","nextExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all x,x1: Person | some c: Course | x->c in teaches and x1->c in enrolled and x!=x1 implies x1 not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=all, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='TreeInsert', tree='{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}', parent==>, position=0)\", \"(type='Move', tree='{!in{var1/Person}{sig/Professor}}', parent==>, position=1)\", \"(type='Insert', node=->, parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Move', tree='{var1/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Professor, value=var3/Course)\", \"(type='Move', tree='{sig/Professor}', parent=->, position=1)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":45601500,"targetExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { not some x,x1: Professor | some c: Course | x->c in teaches and x1->c in enrolled and x!=x1 and x in Professor and x1 in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Professor}}{some{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{var0/Person}{sig/Professor}}{in{var1/Person}{sig/Professor}}}}}}}","nextExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"not some x,x1: Professor | some c: Course | x->c in teaches and x1->c in enrolled and x!=x1 and x in Professor and x1 in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":23,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Professor}}{some{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{var0/Person}{sig/Professor}}{in{var1/Person}{sig/Professor}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Insert', node=AND, parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Move', tree='{!={var0/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}', parent=AND, position=1)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}', parent=AND, position=2)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Move', tree='{in{var0/Person}{sig/Professor}}', parent==>, position=0)\", \"(type='Insert', node=!in, parent==>, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=in, position=1)\", \"(type='Update', node=in, value=->)\", \"(type='Move', tree='{in{var1/Person}{sig/Professor}}', parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Professor, value=var3/Course)\", \"(type='Move', tree='{sig/Professor}', parent=->, position=1)\", \"(type='Update', node=sig/Professor, value=var3/Course)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":23,"challenge":"PSqwzYAfW9dFAa9im","time":52319400,"targetExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { all p:Person, c:Course | p->c in teaches implies p in Professor } pred inv3 { teaches in Professor some -> Course } pred inv4 { this/Course <:projects in Course one -> Project } pred inv5 { all p:Project | some s:Person | s->p in projects all s:Person, p:Project | s->p in projects implies s in Student } pred inv6 { all s:Student, p:Project, c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { } pred inv8 { all p1, p2: Professor, c:Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 } pred inv9 { all p:Person, c:Course| some pf:Professor | pf->c in teaches and p->c in enrolled implies p not in Professor } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Course}}{some{one of{var2}{sig/Professor}}{=>{AND{in{->{var2/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{var0/Person}{sig/Professor}}}}}}","nextExpr":"all c1, c2 : Course, p1, p2 : Professor | p1 -> c1 in teaches and p2 -> c1 in teaches and p2 -> c2 in enrolled implies p1 -> c2 not in teaches","sourceExpr":"all p:Person, c:Course| some pf:Professor | pf->c in teaches and p->c in enrolled implies p not in Professor","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Professor}}{all{one of{var3}{sig/Professor}}{=>{AND{in{->{var2/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var3/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var3/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{->{var2/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Update', node=some, value=all)\", \"(type='Insert', node=all, parent=some, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Professor}}', parent=all, position=0)\", \"(type='Move', tree='{=>{AND{in{->{var2/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var0/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{var0/Person}{sig/Professor}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{in{->{var3/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}', parent=AND, position=1)\", \"(type='Insert', node=->, parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Update', node=var0/Person, value=var2/Person)\", \"(type='Move', tree='{var0/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Professor, value=var1/Course)\", \"(type='Move', tree='{sig/Professor}', parent=->, position=1)\", \"(type='Update', node=var1/Course, value=var0/Course)\", \"(type='Update', node=var0/Person, value=var3/Person)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Course to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Course}}{all{one of{var1}{sig/Course}}{all{one of{var2}{sig/Professor}}{all{one of{var3}{sig/Professor}}{=>{AND{in{->{var2/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var3/Person}{var0/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var3/Person}{var1/Course}}{field/enrolled{set of{sig/Course}}}}}{!in{->{var2/Person}{var1/Course}}{field/teaches{set of{sig/Course}}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":46619300,"targetExpr":"all c1, c2 : Course, p1, p2 : Professor | p1 -> c1 in teaches and p2 -> c1 in teaches and p2 -> c2 in enrolled implies p1 -> c2 not in teaches","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { not some x,x1: Professor | some c: Course | x->c in teaches and x1->c in enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{!{some{one of{var0}{sig/Professor}}{some{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","nextExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | p->c in teaches implies p2->c not in enrolled","sourceExpr":"not some x,x1: Professor | some c: Course | x->c in teaches and x1->c in enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var0}{sig/Professor}}{some{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Insert', node==>, parent=some, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='TreeInsert', tree='{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}', parent==>, position=0)\", \"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var2}{sig/Course}}{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{sig/Professor}', parent=-, position=0)\", \"(type='Insert', node=var0/Person, parent=-, position=1)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=in, value=!in)\", \"(type='Delete', node=!)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":44363900,"targetExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | p->c in teaches implies p2->c not in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{AND{!in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}}}}}","nextExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (p1->c not in teaches and p2->c not in teaches)","predicate":"inv9","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=all, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=all, position=0)\", \"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}', parent=all, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Update', node=var2/Course, value=var3/Course)\", \"(type='Update', node=var2/Course, value=var3/Course)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":12,"challenge":"PSqwzYAfW9dFAa9im","time":56741800,"targetExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { all c:Course | some p: Professor | p -> c in teaches teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all p:Project,s:Student | s -> p in Person <: projects implies (some c:Course | c -> p in Course <: projects and s -> c in enrolled) } pred inv7 { all p1:Project,p2:Project,s:Student,c:Course | s -> p1 in Person <: projects and c -> p1 in Course <: projects and s -> p2 in Person <: projects and c -> p2 in Course <: projects implies p1 = p2 } pred inv8 { no p:Professor,c:Course | p -> c in teaches and p -> c in enrolled } pred inv9 { all p:Person | p in Professor implies p not in Student } pred inv10 { grades in Course -> Student -> Grade } pred inv11 { all c:Course,s:Student | (some g:Grade | c -> s -> g in grades) implies s -> c in enrolled } pred inv12 { grades in Course -> Person -> lone Grade } pred inv13 { } pred inv14 { all s1,s2:Student,p1,p2:Project | s1 != s2 and s1 -> p1 in Person <: projects and s2 -> p1 in Person <: projects and s1 -> p2 in Person <: projects and s2 -> p2 in Person <: projects implies p1=p2 } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{sig/Student}}}}","nextExpr":"all p : Professor | no (teaches.(p.teaches) & enrolled.(p.teaches))","sourceExpr":"all p:Person | p in Professor implies p not in Student","predicate":"inv9","isNewNode":true,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{no{&{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node==>, value=&)\", \"(type='Move', tree='{=>{in{var0/Person}{sig/Professor}}{!in{var0/Person}{sig/Student}}}', parent=no, position=0)\", \"(type='Insert', node=., parent==>, position=0)\", \"(type='Insert', node=., parent==>, position=1)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=., position=0)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{var0/Person}{sig/Professor}}', parent=., position=1)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{var0/Person}{sig/Student}}', parent=., position=1)\", \"(type='Insert', node=field/teaches, parent=in, position=1)\", \"(type='Insert', node=field/teaches, parent=!in, position=1)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Update', node=sig/Student, value=sig/Course)\", \"(type='Move', tree='{sig/Student}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{no{&{.{field/teaches{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{.{field/enrolled{set of{sig/Course}}}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}}}}","totalTED":19,"challenge":"PSqwzYAfW9dFAa9im","time":43998200,"targetExpr":"all p : Professor | no (teaches.(p.teaches) & enrolled.(p.teaches))","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { all t:Professor, c:Course | c in t.teaches implies (all p:Person | c in p.enrolled implies p not in Professor) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{=>{in{var1/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{all{one of{var2}{sig/Person}}{=>{in{var1/Course}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}{!in{var2/Person}{sig/Professor}}}}}}}","nextExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | c in p.teaches implies c not in p2.enrolled","sourceExpr":"all p : Professor | all c : Course | c in p.teaches implies (all s : Person | c in s.enrolled implies s not in Professor)","predicate":"inv9","isNewNode":false,"srcDstTED":19,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Move', tree='{sig/Course}', parent=-, position=0)\", \"(type='Insert', node=var0/Person, parent=-, position=1)\", \"(type='Update', node=var1/Course, value=var1/Person)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{.{var0/Person}{field/teaches{set of{sig/Course}}}}', parent=., position=0)\", \"(type='TreeInsert', tree='{~{field/teaches{set of{sig/Course}}}}', parent=., position=1)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Update', node=var1/Course, value=var2/Course)\", \"(type='Update', node=var2/Person, value=var2/Course)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=sig/Professor, value=var1/Person)\", \"(type='Move', tree='{sig/Professor}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\"]","hint":"Keep going! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{!in{var2/Course}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":19,"challenge":"PSqwzYAfW9dFAa9im","time":111182700,"targetExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | c in p.teaches implies c not in p2.enrolled","createdShorterPath":true}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor, c: Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 and p1 not in Student and p2 in Student } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{AND{!={var0/Person}{var1/Person}}{!in{var0/Person}{sig/Student}}{in{var1/Person}{sig/Student}}}}}}}","nextExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1,p2: Professor, c: Course | p1->c in teaches and p2->c in enrolled implies p1!=p2 and p1 not in Student and p2 in Student","predicate":"inv9","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Update', node=!=, value=one of)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=var0/Person, value=var3)\", \"(type='Update', node=var1/Person, value=sig/Course)\", \"(type='Insert', node=in, parent==>, position=0)\", \"(type='Insert', node=!in, parent==>, position=1)\", \"(type='Update', node=!in, value=->)\", \"(type='Move', tree='{!in{var0/Person}{sig/Student}}', parent=in, position=0)\", \"(type='TreeInsert', tree='{field/teaches{set of{sig/Course}}}', parent=in, position=1)\", \"(type='Update', node=in, value=->)\", \"(type='Move', tree='{in{var1/Person}{sig/Student}}', parent=!in, position=0)\", \"(type='TreeInsert', tree='{field/enrolled{set of{sig/Course}}}', parent=!in, position=1)\", \"(type='Update', node=sig/Student, value=var3/Course)\", \"(type='Update', node=sig/Student, value=var3/Course)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":18,"challenge":"PSqwzYAfW9dFAa9im","time":55591000,"targetExpr":"all p1,p2:Professor,c1:Course | (p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { all p1, p2: Professor, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 != p2) } pred inv9 { all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 not in Professor) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Course}}{=>{AND{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{!in{var0/Person}{sig/Professor}}}}}}","nextExpr":"all p1, p2 : Professor | all c:Course | (c in p1.teaches) and (c in p2.teaches) implies p1 not in enrolled.(p2.teaches)","sourceExpr":"all p1, p2: Person, c : Course | (p1 -> c in enrolled and p2 -> c in teaches) => (p1 not in Professor)","predicate":"inv9","isNewNode":true,"srcDstTED":20,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Update', node=sig/Person, value=sig/Professor)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Insert', node=var2/Course, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=var2/Course, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Insert', node=field/enrolled, parent=., position=0)\", \"(type='TreeInsert', tree='{.{var1/Person}{field/teaches{set of{sig/Course}}}}', parent=., position=1)\", \"(type='Move', tree='{var0/Person}', parent=., position=0)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Move', tree='{field/enrolled{set of{sig/Course}}}', parent=., position=1)\", \"(type='Move', tree='{var1/Person}', parent=., position=0)\", \"(type='Move', tree='{field/teaches{set of{sig/Course}}}', parent=., position=1)\", \"(type='Insert', node=set of, parent=field/enrolled, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=->)\", \"(type='Delete', node=var2/Course)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using signature of type Person, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{in{var2/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{in{var2/Course}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{!in{var0/Person}{.{field/enrolled{set of{sig/Course}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}}}}}","totalTED":20,"challenge":"PSqwzYAfW9dFAa9im","time":42831500,"targetExpr":"all p1, p2 : Professor | all c:Course | (c in p1.teaches) and (c in p2.teaches) implies p1 not in enrolled.(p2.teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student, p:Project | s -> p in projects implies (some c:Course | s -> c in enrolled and c -> p in projects) } pred inv7 { } pred inv8 { all p:Person | p.teaches & p.enrolled = none } pred inv9 { all t:Professor, c:Course | c in t.teaches implies (all p:Person | c in p.enrolled and p not in Professor) } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Course}}{=>{in{var1/Course}{.{var0/Person}{field/teaches{set of{sig/Course}}}}}{all{one of{var2}{sig/Person}}{AND{!in{var2/Person}{sig/Professor}}{in{var1/Course}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}}}}}}","nextExpr":"all p1,p2 : Professor | some (p1.teaches & p2.teaches) implies no (p1.teaches & p2.enrolled)","sourceExpr":"all t:Professor, c:Course | c in t.teaches implies (all p:Person | c in p.enrolled and p not in Professor)","predicate":"inv9","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Update', node=sig/Course, value=sig/Professor)\", \"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Update', node=AND, value=&)\", \"(type='Move', tree='{AND{!in{var2/Person}{sig/Professor}}{in{var1/Course}{.{var2/Person}{field/enrolled{set of{sig/Course}}}}}}', parent=no, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/teaches{set of{sig/Course}}}}', parent=&, position=0)\", \"(type='Update', node=one of, value=.)\", \"(type='Move', tree='{one of{var2}{sig/Person}}', parent=&, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{.{var2/Person}{field/enrolled{set of{sig/Course}}}}', parent=AND, position=1)\", \"(type='Update', node=var2, value=var1/Person)\", \"(type='Insert', node=field/teaches, parent=one of, position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Insert', node=field/teaches, parent=!in, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Insert', node=set of, parent=field/teaches, position=0)\", \"(type='Update', node=sig/Person, value=sig/Course)\", \"(type='Move', tree='{sig/Person}', parent=set of, position=0)\", \"(type='Update', node=sig/Professor, value=sig/Course)\", \"(type='Move', tree='{sig/Professor}', parent=set of, position=0)\", \"(type='Delete', node=var1/Course)\", \"(type='Delete', node=in)\", \"(type='Delete', node=var1/Course)\", \"(type='Delete', node=in)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using signature of type Course, try using signature of type Professor to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{=>{some{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/teaches{set of{sig/Course}}}}}}{no{&{.{var0/Person}{field/teaches{set of{sig/Course}}}}{.{var1/Person}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":21,"challenge":"PSqwzYAfW9dFAa9im","time":40492500,"targetExpr":"all p1,p2 : Professor | some (p1.teaches & p2.teaches) implies no (p1.teaches & p2.enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student->Course } pred inv2 { teaches in Professor->Course } pred inv3 { teaches in Professor some->Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { Person <: projects in Student some -> Project } pred inv6 { all s:Student,p:Project,c:Course | s->p in projects and c->p in projects implies s->c in enrolled } pred inv7 { all s:Student,c:Course | lone p:Project | s->p in projects and c->p in projects and s->c in enrolled } pred inv8 { all p:Person, c:Course | p->c in teaches and p->c in enrolled implies p not in Professor } pred inv9 { all p1,p2:Professor,c:Course | p1->c in teaches implies p2->c in enrolled } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}","nextExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | p->c in teaches implies p2->c not in enrolled","sourceExpr":"all p1,p2:Professor,c:Course | p1->c in teaches implies p2->c in enrolled","predicate":"inv9","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='TreeInsert', tree='{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}', parent==>, position=0)\", \"(type='Move', tree='{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}', parent==>, position=1)\", \"(type='Move', tree='{sig/Professor}', parent=-, position=0)\", \"(type='Insert', node=var0/Person, parent=-, position=1)\", \"(type='Update', node=in, value=!in)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{-{sig/Professor}{var0/Person}}}{=>{in{var1/Person}{.{.{var0/Person}{field/teaches{set of{sig/Course}}}}{~{field/teaches{set of{sig/Course}}}}}}{all{one of{var2}{sig/Course}}{=>{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}","totalTED":16,"challenge":"PSqwzYAfW9dFAa9im","time":43631300,"targetExpr":"all p:Professor | all p2:Professor-p | p2 in p.teaches.~teaches implies all c:Course | p->c in teaches implies p2->c not in enrolled","createdShorterPath":false}
{"mapping":"APTED","code":"open util/ordering[Grade] sig Person { teaches : set Course, enrolled : set Course, projects : set Project } sig Professor,Student in Person {} sig Course { projects : set Project, grades : Person -> Grade } sig Project {} sig Grade {} pred inv1 { enrolled in Student -> Course } pred inv2 { teaches in Professor -> Course } pred inv3 { teaches in Professor some -> Course } pred inv4 { Course <: projects in Course one -> Project } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { not some x: Professor | some c: Course | x->c in teaches and x->c in enrolled } pred inv9 { all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (not (p1->c in teaches or p2->c in teaches) ) } pred inv10 { all p: Person, g: Grade, c: Course | c->p->g in grades implies p in Student } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{some{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/enrolled{set of{sig/Course}}}}}{!{OR{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}}}}}}","nextExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","sourceExpr":"all p1,p2: Professor| some c: Course | p1->c in enrolled and p2->c in enrolled and p1!=p2 implies (not (p1->c in teaches or p2->c in teaches) )","predicate":"inv9","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=!, value=all)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Course}}', parent=!, position=0)\", \"(type='Update', node=OR, value==>)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=field/enrolled, value=field/teaches)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=field/teaches, value=field/enrolled)\", \"(type='Update', node=var2/Course, value=var3/Course)\", \"(type='Update', node=var2/Course, value=var3/Course)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Professor}}{all{one of{var1}{sig/Professor}}{all{one of{var2}{sig/Course}}{=>{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}{in{->{var1/Person}{var2/Course}}{field/teaches{set of{sig/Course}}}}}{all{one of{var3}{sig/Course}}{=>{in{->{var0/Person}{var3/Course}}{field/teaches{set of{sig/Course}}}}{!in{->{var1/Person}{var3/Course}}{field/enrolled{set of{sig/Course}}}}}}}}}}","totalTED":12,"challenge":"PSqwzYAfW9dFAa9im","time":50705800,"targetExpr":"all p1,p2 : Professor | all c1:Course | (p1!=p2 and p1->c1 in teaches and p2->c1 in teaches) implies (all c2 : Course | p1->c2 in teaches implies p2->c2 not in enrolled)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { succs in Track -> some Entry succs in Track -> one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{in{field/succs{set of{sig/Track}}}{->some{sig/Track}{sig/Entry}}}{in{field/succs{set of{sig/Track}}}{->one{sig/Track}{sig/Exit}}}}","nextExpr":"some Entry some Exit","sourceExpr":"succs in Track -> some Entry succs in Track -> one Exit","predicate":"inv1","isNewNode":true,"srcDstTED":12,"targetAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","operations":"[\"(type='Update', node=->some, value=some)\", \"(type='Move', tree='{->some{sig/Track}{sig/Entry}}', parent=AND, position=0)\", \"(type='Update', node=->one, value=some)\", \"(type='Move', tree='{->one{sig/Track}{sig/Exit}}', parent=AND, position=1)\", \"(type='Delete', node=sig/Track)\", \"(type='Delete', node=sig/Track)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using ->some, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","totalTED":12,"challenge":"QxGnrFQnXPGh2Lh8C","time":112011900,"targetExpr":"some Entry some Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { Junction in Track.*succs } pred inv6 { all t:Track, s:Signal | t->s in signals and t=Entry implies Speed in s } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{one{sig/Exit}}{some{sig/Entry}}}","nextExpr":"some Entry some Exit","sourceExpr":"some Entry and one Exit","predicate":"inv1","isNewNode":false,"srcDstTED":3,"targetAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","operations":"[\"(type='Update', node=one, value=some)\"]","hint":"Near a solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":87145100,"targetExpr":"some Entry some Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some e:Entry | e in t.*succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{in{var1/Track}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"all t:Track | some e:Entry | e in t.*succs","predicate":"inv1","isNewNode":true,"srcDstTED":9,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Update', node=in, value=AND)\", \"(type='Insert', node=in, parent=in, position=0)\", \"(type='Update', node=., value=in)\", \"(type='Move', tree='{var1/Track}', parent=in, position=0)\", \"(type='Insert', node=sig/Track, parent=in, position=1)\", \"(type='Move', tree='{sig/Track}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":9,"challenge":"QxGnrFQnXPGh2Lh8C","time":68143700,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Exit & Track } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{&{sig/Exit}{sig/Track}}}","nextExpr":"some Entry->Exit","sourceExpr":"some Exit & Track","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{some{->{sig/Entry}{sig/Exit}}}","operations":"[\"(type='Update', node=&, value=->)\", \"(type='Insert', node=sig/Entry, parent=&, position=0)\", \"(type='Delete', node=sig/Track)\"]","hint":"Near a solution! Instead of using intersection operator ('&') to find the common elements between two sets, try using arrow operator ('->') to map a relation.","nextAST":"{some{->{sig/Entry}{sig/Exit}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":37284700,"targetExpr":"some Entry->Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some e:Entry | some ex:Exit | e in t.succs and t in e.succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"all t:Track | some e:Entry | some ex:Exit | e in t.succs and t in e.succs","predicate":"inv1","isNewNode":true,"srcDstTED":14,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Move', tree='{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var1/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":14,"challenge":"QxGnrFQnXPGh2Lh8C","time":35803200,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.^succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{in{+{var1/Track}{var2/Track}}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.^succs","predicate":"inv1","isNewNode":true,"srcDstTED":13,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Update', node=in, value=AND)\", \"(type='Move', tree='{in{+{var1/Track}{var2/Track}}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Update', node=+, value=in)\", \"(type='Update', node=., value=in)\", \"(type='Update', node=var2/Track, value=sig/Track)\", \"(type='Move', tree='{sig/Track}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=^)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":13,"challenge":"QxGnrFQnXPGh2Lh8C","time":34218900,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.*succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{in{+{var1/Track}{var2/Track}}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.*succs","predicate":"inv1","isNewNode":true,"srcDstTED":13,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Update', node=in, value=AND)\", \"(type='Move', tree='{in{+{var1/Track}{var2/Track}}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Update', node=+, value=in)\", \"(type='Update', node=., value=in)\", \"(type='Update', node=var2/Track, value=sig/Track)\", \"(type='Move', tree='{sig/Track}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=*)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":13,"challenge":"QxGnrFQnXPGh2Lh8C","time":31577200,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { one Exit one Entry } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{one{sig/Exit}}{one{sig/Entry}}}","nextExpr":"some Exit and some Entry","sourceExpr":"one Exit one Entry","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{AND{some{sig/Exit}}{some{sig/Entry}}}","operations":"[\"(type='Update', node=one, value=some)\", \"(type='Update', node=one, value=some)\"]","hint":"Near a solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{sig/Exit}}{some{sig/Entry}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":36096100,"targetExpr":"some Exit and some Entry","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t: Track | some e: Entry, x: Exit | e in t && x in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{AND{in{var1/Track}{var0/Track}}{in{var2/Track}{var0/Track}}}}}}","nextExpr":"some e: Entry, ex: Exit | e in Track and ex in Track","sourceExpr":"all t : Track | some e : Entry | some s : Exit| e in t and s in t","predicate":"inv1","isNewNode":false,"srcDstTED":10,"targetAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","operations":"[\"(type='Move', tree='{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{AND{in{var1/Track}{var0/Track}}{in{var2/Track}{var0/Track}}}}}', parent=root, position=0)\", \"(type='Update', node=var1, value=var0)\", \"(type='Update', node=var2, value=var1)\", \"(type='Insert', node=sig/Track, parent=in, position=2)\", \"(type='Update', node=var2/Track, value=var1/Track)\", \"(type='Update', node=var0/Track, value=sig/Track)\", \"(type='Delete', node=var1/Track)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Track}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the existential quantifier ('some') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":96243900,"targetExpr":"some e: Entry, ex: Exit | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all e: Entry, x: Exit | some e && some x } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{AND{some{var0/Track}}{some{var1/Track}}}}}","nextExpr":"some e: Entry, ex: Exit | e in Track and ex in Track","sourceExpr":"all e: Entry, x: Exit | some e && some x","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=some, value=in)\", \"(type='Update', node=some, value=in)\", \"(type='Insert', node=sig/Track, parent=some, position=1)\", \"(type='Insert', node=sig/Track, parent=some, position=1)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":32537000,"targetExpr":"some e: Entry, ex: Exit | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { lone Exit and lone Entry } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{lone{sig/Exit}}{lone{sig/Entry}}}","nextExpr":"some Exit and some Entry","sourceExpr":"lone Exit and lone Entry","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{AND{some{sig/Exit}}{some{sig/Entry}}}","operations":"[\"(type='Update', node=lone, value=some)\", \"(type='Update', node=lone, value=some)\"]","hint":"Near a solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{sig/Exit}}{some{sig/Entry}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":33523100,"targetExpr":"some Exit and some Entry","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { succs in Track -> some Entry succs in Track -> some Exit } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{in{field/succs{set of{sig/Track}}}{->some{sig/Track}{sig/Entry}}}{in{field/succs{set of{sig/Track}}}{->some{sig/Track}{sig/Exit}}}}","nextExpr":"some Entry && some Exit","sourceExpr":"succs in Track -> some Entry succs in Track -> some Exit","predicate":"inv1","isNewNode":true,"srcDstTED":12,"targetAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","operations":"[\"(type='Update', node=->some, value=some)\", \"(type='Move', tree='{->some{sig/Track}{sig/Entry}}', parent=AND, position=0)\", \"(type='Update', node=->some, value=some)\", \"(type='Move', tree='{->some{sig/Track}{sig/Exit}}', parent=AND, position=1)\", \"(type='Delete', node=sig/Track)\", \"(type='Delete', node=sig/Track)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using ->some, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","totalTED":12,"challenge":"QxGnrFQnXPGh2Lh8C","time":35984900,"targetExpr":"some Entry && some Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t: Track | some e: Entry | e in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{in{var1/Track}{var0/Track}}}}","nextExpr":"some e : Entry | some s : Exit | (e+s) in Track","sourceExpr":"all t: Track | some e: Entry | e in t","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{in{+{var0/Track}{var1/Track}}{sig/Track}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Entry)\", \"(type='Update', node=sig/Entry, value=sig/Exit)\", \"(type='Insert', node=+, parent=in, position=0)\", \"(type='Update', node=var0/Track, value=sig/Track)\", \"(type='Insert', node=var0/Track, parent=+, position=0)\", \"(type='Move', tree='{var1/Track}', parent=+, position=1)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{in{+{var0/Track}{var1/Track}}{sig/Track}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":36175400,"targetExpr":"some e : Entry | some s : Exit | (e+s) in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some t: Track | some e: Entry | some x: Exit | e in t.succs && x in t.succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var2/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"some t: Track | some e: Entry | some x: Exit | e in t.succs && x in t.succs","predicate":"inv1","isNewNode":true,"srcDstTED":13,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Move', tree='{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var2/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using signature of type Track, try using signature of type Exit to help satisfy the required property.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":13,"challenge":"QxGnrFQnXPGh2Lh8C","time":32587100,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some e:Entry | some ex:Exit | e in t.succs and t in ex.succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"all t:Track | some e:Entry | some ex:Exit | e in t.succs and t in ex.succs","predicate":"inv1","isNewNode":true,"srcDstTED":14,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Move', tree='{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":14,"challenge":"QxGnrFQnXPGh2Lh8C","time":43533600,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{sig/Entry}}","nextExpr":"some Entry && some Exit","sourceExpr":"some Entry","predicate":"inv1","isNewNode":false,"srcDstTED":3,"targetAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","operations":"[\"(type='Insert', node=AND, parent=root, position=0)\", \"(type='Move', tree='{some{sig/Entry}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{some{sig/Exit}}', parent=AND, position=1)\"]","hint":"Near a solution! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":81696000,"targetExpr":"some Entry && some Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { succs in Track -> some Entry succs in Track -> some Exit signals in Track -> some Signal } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{in{field/succs{set of{sig/Track}}}{->some{sig/Track}{sig/Entry}}}{in{field/succs{set of{sig/Track}}}{->some{sig/Track}{sig/Exit}}}{in{field/signals{set of{sig/Signal}}}{->some{sig/Track}{sig/Signal}}}}","nextExpr":"some Entry some Exit","sourceExpr":"succs in Track -> some Entry succs in Track -> some Exit signals in Track -> some Signal","predicate":"inv1","isNewNode":true,"srcDstTED":19,"targetAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","operations":"[\"(type='Update', node=->some, value=some)\", \"(type='Move', tree='{->some{sig/Track}{sig/Entry}}', parent=AND, position=0)\", \"(type='Update', node=->some, value=some)\", \"(type='Move', tree='{->some{sig/Track}{sig/Exit}}', parent=AND, position=1)\", \"(type='Delete', node=sig/Track)\", \"(type='Delete', node=sig/Track)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{in{field/signals{set of{sig/Signal}}}{->some{sig/Track}{sig/Signal}}}')\"]","hint":"Keep going! Instead of using ->some, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{sig/Entry}}{some{sig/Exit}}}","totalTED":19,"challenge":"QxGnrFQnXPGh2Lh8C","time":33310100,"targetExpr":"some Entry some Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.*succs all t:Track | some s:Signal | t -> s in signals } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{in{+{var1/Track}{var2/Track}}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}}{all{one of{var0}{sig/Track}}{some{one of{var3}{sig/Signal}}{in{->{var0/Track}{var3/Signal}}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"some t: Track | t in Entry and t in Track some t: Track | t in Exit and t in Track","sourceExpr":"all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.*succs all t:Track | some s:Signal | t -> s in signals","predicate":"inv1","isNewNode":true,"srcDstTED":25,"targetAST":"{AND{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Track}}}}{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Exit}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=some, value=AND)\", \"(type='Update', node=some, value=AND)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{in{+{var1/Track}{var2/Track}}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node=var1, value=var0/Track)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Update', node=var3, value=var0/Track)\", \"(type='Update', node=sig/Signal, value=sig/Exit)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Update', node=var3/Signal, value=sig/Track)\", \"(type='Move', tree='{var3/Signal}', parent=in, position=1)\", \"(type='TreeDelete', tree='{+{var1/Track}{var2/Track}}')\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=*)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/signals{set of{sig/Signal}}}')\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Track}}}}{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Exit}}{in{var0/Track}{sig/Track}}}}}","totalTED":25,"challenge":"QxGnrFQnXPGh2Lh8C","time":41721400,"targetExpr":"some t: Track | t in Entry and t in Track some t: Track | t in Exit and t in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Track.succs & Entry and some Track.succs & Exit } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{some{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{sig/Entry}}}{some{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{sig/Exit}}}}","nextExpr":"some (Entry & Track) some (Exit & Track)","sourceExpr":"some Track.succs & Entry and some Track.succs & Exit","predicate":"inv1","isNewNode":true,"srcDstTED":10,"targetAST":"{AND{some{&{sig/Entry}{sig/Track}}}{some{&{sig/Exit}{sig/Track}}}}","operations":"[\"(type='Move', tree='{sig/Track}', parent=&, position=1)\", \"(type='Move', tree='{sig/Track}', parent=&, position=1)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! It seems like the signature of type Track is not in the right place. Try moving it to the inside of the intersection operator ('&') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{AND{some{&{sig/Entry}{sig/Track}}}{some{&{sig/Exit}{sig/Track}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":83872400,"targetExpr":"some (Entry & Track) some (Exit & Track)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t: Track| t in Entry and t in Exit } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Exit}}}}","nextExpr":"some e : Exit, en : Entry | e in Track and en in Track","sourceExpr":"all t : Track | t in Entry and t in Exit","predicate":"inv1","isNewNode":false,"srcDstTED":9,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Entry}}', parent=some, position=0)\", \"(type='Move', tree='{AND{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Exit}}}', parent=some, position=1)\", \"(type='Update', node=sig/Entry, value=sig/Track)\", \"(type='Update', node=var0/Track, value=var1/Track)\", \"(type='Update', node=sig/Exit, value=sig/Track)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","totalTED":9,"challenge":"QxGnrFQnXPGh2Lh8C","time":60823500,"targetExpr":"some e : Exit, en : Entry | e in Track and en in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | t in Entry or (some t.succs & Entry) or t in Exit or (some t.succs & Exit) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{OR{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Exit}}{some{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Entry}}}{some{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Exit}}}}}","nextExpr":"some t: Track | t in Entry and some t: Track | t in Exit","sourceExpr":"all t:Track | t in Entry or (some t.succs & Entry) or t in Exit or (some t.succs & Exit)","predicate":"inv1","isNewNode":true,"srcDstTED":19,"targetAST":"{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{some{one of{var0}{sig/Track}}{in{var0/Track}{sig/Exit}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=OR, value=AND)\", \"(type='Insert', node=some, parent=OR, position=1)\", \"(type='Update', node=., value=one of)\", \"(type='Move', tree='{.{var0/Track}{field/succs{set of{sig/Track}}}}', parent=some, position=0)\", \"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Exit}}', parent=some, position=1)\", \"(type='Update', node=var0/Track, value=var0)\", \"(type='Move', tree='{sig/Track}', parent=., position=1)\", \"(type='Move', tree='{var0/Track}', parent=&, position=0)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Exit}}')\", \"(type='Delete', node=sig/Entry)\", \"(type='Delete', node=&)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{some{one of{var0}{sig/Track}}{in{var0/Track}{sig/Exit}}}}}","totalTED":19,"challenge":"QxGnrFQnXPGh2Lh8C","time":60108400,"targetExpr":"some t: Track | t in Entry and some t: Track | t in Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry & Track } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{&{sig/Entry}{sig/Track}}}","nextExpr":"some Entry->Exit","sourceExpr":"some Entry & Track","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{some{->{sig/Entry}{sig/Exit}}}","operations":"[\"(type='Update', node=&, value=->)\", \"(type='Update', node=sig/Track, value=sig/Exit)\"]","hint":"Near a solution! Instead of using intersection operator ('&') to find the common elements between two sets, try using arrow operator ('->') to map a relation.","nextAST":"{some{->{sig/Entry}{sig/Exit}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":55285800,"targetExpr":"some Entry->Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | Entry in t and Exit in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{AND{in{sig/Entry}{var0/Track}}{in{sig/Exit}{var0/Track}}}}","nextExpr":"all x : univ | some Entry and some Exit","sourceExpr":"all t: Track | Entry in t and Exit in t","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{univ}}{AND{some{sig/Entry}}{some{sig/Exit}}}}","operations":"[\"(type='Update', node=sig/Track, value=univ)\", \"(type='Update', node=in, value=some)\", \"(type='Update', node=in, value=some)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using signature of type Track, try using universal quantifier ('univ') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{univ}}{AND{some{sig/Entry}}{some{sig/Exit}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":61828500,"targetExpr":"all x : univ | some Entry and some Exit","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all e: Entry, x: Exit | some (e & x) && some (x & e) } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{AND{some{&{var0/Track}{var1/Track}}}{some{&{var0/Track}{var1/Track}}}}}}","nextExpr":"some e: Entry, ex: Exit | e in Track and ex in Track","sourceExpr":"all e: Entry, x: Exit | some (e & x) && some (x & e)","predicate":"inv1","isNewNode":true,"srcDstTED":9,"targetAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{var0/Track}{var1/Track}}', parent=AND, position=0)\", \"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{var0/Track}{var1/Track}}', parent=AND, position=1)\", \"(type='Update', node=var1/Track, value=sig/Track)\", \"(type='Insert', node=sig/Track, parent=&, position=2)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Exit}}{AND{in{var0/Track}{sig/Track}}{in{var1/Track}{sig/Track}}}}}","totalTED":9,"challenge":"QxGnrFQnXPGh2Lh8C","time":34819300,"targetExpr":"some e: Entry, ex: Exit | e in Track and ex in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.*succs all t:Track | some s:Signal | s in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{in{+{var1/Track}{var2/Track}}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}}{all{one of{var0}{sig/Track}}{some{one of{var3}{sig/Signal}}{in{var3/Signal}{var0/Track}}}}}","nextExpr":"some t: Track | t in Entry and t in Track some t: Track | t in Exit and t in Track","sourceExpr":"all t:Track | some entry:Entry, exit:Exit | (entry + exit) in t.*succs all t:Track | some s:Signal | s in t","predicate":"inv1","isNewNode":true,"srcDstTED":22,"targetAST":"{AND{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Track}}}}{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Exit}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=some, value=AND)\", \"(type='Update', node=some, value=AND)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{in{+{var1/Track}{var2/Track}}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node=var1, value=var0/Track)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Update', node=var3, value=var0/Track)\", \"(type='Update', node=sig/Signal, value=sig/Exit)\", \"(type='Insert', node=sig/Track, parent=in, position=2)\", \"(type='TreeDelete', tree='{+{var1/Track}{var2/Track}}')\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=*)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\", \"(type='Delete', node=var3/Signal)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{AND{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Entry}}{in{var0/Track}{sig/Track}}}}{some{one of{var0}{sig/Track}}{AND{in{var0/Track}{sig/Exit}}{in{var0/Track}{sig/Track}}}}}","totalTED":22,"challenge":"QxGnrFQnXPGh2Lh8C","time":36942100,"targetExpr":"some t: Track | t in Entry and t in Track some t: Track | t in Exit and t in Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { all t: Track | some e: Entry | some x: Exit | e in t.succs && x in t.succs } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Entry}}{some{one of{var2}{sig/Exit}}{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var2/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","sourceExpr":"all x: Track | some y : Entry, z : Exit | y in x.succs && z in x.succs","predicate":"inv1","isNewNode":false,"srcDstTED":14,"targetAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Move', tree='{AND{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var2/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Move', tree='{sig/Track}', parent=in, position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Track)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/succs)\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Exit}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Exit}}{some{one of{var1}{sig/Entry}}{AND{in{var1/Track}{sig/Track}}{in{var0/Track}{sig/Track}}}}}","totalTED":14,"challenge":"QxGnrFQnXPGh2Lh8C","time":74620400,"targetExpr":"some ex:Exit, e:Entry | e in Track and ex in Track","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some ex : Exit , en : Entry | ex in Track and en in Track } pred inv2 { all s : Signal | one t : Track | s in t.signals } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t : Track | some s : Signal | t in Entry implies s in Speed and s in t.signals } pred inv7 { all t : Track | t not in t.^succs } pred inv8 { all disj t1, t2 : Track | t1 in Entry and t2 in Exit implies t2 in t1.^succs } pred inv9 { } pred inv10 { all t: Track | Junction in t.succs implies Semaphore in t.signals }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{sig/Junction}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{sig/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t : Track | t in succs.Junction implies t in signals.Semaphore","sourceExpr":"all x: Track | Junction in x.succs implies Semaphore in x.signals","predicate":"inv10","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=sig/Junction, value=var0/Track)\", \"(type='Update', node=sig/Semaphore, value=var0/Track)\", \"(type='Insert', node=sig/Junction, parent=., position=2)\", \"(type='Insert', node=sig/Semaphore, parent=., position=2)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using signature of type Junction, try using variable of type Track to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":153567700,"targetExpr":"all t : Track | t in succs.Junction implies t in signals.Semaphore","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | t in succs.Junction => t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","sourceExpr":"all t: Track | t in succs.Junction => t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":76716900,"targetExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | t in succs.Junction iff t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","sourceExpr":"all t: Track | t in succs.Junction iff t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=some, parent=<=>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":46636700,"targetExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | some t & succs.Junction implies t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{some{&{.{field/succs{set of{sig/Track}}}{sig/Junction}}{var0/Track}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t: Track | some (t.succs & Junction) => some (t.signals & Semaphore)","sourceExpr":"all t: Track | some t & succs.Junction implies t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{some{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\", \"(type='Update', node=var0/Track, value=sig/Junction)\", \"(type='Insert', node=var0/Track, parent=., position=0)\", \"(type='Delete', node=sig/Junction)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Track}}{=>{some{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":51119100,"targetExpr":"all t: Track | some (t.succs & Junction) => some (t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | t in Junction.~succs implies t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{sig/Junction}{~{field/succs{set of{sig/Track}}}}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","sourceExpr":"all t: Track | t in Junction.~succs implies t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=0)\", \"(type='Insert', node=sig/Junction, parent=., position=1)\", \"(type='Delete', node=sig/Junction)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":34298600,"targetExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | some t & Junction.~succs implies t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{some{&{.{sig/Junction}{~{field/succs{set of{sig/Track}}}}}{var0/Track}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t: Track | some (t.succs & Junction) => some (t.signals & Semaphore)","sourceExpr":"all t: Track | some t & Junction.~succs implies t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{some{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\", \"(type='Update', node=var0/Track, value=sig/Junction)\", \"(type='Update', node=sig/Junction, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=~)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Track}}{=>{some{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":33297500,"targetExpr":"all t: Track | some (t.succs & Junction) => some (t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some ex : Exit , en : Entry | ex in Track and en in Track } pred inv2 { all s : Signal | one t : Track | s in t.signals } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t : Track | some s : Signal | t in Entry implies s in Speed and s in t.signals } pred inv7 { all t : Track | t not in t.^succs } pred inv8 { all disj t1, t2 : Track | t1 in Entry and t2 in Exit implies t2 in t1.^succs } pred inv9 { } pred inv10 { all t: Track | Semaphore in t.signals implies Junction in t.succs }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{sig/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}{in{sig/Junction}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t : Track | t in succs.Junction implies t in signals.Semaphore","sourceExpr":"all t: Track | Semaphore in t.signals implies Junction in t.succs","predicate":"inv10","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=sig/Semaphore, value=var0/Track)\", \"(type='Update', node=sig/Junction, value=var0/Track)\", \"(type='Update', node=field/signals, value=field/succs)\", \"(type='Insert', node=sig/Junction, parent=., position=2)\", \"(type='Update', node=field/succs, value=field/signals)\", \"(type='Insert', node=sig/Semaphore, parent=., position=2)\", \"(type='Update', node=sig/Signal, value=sig/Track)\", \"(type='Update', node=sig/Track, value=sig/Signal)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using signature of type Semaphore, try using variable of type Track to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":33952800,"targetExpr":"all t : Track | t in succs.Junction implies t in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | t in Junction.succs implies t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{sig/Junction}{field/succs{set of{sig/Track}}}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | t in succs.Junction implies some (t.signals & Semaphore)","sourceExpr":"all t: Track | t in Junction.succs implies t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\", \"(type='Insert', node=sig/Junction, parent=., position=2)\", \"(type='Delete', node=sig/Junction)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":42059200,"targetExpr":"all t : Track | t in succs.Junction implies some (t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { all t: Track | t in succs.Junction and t.signals in Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{AND{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","sourceExpr":"all t: Track | t in succs.Junction and t.signals in Semaphore","predicate":"inv10","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Insert', node=some, parent=AND, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":38056900,"targetExpr":"all t : Track | t in (succs.Junction) implies some(t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.succs } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all s: Signal | one t: Track | s in t.signals","sourceExpr":"all s:Signal | one t:Track | s in t.succs","predicate":"inv2","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","operations":"[\"(type='Update', node=field/succs, value=field/signals)\", \"(type='Update', node=sig/Track, value=sig/Signal)\"]","hint":"Near a solution! Instead of using field \"succs\", try using field \"signals\" to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":124125200,"targetExpr":"all s: Signal | one t: Track | s in t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{var1/Track}}}}","nextExpr":"all s: Signal | one t: Track | s in t.signals","sourceExpr":"all x:Signal | one y: Track | x in y","predicate":"inv2","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","operations":"[\"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var1/Track}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/signals{set of{sig/Signal}}}', parent=., position=1)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":94433000,"targetExpr":"all s: Signal | one t: Track | s in t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e: Entry| some t: Exit| e in Track and t in Track } pred inv2 { all s: Signal| some t: Track| one t.signals } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Signal}}{some{one of{var1}{sig/Track}}{one{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all s: Signal | one t: Track | s in t.signals","sourceExpr":"all s: Signal| some t: Track| one t.signals","predicate":"inv2","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","operations":"[\"(type='Update', node=some, value=one)\", \"(type='Update', node=one, value=in)\", \"(type='Insert', node=var0/Signal, parent=one, position=0)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Signal}}{one{one of{var1}{sig/Track}}{in{var0/Signal}{.{var1/Track}{field/signals{set of{sig/Signal}}}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":85472900,"targetExpr":"all s: Signal | one t: Track | s in t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all e:Exit, t:Track | t not in e.succs } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t:Track | t in Exit iff all ts:Track | ts not in t.succs","sourceExpr":"all e : Exit | (all t : Track | t not in e.succs)","predicate":"inv3","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Move', tree='{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}', parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent=<=>, position=1)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":122204000,"targetExpr":"all t:Track | t in Exit iff all ts:Track | ts not in t.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs implies t in Exit } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Exit}}}}","nextExpr":"all t: Track | t in Exit iff no t.succs","sourceExpr":"all t : Track | no t.succs implies t in Exit","predicate":"inv3","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent==>, position=0)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Exit}}')\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","totalTED":7,"challenge":"QxGnrFQnXPGh2Lh8C","time":74304100,"targetExpr":"all t: Track | t in Exit iff no t.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all e:Exit | one t:Track | t not in e.succs } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{one{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all e : Track | e in Exit iff (all t : Track | t not in e.succs)","sourceExpr":"all e:Exit | one t:Track | t not in e.succs","predicate":"inv3","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Update', node=one, value=all)\", \"(type='Move', tree='{one{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}', parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent=<=>, position=1)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":107425500,"targetExpr":"all e : Track | e in Exit iff (all t : Track | t not in e.succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Exit and some Entry } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit implies no t.^(succs) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t:Track | t in Exit iff no t.^(succs)","sourceExpr":"all t:Track | t in Exit => no t.^(succs)","predicate":"inv3","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":73606100,"targetExpr":"all t:Track | t in Exit iff no t.^(succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry && some Exit } pred inv2 { all s: Signal | one s.~signals } pred inv3 { all x: Exit | #x.succs = 0 } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{={#{.{var0/Track}{field/succs{set of{sig/Track}}}}}{0}}}","nextExpr":"all t : Track | #(t.succs) = 0 iff t in Exit","sourceExpr":"all e : Exit | #(e.succs) = 0","predicate":"inv3","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{={#{.{var0/Track}{field/succs{set of{sig/Track}}}}}{0}}{in{var0/Track}{sig/Exit}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Move', tree='{={#{.{var0/Track}{field/succs{set of{sig/Track}}}}}{0}}', parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent=<=>, position=1)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{={#{.{var0/Track}{field/succs{set of{sig/Track}}}}}{0}}{in{var0/Track}{sig/Exit}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":73155100,"targetExpr":"all t : Track | #(t.succs) = 0 iff t in Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Exit and some Entry } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all e:Exit | no e.^(succs) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t:Track| t in Exit iff no t.^succs","sourceExpr":"all e:Exit | no e.^succs","predicate":"inv3","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent=<=>, position=0)\", \"(type='Move', tree='{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}', parent=<=>, position=1)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":73733000,"targetExpr":"all t:Track| t in Exit iff no t.^succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all e:Exit, t:Track | t not in e.^(succs) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all e : Track | e in Exit iff (all t : Track | t not in e.succs)","sourceExpr":"all e:Exit, t:Track | t not in e.^(succs)","predicate":"inv3","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Move', tree='{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}', parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent=<=>, position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{all{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":32747400,"targetExpr":"all e : Track | e in Exit iff (all t : Track | t not in e.succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |Exit in t implies #t.succs=0 } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{sig/Exit}{var0/Track}}{={#{.{var0/Track}{field/succs{set of{sig/Track}}}}}{0}}}}","nextExpr":"all t: Track | t in Exit iff no t.succs","sourceExpr":"all t : Track | Exit in t => #t.succs = 0","predicate":"inv3","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=#, value=no)\", \"(type='Move', tree='{#{.{var0/Track}{field/succs{set of{sig/Track}}}}}', parent==>, position=1)\", \"(type='Insert', node=var0/Track, parent=in, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=0)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":82370400,"targetExpr":"all t: Track | t in Exit iff no t.succs","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all e:Exit | one t:Track | t not in e.^(succs) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{one{one of{var1}{sig/Track}}{!in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t:Track | t in Exit iff no t.^(succs)","sourceExpr":"all e:Exit | one t:Track | t not in e.^(succs)","predicate":"inv3","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","operations":"[\"(type='Update', node=one, value=<=>)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Update', node=one of, value=in)\", \"(type='Update', node=!in, value=no)\", \"(type='Update', node=var1, value=var0/Track)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Delete', node=var1/Track)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","totalTED":7,"challenge":"QxGnrFQnXPGh2Lh8C","time":43389400,"targetExpr":"all t:Track | t in Exit iff no t.^(succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all e:Exit | no e.succs } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}","nextExpr":"all t: Track | t in Exit iff no t.succs","sourceExpr":"all e : Exit | no e.succs","predicate":"inv3","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Exit}}', parent=<=>, position=0)\", \"(type='Move', tree='{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}', parent=<=>, position=1)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":73873600,"targetExpr":"all t: Track | t in Exit iff no t.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |t in Exit implies no t.succs } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t: Track | t in Exit iff no t.succs","sourceExpr":"all t : Track | t in Exit implies no t.succs","predicate":"inv3","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":67538700,"targetExpr":"all t: Track | t in Exit iff no t.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit <=> t not in t.^(succs) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Exit}}}}","nextExpr":"all t : Track | (t.succs)=none iff t in Exit","sourceExpr":"all t:Track | t in Exit <=> t not in t.^(succs)","predicate":"inv3","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{={.{var0/Track}{field/succs{set of{sig/Track}}}}{none}}{in{var0/Track}{sig/Exit}}}}","operations":"[\"(type='Update', node=!in, value==)\", \"(type='Insert', node=none, parent=!in, position=2)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{={.{var0/Track}{field/succs{set of{sig/Track}}}}{none}}{in{var0/Track}{sig/Exit}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":42491000,"targetExpr":"all t : Track | (t.succs)=none iff t in Exit","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |Exit in t implies (no t.succs) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{sig/Exit}{var0/Track}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t : Track | t in Exit implies no t.succs","sourceExpr":"all t:Track | Exit in t implies no t.succs","predicate":"inv3","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Insert', node=var0/Track, parent=in, position=0)\", \"(type='Delete', node=var0/Track)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Track to correctly capture the property you want to specify. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":97373600,"targetExpr":"all t: Track | t in Exit iff no t.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { Junction in Track.*succs } pred inv6 { all t:Track, s:Signal | t->s in signals and t=Entry implies Speed in s } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{.{sig/Exit}{field/succs{set of{sig/Track}}}}}","nextExpr":"Exit = Track - succs.Track","sourceExpr":"no Exit.succs","predicate":"inv3","isNewNode":false,"srcDstTED":6,"targetAST":"{={-{sig/Track}{.{field/succs{set of{sig/Track}}}{sig/Track}}}{sig/Exit}}","operations":"[\"(type='Insert', node==, parent=root, position=0)\", \"(type='Update', node=no, value=-)\", \"(type='Move', tree='{no{.{sig/Exit}{field/succs{set of{sig/Track}}}}}', parent==, position=0)\", \"(type='Insert', node=sig/Exit, parent==, position=1)\", \"(type='Insert', node=sig/Track, parent=no, position=0)\", \"(type='Insert', node=sig/Track, parent=., position=2)\", \"(type='Delete', node=sig/Exit)\"]","hint":"Keep going! Consider adding a equal operator ('=') to specify that the left side is equal to the right side. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{={-{sig/Track}{.{field/succs{set of{sig/Track}}}{sig/Track}}}{sig/Exit}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":75741400,"targetExpr":"Exit = Track - succs.Track","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs no Exit.signals } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{no{.{sig/Exit}{field/succs{set of{sig/Track}}}}}{no{.{sig/Exit}{field/signals{set of{sig/Signal}}}}}}","nextExpr":"Exit = Track - succs.Track","sourceExpr":"no Exit.succs no Exit.signals","predicate":"inv3","isNewNode":false,"srcDstTED":10,"targetAST":"{={-{sig/Track}{.{field/succs{set of{sig/Track}}}{sig/Track}}}{sig/Exit}}","operations":"[\"(type='Update', node=AND, value==)\", \"(type='Update', node=no, value=-)\", \"(type='Move', tree='{sig/Exit}', parent=AND, position=1)\", \"(type='Insert', node=sig/Track, parent=no, position=0)\", \"(type='Insert', node=sig/Track, parent=., position=2)\", \"(type='Delete', node=sig/Exit)\", \"(type='TreeDelete', tree='{field/signals{set of{sig/Signal}}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{={-{sig/Track}{.{field/succs{set of{sig/Track}}}{sig/Track}}}{sig/Exit}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":89709000,"targetExpr":"Exit = Track - succs.Track","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry && some Exit } pred inv2 { all s: Signal | one s.~signals } pred inv3 { all x: Exit | x not in Track.succs } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Exit}}{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}}","nextExpr":"all t: Track | t in Exit iff no t.succs","sourceExpr":"all t : Exit | t not in Track.succs","predicate":"inv3","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node=!in, value=<=>)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Insert', node=in, parent=!in, position=0)\", \"(type='Insert', node=no, parent=!in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Insert', node=sig/Exit, parent=in, position=1)\", \"(type='Move', tree='{.{sig/Track}{field/succs{set of{sig/Track}}}}', parent=no, position=0)\", \"(type='Update', node=sig/Track, value=var0/Track)\"]","hint":"Keep going! Instead of using exclusion operator ('!in') to specify that some element(s) do not belong to a set, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Exit}}{no{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":82558000,"targetExpr":"all t: Track | t in Exit iff no t.succs","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry && some Exit } pred inv2 { all s: Signal | one s.~signals } pred inv3 { all t: Track | (t in Exit) <=> no t.succs } pred inv4 { all t: Track | (t in Entry) <=> t.succs not in Entry } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Entry}}{in{var0/Track}{sig/Entry}}}}","nextExpr":"all t : Track | t in Entry iff t not in Track.succs","sourceExpr":"all t: Track | (t in Entry) <=> t.succs not in Entry","predicate":"inv4","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Entry}}}}","operations":"[\"(type='Insert', node=var0/Track, parent=!in, position=0)\", \"(type='Update', node=var0/Track, value=sig/Track)\", \"(type='Delete', node=sig/Entry)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Track to correctly capture the property you want to specify. Think about how you can incorporate this within the exclusion operator ('!in') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Entry}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":118249900,"targetExpr":"all t : Track | t in Entry iff t not in Track.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry && some Exit } pred inv2 { all s: Signal | one s.~signals } pred inv3 { all t: Track | (t in Exit) <=> no t.succs } pred inv4 { all t: Track | (t in Entry) <=> no t.^succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t : Track | t in Entry <=> no succs.t","sourceExpr":"all t : Track | t in Entry <=> no t.^succs","predicate":"inv4","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=0)\", \"(type='Insert', node=var0/Track, parent=., position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=^)\"]","hint":"Near a solution! It seems like the field \"succs\" is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":92328800,"targetExpr":"all t : Track | t in Entry <=> no succs.t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.^succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{sig/Track}{.{sig/Entry}{^{field/succs{set of{sig/Track}}}}}}","nextExpr":"Entry = Track - Track.^succs","sourceExpr":"Track in Entry.^succs","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{={-{sig/Track}{.{sig/Track}{^{field/succs{set of{sig/Track}}}}}}{sig/Entry}}","operations":"[\"(type='Insert', node==, parent=root, position=0)\", \"(type='Update', node=in, value=-)\", \"(type='Move', tree='{in{sig/Track}{.{sig/Entry}{^{field/succs{set of{sig/Track}}}}}}', parent==, position=0)\", \"(type='Insert', node=sig/Entry, parent==, position=1)\", \"(type='Update', node=sig/Entry, value=sig/Track)\"]","hint":"Keep going! Consider adding a equal operator ('=') to specify that the left side is equal to the right side. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{={-{sig/Track}{.{sig/Track}{^{field/succs{set of{sig/Track}}}}}}{sig/Entry}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":40419500,"targetExpr":"Entry = Track - Track.^succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry && some Exit } pred inv2 { all s: Signal | one s.~signals } pred inv3 { all t: Track | (t in Exit) <=> no t.succs } pred inv4 { all t: Entry | no t.^succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{no{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all e:Entry| no succs.e","sourceExpr":"all e: Entry | no e.^succs","predicate":"inv4","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=0)\", \"(type='Insert', node=var0/Track, parent=., position=1)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=^)\"]","hint":"Keep going! It seems like the field \"succs\" is not in the right place. Try moving it to the inside of the dot join operator ('.') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":61641500,"targetExpr":"all t : Track | t in Entry <=> no succs.t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff t not in succs.Track } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Track}}}{in{var0/Track}{sig/Entry}}}}","nextExpr":"all t : Track | t in Entry iff t not in Track.succs","sourceExpr":"all t : Track | t in Entry iff t not in succs.Track","predicate":"inv4","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Entry}}}}","operations":"[\"(type='Insert', node=sig/Track, parent=., position=0)\", \"(type='Delete', node=sig/Track)\"]","hint":"Near a solution! Consider adding a signature of type Track to help satisfy the required property. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Entry}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":38085600,"targetExpr":"all t : Track | t in Entry iff t not in Track.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{no{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{var0/Track}}}}","nextExpr":"all t : Track | t in Entry iff t not in Track.succs","sourceExpr":"all t:Track | no t & Track.succs","predicate":"inv4","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Entry}}}}","operations":"[\"(type='Update', node=&, value=<=>)\", \"(type='Move', tree='{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{var0/Track}}', parent=all, position=1)\", \"(type='Insert', node=!in, parent=&, position=0)\", \"(type='Insert', node=in, parent=&, position=1)\", \"(type='Insert', node=var0/Track, parent=!in, position=0)\", \"(type='Move', tree='{.{sig/Track}{field/succs{set of{sig/Track}}}}', parent=!in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=in, position=0)\", \"(type='Insert', node=sig/Entry, parent=in, position=1)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using intersection operator ('&') to find the common elements between two sets, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{sig/Entry}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":37148000,"targetExpr":"all t : Track | t in Entry iff t not in Track.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{sig/Track}{.{sig/Entry}{*{field/succs{set of{sig/Track}}}}}}","nextExpr":"Entry = Track - (Track . succs)","sourceExpr":"Track in Entry.*succs","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{={-{sig/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{sig/Entry}}","operations":"[\"(type='Insert', node==, parent=root, position=0)\", \"(type='Update', node=in, value=-)\", \"(type='Move', tree='{in{sig/Track}{.{sig/Entry}{*{field/succs{set of{sig/Track}}}}}}', parent==, position=0)\", \"(type='Insert', node=sig/Entry, parent==, position=1)\", \"(type='Update', node=sig/Entry, value=sig/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Consider adding a equal operator ('=') to specify that the left side is equal to the right side. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{={-{sig/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{sig/Entry}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":37560400,"targetExpr":"Entry = Track - (Track . succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs and no Entry->Entry } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{in{sig/Track}{.{sig/Entry}{*{field/succs{set of{sig/Track}}}}}}{no{->{sig/Entry}{sig/Entry}}}}","nextExpr":"Entry = Track - (Track . succs)","sourceExpr":"Track in Entry.*succs and no Entry->Entry","predicate":"inv4","isNewNode":true,"srcDstTED":7,"targetAST":"{={-{sig/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{sig/Entry}}","operations":"[\"(type='Update', node=AND, value==)\", \"(type='Update', node=in, value=-)\", \"(type='Move', tree='{sig/Entry}', parent=AND, position=1)\", \"(type='Update', node=sig/Entry, value=sig/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=*)\", \"(type='Delete', node=sig/Entry)\", \"(type='Delete', node=->)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{={-{sig/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{sig/Entry}}","totalTED":7,"challenge":"QxGnrFQnXPGh2Lh8C","time":42997100,"targetExpr":"Entry = Track - (Track . succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { one Entry Track in Entry.*succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{AND{in{sig/Track}{.{sig/Entry}{*{field/succs{set of{sig/Track}}}}}}{one{sig/Entry}}}","nextExpr":"Entry = Track - (Track . succs)","sourceExpr":"one Entry Track in Entry.*succs","predicate":"inv4","isNewNode":true,"srcDstTED":5,"targetAST":"{={-{sig/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{sig/Entry}}","operations":"[\"(type='Update', node=AND, value==)\", \"(type='Update', node=in, value=-)\", \"(type='Move', tree='{sig/Entry}', parent=AND, position=1)\", \"(type='Update', node=sig/Entry, value=sig/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=*)\", \"(type='Delete', node=one)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using equal operator ('=') to specify that the left side is equal to the right side.","nextAST":"{={-{sig/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}{sig/Entry}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":36031400,"targetExpr":"Entry = Track - (Track . succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff no Track.succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{sig/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t : Track | t in Entry <=> no succs.t","sourceExpr":"all t : Track | t in Entry iff no Track.succs","predicate":"inv4","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=sig/Track)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Track to correctly capture the property you want to specify. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":90263700,"targetExpr":"all t : Track | t in Entry <=> no succs.t","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { no succs.Entry } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{.{field/succs{set of{sig/Track}}}{sig/Entry}}}","nextExpr":"all t: Track | t in Entry iff no ^(succs).t","sourceExpr":"no succs.Entry","predicate":"inv4","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{^{field/succs{set of{sig/Track}}}}{var0/Track}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Track}}', parent=all, position=0)\", \"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Entry}}', parent=<=>, position=0)\", \"(type='Move', tree='{no{.{field/succs{set of{sig/Track}}}{sig/Entry}}}', parent=<=>, position=1)\", \"(type='Insert', node=^, parent=., position=0)\", \"(type='Update', node=sig/Entry, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=^, position=0)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Track\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{^{field/succs{set of{sig/Track}}}}{var0/Track}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":44079900,"targetExpr":"all t: Track | t in Entry iff no ^(succs).t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff no t.*succs } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t : Track | t in Entry iff no t.~succs","sourceExpr":"all t:Track | t in Entry iff no t.*succs","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}","operations":"[\"(type='Update', node=*, value=~)\"]","hint":"One step away from the solution! Instead of using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation, try using transpose operator ('~') to transpose a relation.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":37252000,"targetExpr":"all t : Track | t in Entry iff no t.~succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry implies t not in succs.Track } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Track}}}}}","nextExpr":"all t : Track | t in Entry <=> no succs.t","sourceExpr":"all t : Track | t in Entry implies t not in succs.Track","predicate":"inv4","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=!in, value=no)\", \"(type='Update', node=sig/Track, value=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{no{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":34662000,"targetExpr":"all t : Track | t in Entry <=> no succs.t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1:Track | some t2,t3:Track | t1 in t2.succs and t1 in t3.succs implies t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{=>{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t : Track | t in Junction iff (some y,z : Track | t in y.succs and t in z.succs and y!=z)","sourceExpr":"all t: Track | some t1, t2: Track | t in t1.succs && t in t2.succs => t in Junction","predicate":"inv5","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{=>{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}', parent=<=>, position=1)\", \"(type='Move', tree='{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='TreeInsert', tree='{!={var1/Track}{var2/Track}}', parent=AND, position=0)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Junction}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":11,"challenge":"QxGnrFQnXPGh2Lh8C","time":158270300,"targetExpr":"all t : Track | t in Junction iff (some y,z : Track | t in y.succs and t in z.succs and y!=z)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { all t:Track | t in Junction iff #(Track.succs)>0 } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{sig/Track}{field/succs{set of{sig/Track}}}}}{0}}{in{var0/Track}{sig/Junction}}}}","nextExpr":"all t : Track | t in Junction iff #succs.t>1","sourceExpr":"all t:Track | t in Junction iff #(Track.succs)>0","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{field/succs{set of{sig/Track}}}{var0/Track}}}{1}}{in{var0/Track}{sig/Junction}}}}","operations":"[\"(type='Update', node=0, value=1)\", \"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=sig/Track)\"]","hint":"Near a solution! Instead of using 0, try using 1 to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{field/succs{set of{sig/Track}}}{var0/Track}}}{1}}{in{var0/Track}{sig/Junction}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":79784700,"targetExpr":"all t : Track | t in Junction iff #succs.t>1","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { Junction in Track.*succs } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{sig/Junction}{.{sig/Track}{*{field/succs{set of{sig/Track}}}}}}","nextExpr":"Junction = { t : Track | not lone succs.t }","sourceExpr":"Junction in Track.*(succs)","predicate":"inv5","isNewNode":false,"srcDstTED":10,"targetAST":"{={comprehension{one of{var0}{sig/Track}}{!{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}{sig/Junction}}","operations":"[\"(type='Insert', node==, parent=root, position=0)\", \"(type='Update', node=in, value=comprehension)\", \"(type='Move', tree='{in{sig/Junction}{.{sig/Track}{*{field/succs{set of{sig/Track}}}}}}', parent==, position=0)\", \"(type='Insert', node=sig/Junction, parent==, position=1)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Insert', node=!, parent=in, position=1)\", \"(type='Update', node=sig/Junction, value=var0)\", \"(type='Move', tree='{sig/Junction}', parent=one of, position=0)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Insert', node=lone, parent=!, position=0)\", \"(type='Update', node=*, value=.)\", \"(type='Move', tree='{*{field/succs{set of{sig/Track}}}}', parent=lone, position=0)\", \"(type='Insert', node=var0/Track, parent=*, position=1)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a equal operator ('=') to specify that the left side is equal to the right side. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{={comprehension{one of{var0}{sig/Track}}{!{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}{sig/Junction}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":95785900,"targetExpr":"Junction = { t : Track | not lone succs.t }","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{=>{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{=>{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}', parent=<=>, position=1)\", \"(type='Move', tree='{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}', parent=some, position=1)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Junction}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":38278500,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t:Track | (some p1,p2:Track | p1 != p2 and p1 in t & Track.succs and p2 in t & Track.succs) iff t in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var1/Track}{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{var0/Track}}}{in{var2/Track}{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{var0/Track}}}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t:Track | (some p1,p2:Track | p1 != p2 and p1 in t & Track.succs and p2 in t & Track.succs) iff t in Junction","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{.{sig/Track}{field/succs{set of{sig/Track}}}}', parent=in, position=1)\", \"(type='Update', node=var2/Track, value=var0/Track)\", \"(type='Move', tree='{.{sig/Track}{field/succs{set of{sig/Track}}}}', parent=in, position=1)\", \"(type='Update', node=sig/Track, value=var1/Track)\", \"(type='Update', node=sig/Track, value=var2/Track)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=&)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=&)\"]","hint":"Keep going! Instead of using variable of type Track, try using variable of type Track to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":46769100,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1:Track | all t2,t3:Track | t1 in t2.succs and t1 in t3.succs implies t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{=>{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t : Track | t in Junction iff (some y,z : Track | t in y.succs and t in z.succs and y!=z)","sourceExpr":"all t1,t2,t3:Track | t1 in t2.succs and t1 in t3.succs implies t1 in Junction","predicate":"inv5","isNewNode":false,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{=>{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}', parent=<=>, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var1/Track}{var2/Track}}', parent=AND, position=0)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Junction}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":13,"challenge":"QxGnrFQnXPGh2Lh8C","time":76018900,"targetExpr":"all t : Track | t in Junction iff (some y,z : Track | t in y.succs and t in z.succs and y!=z)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.^succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{AND{!={var0/Track}{var1/Track}}{in{field/succs{set of{sig/Track}}}{->{var1/Track}{var0/Track}}}}}}}","nextExpr":"all t : Track | t in Junction iff some disj t1, t2 : Track | (t1 + t2) in succs.t","sourceExpr":"all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2)","predicate":"inv5","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{in{+{var1/Track}{var2/Track}}{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}}}","operations":"[\"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Update', node=AND, value=some)\", \"(type='Insert', node=disj, parent=AND, position=0)\", \"(type='Update', node=!=, value=one of)\", \"(type='Update', node=var0/Track, value=var2)\", \"(type='Update', node=var1/Track, value=sig/Track)\", \"(type='TreeInsert', tree='{+{var1/Track}{var2/Track}}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Track}', parent=., position=1)\", \"(type='Delete', node=var1/Track)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a disjoint operator ('disj') to specify that two sets are disjoint. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{in{+{var1/Track}{var2/Track}}{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}}}","totalTED":12,"challenge":"QxGnrFQnXPGh2Lh8C","time":38864800,"targetExpr":"all t : Track | t in Junction iff some disj t1, t2 : Track | (t1 + t2) in succs.t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Junction | some p1, p2 : Track | p1 -> j in succs and p2 -> j in succs and p1 != p2 } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.*succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t->t1 in ~succs and t->t2 in ~succs and t1 != t2","sourceExpr":"all j : Junction | some p1, p2 : Track | p1 -> j in succs and p2 -> j in succs and p1 != p2","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var0/Track}{var1/Track}}{~{field/succs{set of{sig/Track}}}}}{in{->{var0/Track}{var2/Track}}{~{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Junction, value=sig/Track)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}', parent=<=>, position=1)\", \"(type='Insert', node=~, parent=in, position=1)\", \"(type='Insert', node=~, parent=in, position=1)\", \"(type='Insert', node=var0/Track, parent=->, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Insert', node=var0/Track, parent=->, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var0/Track}{var1/Track}}{~{field/succs{set of{sig/Track}}}}}{in{->{var0/Track}{var2/Track}}{~{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":11,"challenge":"QxGnrFQnXPGh2Lh8C","time":34938100,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t->t1 in ~succs and t->t2 in ~succs and t1 != t2","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1,t2,t3:Track | t2 != t3 and t1 in t2.succs and t1 in t3.succs iff t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{<=>{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t, t1, t2: Track | t in t1.succs && t in t2.succs && t1!=t2 <=> t in Junction","predicate":"inv5","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}', parent=<=>, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=field/succs, value=AND)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=all, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Move', tree='{in{var0/Track}{sig/Junction}}', parent=field/succs, position=0)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{set of{sig/Track}}', parent=field/succs, position=1)\", \"(type='Update', node=set of, value=in)\", \"(type='Update', node=var0/Track, value=var1/Track)\", \"(type='Update', node=sig/Junction, value=var2/Track)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{var1/Track}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=field/succs, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=var2/Track, value=var1/Track)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=., value=var2/Track)\", \"(type='Move', tree='{.{var1/Track}{field/succs{set of{sig/Track}}}}', parent=sig/Track, position=0)\", \"(type='Update', node=var2/Track, value=field/succs)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var2/Track, position=0)\", \"(type='Update', node=!=, value=sig/Track)\", \"(type='Move', tree='{!={var1/Track}{var2/Track}}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}', parent=var0/Track, position=0)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":78360900,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Track | (j in Junction) iff (some p1, p2 : Track - j| p1 -> j in succs and p2 -> j in succs) } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.*succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{-{sig/Track}{var0/Track}}}{some{one of{var2}{-{sig/Track}{var0/Track}}}{AND{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"all t : Track | t in Junction iff some disj t1,t2 : Track | t1 in t.(~succs) and t2 in t.(~succs)","sourceExpr":"all j : Track | (j in Junction) iff (some p1, p2 : Track - j| p1 -> j in succs and p2 -> j in succs)","predicate":"inv5","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{AND{in{var1/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}{in{var2/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}}}}","operations":"[\"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Move', tree='{var1/Track}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var2/Track}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{var0/Track}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=-)\", \"(type='Delete', node=->)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a disjoint operator ('disj') to specify that two sets are disjoint. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{AND{in{var1/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}{in{var2/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}}}}","totalTED":12,"challenge":"QxGnrFQnXPGh2Lh8C","time":49162900,"targetExpr":"all t : Track | t in Junction iff some disj t1,t2 : Track | t1 in t.(~succs) and t2 in t.(~succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { all t:Track | t in Junction iff #(Track.succs)>1 } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{sig/Track}{field/succs{set of{sig/Track}}}}}{1}}{in{var0/Track}{sig/Junction}}}}","nextExpr":"all t : Track | t in Junction iff #succs.t>1","sourceExpr":"all t : Track | #Track.succs > 1 iff t in Junction","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{field/succs{set of{sig/Track}}}{var0/Track}}}{1}}{in{var0/Track}{sig/Junction}}}}","operations":"[\"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=sig/Track)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Track to correctly capture the property you want to specify. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{field/succs{set of{sig/Track}}}{var0/Track}}}{1}}{in{var0/Track}{sig/Junction}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":50854800,"targetExpr":"all t : Track | t in Junction iff #succs.t>1","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Junction | some p1:(Track-j), p2:(Track-j) | p1 -> j in succs and p2 -> j in succs } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.*succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Junction}}{some{one of{var1}{-{sig/Track}{var0/Track}}}{some{one of{var2}{-{sig/Track}{var0/Track}}}{AND{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t : Track | t in Junction iff some disj t1,t2 : Track | t1 in t.(~succs) and t2 in t.(~succs)","sourceExpr":"all j : Junction | some p1:(Track-j), p2:(Track-j) | p1 -> j in succs and p2 -> j in succs","predicate":"inv5","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{AND{in{var1/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}{in{var2/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Junction, value=sig/Track)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{-{sig/Track}{var0/Track}}}{some{one of{var2}{-{sig/Track}{var0/Track}}}{AND{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}', parent=<=>, position=1)\", \"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Move', tree='{var1/Track}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var2/Track}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{var0/Track}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=-)\", \"(type='Delete', node=->)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{AND{in{var1/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}{in{var2/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}}}}","totalTED":17,"challenge":"QxGnrFQnXPGh2Lh8C","time":41190100,"targetExpr":"all t : Track | t in Junction iff some disj t1,t2 : Track | t1 in t.(~succs) and t2 in t.(~succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Junction | some succs.j } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.^succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Junction}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}","nextExpr":"Junction = { t : Track | not lone succs.t }","sourceExpr":"all x : Junction | some succs.x","predicate":"inv5","isNewNode":false,"srcDstTED":6,"targetAST":"{={comprehension{one of{var0}{sig/Track}}{!{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}{sig/Junction}}","operations":"[\"(type='Insert', node==, parent=root, position=0)\", \"(type='Update', node=all, value=comprehension)\", \"(type='Move', tree='{all{one of{var0}{sig/Junction}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}', parent==, position=0)\", \"(type='Insert', node=sig/Junction, parent==, position=1)\", \"(type='Insert', node=!, parent=all, position=1)\", \"(type='Update', node=sig/Junction, value=sig/Track)\", \"(type='Update', node=some, value=lone)\", \"(type='Move', tree='{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}', parent=!, position=0)\"]","hint":"Keep going! Consider adding a equal operator ('=') to specify that the left side is equal to the right side. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{={comprehension{one of{var0}{sig/Track}}{!{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}{sig/Junction}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":49983700,"targetExpr":"Junction = { t : Track | not lone succs.t }","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff some succs.t } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","nextExpr":"all t : Track | not lone succs.t iff t in Junction","sourceExpr":"all t : Track | t in Junction <=> some succs.t","predicate":"inv5","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","operations":"[\"(type='Insert', node=!, parent=<=>, position=0)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=1)\", \"(type='Update', node=in, value=lone)\", \"(type='Move', tree='{in{var0/Track}{sig/Junction}}', parent=!, position=0)\", \"(type='Update', node=sig/Junction, value=.)\", \"(type='Update', node=some, value=field/succs)\", \"(type='Move', tree='{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}', parent=sig/Junction, position=0)\", \"(type='Move', tree='{var0/Track}', parent=sig/Junction, position=1)\", \"(type='Update', node=., value=set of)\", \"(type='Update', node=var0/Track, value=sig/Track)\", \"(type='TreeDelete', tree='{field/succs{set of{sig/Track}}}')\"]","hint":"Keep going! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within the equivalence operator ('<=>') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":62812800,"targetExpr":"all t : Track | not lone succs.t iff t in Junction","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1:Track | some t2,t3:Track | t1 in t2.succs and t1 in t3.succs and t1 != t2 iff t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{<=>{AND{!={var0/Track}{var1/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t1:Track | some t2,t3:Track | t1 in t2.succs and t1 in t3.succs and t1 != t2 iff t1 in Junction","predicate":"inv5","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{AND{!={var1/Track}{var0/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}', parent=<=>, position=1)\", \"(type='Update', node=field/succs, value=AND)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=some, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Move', tree='{in{var0/Track}{sig/Junction}}', parent=field/succs, position=0)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{set of{sig/Track}}', parent=field/succs, position=1)\", \"(type='Update', node=set of, value=in)\", \"(type='Update', node=sig/Junction, value=var1/Track)\", \"(type='Insert', node=var2/Track, parent=in, position=2)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{var1/Track}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=field/succs, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=var0/Track, value=var1/Track)\", \"(type='Move', tree='{var0/Track}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=., value=var2/Track)\", \"(type='Move', tree='{.{var1/Track}{field/succs{set of{sig/Track}}}}', parent=sig/Track, position=0)\", \"(type='Update', node=var2/Track, value=field/succs)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var2/Track, position=0)\", \"(type='Update', node=!=, value=sig/Track)\", \"(type='Move', tree='{!={var1/Track}{var0/Track}}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}', parent=var0/Track, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":43620400,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some succs.t and t not in succs.t) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{AND{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{var0/Track}}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","nextExpr":"all t:Track | some succs.t and not one succs.t <=> t in Junction","sourceExpr":"all t : Track | t in Junction iff (some succs.t and t not in succs.t)","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{AND{!{one{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","operations":"[\"(type='Insert', node=!, parent=AND, position=0)\", \"(type='Update', node=!in, value=one)\", \"(type='Move', tree='{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{var0/Track}}}', parent=!, position=0)\", \"(type='Delete', node=var0/Track)\"]","hint":"Near a solution! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{AND{!{one{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":39936100,"targetExpr":"all t:Track | some succs.t and not one succs.t <=> t in Junction","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { all t : Track | t in Junction iff #t.succs>1 } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{var0/Track}{field/succs{set of{sig/Track}}}}}{1}}{in{var0/Track}{sig/Junction}}}}","nextExpr":"all t : Track | t in Junction iff #succs.t>1","sourceExpr":"all t : Track | t in Junction iff #t.succs > 1","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{field/succs{set of{sig/Track}}}{var0/Track}}}{1}}{in{var0/Track}{sig/Junction}}}}","operations":"[\"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=var0/Track)\"]","hint":"Near a solution! You can use variables to help specify the condition. Consider using a variable of type Track to correctly capture the property you want to specify. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{>{#{.{field/succs{set of{sig/Track}}}{var0/Track}}}{1}}{in{var0/Track}{sig/Junction}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":55715400,"targetExpr":"all t : Track | t in Junction iff #succs.t>1","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1,t2,t3:Track | t1 in t2.succs and t1 in t3.succs iff t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{<=>{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t1,t2,t3: Track| (t1 in t2.succs and t1 in t3.succs) <=> t1 in Junction","predicate":"inv5","isNewNode":false,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{AND{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}', parent=<=>, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=field/succs, value=AND)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=all, position=1)\", \"(type='TreeInsert', tree='{!={var1/Track}{var2/Track}}', parent=field/succs, position=0)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{set of{sig/Track}}', parent=field/succs, position=1)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{var0/Track}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=field/succs, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=sig/Junction, value=var1/Track)\", \"(type='Move', tree='{sig/Junction}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=., value=var2/Track)\", \"(type='Move', tree='{.{var1/Track}{field/succs{set of{sig/Track}}}}', parent=sig/Track, position=0)\", \"(type='Update', node=var2/Track, value=field/succs)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var2/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{sig/Junction}}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}', parent=var0/Track, position=0)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":13,"challenge":"QxGnrFQnXPGh2Lh8C","time":72831900,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t:Track | (some p1,p2:Track | p1 != p2 and p1 in t & Track.succs and p2 in t & Track.succs) implies t in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var1/Track}{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{var0/Track}}}{in{var2/Track}{&{.{sig/Track}{field/succs{set of{sig/Track}}}}{var0/Track}}}}}}{in{var0/Track}{sig/Junction}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t:Track | (some p1,p2:Track | p1 != p2 and p1 in t & Track.succs and p2 in t & Track.succs) implies t in Junction","predicate":"inv5","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent==>, position=0)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{.{sig/Track}{field/succs{set of{sig/Track}}}}', parent=in, position=1)\", \"(type='Update', node=var2/Track, value=var0/Track)\", \"(type='Move', tree='{.{sig/Track}{field/succs{set of{sig/Track}}}}', parent=in, position=1)\", \"(type='Update', node=sig/Track, value=var1/Track)\", \"(type='Update', node=sig/Track, value=var2/Track)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=&)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=&)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Junction}}')\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":15,"challenge":"QxGnrFQnXPGh2Lh8C","time":44138900,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Track | (j in Junction) iff (some p1, p2 : Track| p1 -> j in succs and p2 -> j in succs) } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.*succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"all t : Track | t in Junction iff some disj t1,t2 : Track | t1 in t.(~succs) and t2 in t.(~succs)","sourceExpr":"all j : Track | (j in Junction) iff (some p1, p2 : Track| p1 -> j in succs and p2 -> j in succs)","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{AND{in{var1/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}{in{var2/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}}}}","operations":"[\"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Insert', node=disj, parent=some, position=0)\", \"(type='Move', tree='{var1/Track}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var2/Track}', parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{var0/Track}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{var0/Track}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Delete', node=->)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Consider adding a disjoint operator ('disj') to specify that two sets are disjoint. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{disj}{one of{var1}{sig/Track}}{some{disj}{one of{var2}{sig/Track}}{AND{in{var1/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}{in{var2/Track}{.{var0/Track}{~{field/succs{set of{sig/Track}}}}}}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":39223600,"targetExpr":"all t : Track | t in Junction iff some disj t1,t2 : Track | t1 in t.(~succs) and t2 in t.(~succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Junction | some p1:(Track-j), p2:(Track-j) | p1 -> j in succs and p2 -> j in succs and p1 != p2 } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.*succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Junction}}{some{one of{var1}{-{sig/Track}{var0/Track}}}{some{one of{var2}{-{sig/Track}{var0/Track}}}{AND{!={var1/Track}{var2/Track}}{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t->t1 in ~succs and t->t2 in ~succs and t1 != t2","sourceExpr":"all j : Junction | some p1:(Track-j), p2:(Track-j) | p1 -> j in succs and p2 -> j in succs and p1 != p2","predicate":"inv5","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var0/Track}{var1/Track}}{~{field/succs{set of{sig/Track}}}}}{in{->{var0/Track}{var2/Track}}{~{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Junction, value=sig/Track)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{-{sig/Track}{var0/Track}}}{some{one of{var2}{-{sig/Track}{var0/Track}}}{AND{!={var1/Track}{var2/Track}}{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}', parent=<=>, position=1)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Move', tree='{sig/Track}', parent=one of, position=1)\", \"(type='Insert', node=~, parent=in, position=1)\", \"(type='Insert', node=~, parent=in, position=1)\", \"(type='Insert', node=var0/Track, parent=->, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Insert', node=var0/Track, parent=->, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=-)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var0/Track}{var1/Track}}{~{field/succs{set of{sig/Track}}}}}{in{->{var0/Track}{var2/Track}}{~{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":15,"challenge":"QxGnrFQnXPGh2Lh8C","time":40037800,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t->t1 in ~succs and t->t2 in ~succs and t1 != t2","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { } pred inv5 { all t : Track | t in Junction iff some t.succs } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t : Track | t not in Junction iff lone succs.t","sourceExpr":"all t : Track | t in Junction iff some t.succs","predicate":"inv5","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{sig/Junction}}{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=some, value=lone)\", \"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{sig/Junction}}{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":79814300,"targetExpr":"all t : Track | t not in Junction iff lone succs.t","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1,t2,t3:Track | t1 != t2 and t2 != t3 and t1 in t2.succs and t1 in t3.succs iff t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{<=>{AND{!={var0/Track}{var1/Track}}{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t1,t2,t3:Track | t1 != t2 and t2 != t3 and t1 in t2.succs and t1 in t3.succs iff t1 in Junction","predicate":"inv5","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Update', node=all, value=some)\", \"(type='Move', tree='{all{one of{var1}{sig/Track}}{all{one of{var2}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{AND{!={var1/Track}{var0/Track}}{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}', parent=<=>, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=field/succs, value=AND)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=all, position=1)\", \"(type='Move', tree='{!={var1/Track}{var0/Track}}', parent=field/succs, position=0)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{set of{sig/Track}}', parent=field/succs, position=1)\", \"(type='Update', node=set of, value=in)\", \"(type='Update', node=var0/Track, value=var2/Track)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{var1/Track}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=field/succs, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=var2/Track, value=var1/Track)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=., value=var2/Track)\", \"(type='Move', tree='{.{var1/Track}{field/succs{set of{sig/Track}}}}', parent=sig/Track, position=0)\", \"(type='Update', node=var2/Track, value=field/succs)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var2/Track, position=0)\", \"(type='Update', node=!=, value=sig/Track)\", \"(type='Move', tree='{!={var1/Track}{var2/Track}}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}', parent=var0/Track, position=0)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Junction}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":13,"challenge":"QxGnrFQnXPGh2Lh8C","time":36969800,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs iff t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{<=>{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t: Track | some t1, t2: Track | t in t1.succs && t in t2.succs && t1!=t2 <=> t in Junction","predicate":"inv5","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}', parent=<=>, position=1)\", \"(type='Update', node=field/succs, value=AND)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=some, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Move', tree='{in{var0/Track}{sig/Junction}}', parent=field/succs, position=0)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{set of{sig/Track}}', parent=field/succs, position=1)\", \"(type='Update', node=set of, value=in)\", \"(type='Update', node=var0/Track, value=var1/Track)\", \"(type='Update', node=sig/Junction, value=var2/Track)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{var1/Track}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=field/succs, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=var2/Track, value=var1/Track)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=., value=var2/Track)\", \"(type='Move', tree='{.{var1/Track}{field/succs{set of{sig/Track}}}}', parent=sig/Track, position=0)\", \"(type='Update', node=var2/Track, value=field/succs)\", \"(type='Move', tree='{var2/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var2/Track, position=0)\", \"(type='Update', node=!=, value=sig/Track)\", \"(type='Move', tree='{!={var1/Track}{var2/Track}}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}', parent=var0/Track, position=0)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":57637200,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { all t:Track | t in Junction iff t in Track.succs } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{in{var0/Track}{.{sig/Track}{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t : Track | t not in Junction iff lone succs.t","sourceExpr":"all t: Track | t in Junction <=> t in Track.succs","predicate":"inv5","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{sig/Junction}}{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=in, value=lone)\", \"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=sig/Track)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{sig/Junction}}{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":68299700,"targetExpr":"all t : Track | t not in Junction iff lone succs.t","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { all t1:Track | some t2,t3:Track | t1 in t2.succs and t1 in t2.succs and t1 != t2 iff t1 in Junction } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{<=>{AND{!={var0/Track}{var1/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}}{in{var0/Track}{sig/Junction}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","sourceExpr":"all t1:Track | some t2,t3:Track | t1 in t2.succs and t1 in t2.succs and t1 != t2 iff t1 in Junction","predicate":"inv5","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{AND{!={var1/Track}{var0/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}}}}}', parent=<=>, position=1)\", \"(type='Update', node=field/succs, value=AND)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=some, position=1)\", \"(type='Update', node=in, value=!=)\", \"(type='Move', tree='{in{var0/Track}{sig/Junction}}', parent=field/succs, position=0)\", \"(type='Update', node=set of, value=in)\", \"(type='Move', tree='{set of{sig/Track}}', parent=field/succs, position=1)\", \"(type='Update', node=set of, value=in)\", \"(type='Update', node=sig/Junction, value=var1/Track)\", \"(type='Insert', node=var2/Track, parent=in, position=2)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Move', tree='{var1/Track}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=field/succs, value=var0/Track)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=set of, position=0)\", \"(type='Update', node=sig/Track, value=.)\", \"(type='Update', node=var0/Track, value=var1/Track)\", \"(type='Move', tree='{var0/Track}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=., value=var2/Track)\", \"(type='Move', tree='{.{var1/Track}{field/succs{set of{sig/Track}}}}', parent=sig/Track, position=0)\", \"(type='Update', node=var1/Track, value=field/succs)\", \"(type='Move', tree='{var1/Track}', parent=sig/Track, position=1)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=var0/Track, value=set of)\", \"(type='Move', tree='{var0/Track}', parent=var1/Track, position=0)\", \"(type='Update', node=!=, value=sig/Track)\", \"(type='Move', tree='{!={var1/Track}{var0/Track}}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Track)\", \"(type='Move', tree='{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}', parent=var0/Track, position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=.)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\", \"(type='Delete', node=<=>)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{var0/Track}{.{var1/Track}{field/succs{set of{sig/Track}}}}}{in{var0/Track}{.{var2/Track}{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":11,"challenge":"QxGnrFQnXPGh2Lh8C","time":42910100,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t1!=t2 and t in t1.succs and t in t2.succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { all t:Track | t in Junction implies #Track.succs>1 } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Junction}}{>{#{.{sig/Track}{field/succs{set of{sig/Track}}}}}{1}}}}","nextExpr":"all t : Track | t not in Junction iff lone succs.t","sourceExpr":"all t:Track | t in Junction implies #Track.succs>1","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{sig/Junction}}{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","operations":"[\"(type='Update', node==>, value=<=>)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=#, value=lone)\", \"(type='Move', tree='{#{.{sig/Track}{field/succs{set of{sig/Track}}}}}', parent==>, position=1)\", \"(type='Insert', node=var0/Track, parent=., position=2)\", \"(type='Delete', node=sig/Track)\", \"(type='Delete', node=1)\", \"(type='Delete', node=>)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{!in{var0/Track}{sig/Junction}}{lone{.{field/succs{set of{sig/Track}}}{var0/Track}}}}}","totalTED":7,"challenge":"QxGnrFQnXPGh2Lh8C","time":37022400,"targetExpr":"all t : Track | t not in Junction iff lone succs.t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all j : Junction | some p1, p2 : Track | p1 -> j in succs and p2 -> j in succs and p1 != p2 and j != p1 and j != p2 } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.*succs } pred inv8 { all e:Entry, x:Exit | x in e.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{!={var0/Track}{var1/Track}}{!={var0/Track}{var2/Track}}{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all t:Track | t in Junction iff some t1,t2:Track | t->t1 in ~succs and t->t2 in ~succs and t1 != t2","sourceExpr":"all j : Junction | some p1, p2 : Track | p1 -> j in succs and p2 -> j in succs and p1 != p2 and j != p1 and j != p2","predicate":"inv5","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var0/Track}{var1/Track}}{~{field/succs{set of{sig/Track}}}}}{in{->{var0/Track}{var2/Track}}{~{field/succs{set of{sig/Track}}}}}}}}}}","operations":"[\"(type='Insert', node=<=>, parent=all, position=1)\", \"(type='Update', node=sig/Junction, value=sig/Track)\", \"(type='TreeInsert', tree='{in{var0/Track}{sig/Junction}}', parent=<=>, position=0)\", \"(type='Move', tree='{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{!={var1/Track}{var0/Track}}{!={var0/Track}{var2/Track}}{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}{in{->{var2/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}}}}', parent=<=>, position=1)\", \"(type='Insert', node=in, parent=AND, position=1)\", \"(type='Update', node=!=, value=->)\", \"(type='Move', tree='{!={var1/Track}{var0/Track}}', parent=in, position=0)\", \"(type='Update', node=in, value=~)\", \"(type='Move', tree='{in{->{var1/Track}{var0/Track}}{field/succs{set of{sig/Track}}}}', parent=in, position=1)\", \"(type='Insert', node=~, parent=in, position=1)\", \"(type='Update', node=var1/Track, value=var0/Track)\", \"(type='Update', node=var0/Track, value=var1/Track)\", \"(type='Insert', node=var0/Track, parent=->, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=~, position=0)\", \"(type='TreeDelete', tree='{->{var1/Track}{var0/Track}}')\", \"(type='TreeDelete', tree='{!={var0/Track}{var2/Track}}')\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Consider adding a equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Junction}}{some{one of{var1}{sig/Track}}{some{one of{var2}{sig/Track}}{AND{!={var1/Track}{var2/Track}}{in{->{var0/Track}{var1/Track}}{~{field/succs{set of{sig/Track}}}}}{in{->{var0/Track}{var2/Track}}{~{field/succs{set of{sig/Track}}}}}}}}}}","totalTED":17,"challenge":"QxGnrFQnXPGh2Lh8C","time":37065300,"targetExpr":"all t:Track | t in Junction iff some t1,t2:Track | t->t1 in ~succs and t->t2 in ~succs and t1 != t2","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some succs.t and t not in ^succs.t) } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{AND{!in{var0/Track}{.{^{field/succs{set of{sig/Track}}}}{var0/Track}}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","nextExpr":"all t:Track | some succs.t and not one succs.t <=> t in Junction","sourceExpr":"all t : Track | t in Junction iff (some succs.t and t not in ^succs.t)","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{<=>{AND{!{one{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","operations":"[\"(type='Insert', node=!, parent=AND, position=0)\", \"(type='Update', node=!in, value=one)\", \"(type='Move', tree='{!in{var0/Track}{.{^{field/succs{set of{sig/Track}}}}{var0/Track}}}', parent=!, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=0)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within the conjunction operator ('and') expression.","nextAST":"{all{one of{var0}{sig/Track}}{<=>{AND{!{one{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{some{.{field/succs{set of{sig/Track}}}{var0/Track}}}}{in{var0/Track}{sig/Junction}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":37131800,"targetExpr":"all t:Track | some succs.t and not one succs.t <=> t in Junction","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { } pred inv6 { some Entry.signals & Speed } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{&{.{sig/Entry}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"some (Speed & Entry.signals)","predicate":"inv6","isNewNode":false,"srcDstTED":4,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{.{sig/Entry}{field/signals{set of{sig/Signal}}}}{sig/Speed}}', parent=root, position=0)\", \"(type='Move', tree='{sig/Entry}', parent=&, position=0)\", \"(type='Insert', node=., parent=&, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Speed}', parent=., position=1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using intersection operator ('&') to find the common elements between two sets, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":116897100,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { } pred inv6 { signals.Speed = Entry } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={.{field/signals{set of{sig/Signal}}}{sig/Speed}}{sig/Entry}}","nextExpr":"Entry in signals.Speed","sourceExpr":"Entry = signals.Speed","predicate":"inv6","isNewNode":false,"srcDstTED":3,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=sig/Entry, parent==, position=0)\", \"(type='Delete', node=sig/Entry)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":50800000,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { signals in Entry one -> some Signal } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/signals{set of{sig/Signal}}}{one->some{sig/Entry}{sig/Signal}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"signals in Entry one -> some Signal","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Insert', node=sig/Entry, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Update', node=sig/Entry, value=sig/Speed)\", \"(type='Move', tree='{sig/Entry}', parent=., position=1)\", \"(type='Delete', node=sig/Signal)\", \"(type='Delete', node=one->some)\"]","hint":"Keep going! Consider adding a signature of type Entry to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":106436200,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track | t in Entry implies Speed in t.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{in{sig/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t: Track | t in Entry implies some Speed&t.signals","sourceExpr":"all t : Track | t in Entry implies Speed in t.signals","predicate":"inv6","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{sig/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}', parent=some, position=0)\", \"(type='Insert', node=sig/Speed, parent=in, position=2)\", \"(type='Delete', node=sig/Speed)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":76863200,"targetExpr":"all t: Track | t in Entry implies some Speed&t.signals","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { signals in Entry-> one Speed } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/signals{set of{sig/Signal}}}{->one{sig/Entry}{sig/Speed}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"signals in Entry -> one Speed","predicate":"inv6","isNewNode":false,"srcDstTED":4,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Insert', node=sig/Entry, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Speed}', parent=., position=1)\", \"(type='Delete', node=sig/Entry)\", \"(type='Delete', node=->one)\"]","hint":"Keep going! Consider adding a signature of type Entry to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":44607400,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { Junction in Track.*succs } pred inv6 { signals in Entry -> some Speed } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/signals{set of{sig/Signal}}}{->some{sig/Entry}{sig/Speed}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"signals in Entry -> some Speed","predicate":"inv6","isNewNode":false,"srcDstTED":4,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Insert', node=sig/Entry, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Speed}', parent=., position=1)\", \"(type='Delete', node=sig/Entry)\", \"(type='Delete', node=->some)\"]","hint":"Keep going! Consider adding a signature of type Entry to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":58782600,"targetExpr":"Entry in signals.Speed","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit <=> no t.^(succs) } pred inv4 { all t:Track | t in Entry <=> t not in Track.^(succs) } pred inv5 { all t:Track | t in Junction <=> #succs.t>1 } pred inv6 { all e:Entry | one s:Speed | s in e.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{one{one of{var1}{sig/Speed}}{in{var1/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all e:Entry | some s:Speed | s in e.signals","sourceExpr":"all e : Entry | one s : Speed | s in e.signals","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Speed}}{in{var1/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","operations":"[\"(type='Update', node=one, value=some)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Entry}}{some{one of{var1}{sig/Speed}}{in{var1/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":41561500,"targetExpr":"all e:Entry | some s:Speed | s in e.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { all e:Entry | Speed in e.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{in{sig/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}","nextExpr":"all e : Entry | some (Speed & e.signals)","sourceExpr":"all e: Entry | Speed in e.signals","predicate":"inv6","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}","operations":"[\"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{sig/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}', parent=some, position=0)\", \"(type='Insert', node=sig/Speed, parent=in, position=2)\", \"(type='Delete', node=sig/Speed)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":42943000,"targetExpr":"all e : Entry | some (Speed & e.signals)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track | t in Entry implies some t.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t: Track | t in Entry implies some Speed&t.signals","sourceExpr":"all t:Track| t in Entry => some t.signals","predicate":"inv6","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","operations":"[\"(type='Insert', node=&, parent=some, position=0)\", \"(type='Move', tree='{.{var0/Track}{field/signals{set of{sig/Signal}}}}', parent=&, position=0)\", \"(type='Insert', node=sig/Speed, parent=&, position=1)\"]","hint":"Near a solution! Consider adding a intersection operator ('&') to find the common elements between two sets. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":38379500,"targetExpr":"all t: Track | t in Entry implies some Speed&t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { Junction in Track.*succs } pred inv6 { all t:Track, s:Signal | t->s in signals and t=Entry implies Speed in s } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Signal}}{=>{AND{={sig/Entry}{var0/Track}}{in{->{var0/Track}{var1/Signal}}{field/signals{set of{sig/Signal}}}}}{in{sig/Speed}{var1/Signal}}}}}","nextExpr":"all x:Track|some y:Signal| x in Entry implies x->y in signals and y in Speed","sourceExpr":"all t:Track, s:Signal | t->s in signals and t=Entry implies Speed in s","predicate":"inv6","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Signal}}{=>{in{var0/Track}{sig/Entry}}{AND{in{->{var0/Track}{var1/Signal}}{field/signals{set of{sig/Signal}}}}{in{var1/Signal}{sig/Speed}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=->, value=in)\", \"(type='Move', tree='{->{var0/Track}{var1/Signal}}', parent==>, position=0)\", \"(type='Insert', node=AND, parent==>, position=1)\", \"(type='Insert', node=var0/Track, parent=->, position=0)\", \"(type='Update', node=var0/Track, value=sig/Entry)\", \"(type='Update', node==, value=in)\", \"(type='Move', tree='{={sig/Entry}{var0/Track}}', parent=AND, position=0)\", \"(type='Move', tree='{in{sig/Speed}{var1/Signal}}', parent=AND, position=1)\", \"(type='Update', node=field/signals, value=->)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent==, position=0)\", \"(type='Update', node=var0/Track, value=field/signals)\", \"(type='Insert', node=var1/Signal, parent=in, position=0)\", \"(type='Update', node=sig/Signal, value=var0/Track)\", \"(type='Move', tree='{sig/Signal}', parent=field/signals, position=0)\", \"(type='Update', node=set of, value=var1/Signal)\", \"(type='Update', node=sig/Entry, value=set of)\", \"(type='Move', tree='{sig/Entry}', parent=var0/Track, position=0)\", \"(type='Update', node=in, value=sig/Signal)\", \"(type='Move', tree='{in{->{var0/Track}{var1/Signal}}{field/signals{set of{sig/Signal}}}}', parent=sig/Entry, position=0)\", \"(type='Delete', node=var1/Signal)\", \"(type='Delete', node=var1/Signal)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Track}}{some{one of{var1}{sig/Signal}}{=>{in{var0/Track}{sig/Entry}}{AND{in{->{var0/Track}{var1/Signal}}{field/signals{set of{sig/Signal}}}}{in{var1/Signal}{sig/Speed}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":65933300,"targetExpr":"all x:Track|some y:Signal| x in Entry implies x->y in signals and y in Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track | t in Entry iff some t.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{in{var0/Track}{sig/Entry}}{some{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t:Track| t in Entry => some t.signals","sourceExpr":"all t : Track | t in Entry <=> some t.signals","predicate":"inv6","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":39363400,"targetExpr":"all t: Track | t in Entry implies some Speed&t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e: Entry| some t: Exit| e in Track and t in Track } pred inv2 { all s: Signal| one signals.s } pred inv3 { all t: Track| no t.succs <=> t in Exit } pred inv4 { all t: Track| no succs.t <=> t in Entry } pred inv5 { all t: Track| #succs.t>1 <=> t in Junction } pred inv6 { all e: Entry| some e.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{some{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}","nextExpr":"all e : Entry | some (Speed & e.signals)","sourceExpr":"all e:Entry | some e.signals","predicate":"inv6","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}","operations":"[\"(type='Insert', node=&, parent=some, position=0)\", \"(type='Move', tree='{.{var0/Track}{field/signals{set of{sig/Signal}}}}', parent=&, position=0)\", \"(type='Insert', node=sig/Speed, parent=&, position=1)\"]","hint":"Near a solution! Consider adding a intersection operator ('&') to find the common elements between two sets. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}","totalTED":2,"challenge":"QxGnrFQnXPGh2Lh8C","time":46442400,"targetExpr":"all e : Entry | some (Speed & e.signals)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { signals in Entry one -> one Signal } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/signals{set of{sig/Signal}}}{one->one{sig/Entry}{sig/Signal}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"signals in Entry one -> one Signal","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Insert', node=sig/Entry, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Update', node=sig/Entry, value=sig/Speed)\", \"(type='Move', tree='{sig/Entry}', parent=., position=1)\", \"(type='Delete', node=sig/Signal)\", \"(type='Delete', node=one->one)\"]","hint":"Keep going! Consider adding a signature of type Entry to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":32870300,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { signals in Entry-> one Signal } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/signals{set of{sig/Signal}}}{->one{sig/Entry}{sig/Signal}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"signals in Entry-> one Signal","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Insert', node=sig/Entry, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Update', node=sig/Entry, value=sig/Speed)\", \"(type='Move', tree='{sig/Entry}', parent=., position=1)\", \"(type='Delete', node=sig/Signal)\", \"(type='Delete', node=->one)\"]","hint":"Keep going! Consider adding a signature of type Entry to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":33662600,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some en:Entry, ex:Exit | en in Track and ex in Track } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track |t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { some t:Track | t in Entry implies Speed in t.signals } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{in{sig/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t: Track | t in Entry implies some Speed&t.signals","sourceExpr":"some t:Track | t in Entry implies Speed in t.signals","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{sig/Speed}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}', parent=some, position=0)\", \"(type='Insert', node=sig/Speed, parent=in, position=2)\", \"(type='Delete', node=sig/Speed)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{some{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Speed}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":33721200,"targetExpr":"all t: Track | t in Entry implies some Speed&t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { Junction in Track.*succs } pred inv6 { signals in Entry -> some Signal } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/signals{set of{sig/Signal}}}{->some{sig/Entry}{sig/Signal}}}","nextExpr":"Entry in signals.Speed","sourceExpr":"signals in Entry -> some Signal","predicate":"inv6","isNewNode":true,"srcDstTED":5,"targetAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","operations":"[\"(type='Insert', node=sig/Entry, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Update', node=sig/Entry, value=sig/Speed)\", \"(type='Move', tree='{sig/Entry}', parent=., position=1)\", \"(type='Delete', node=sig/Signal)\", \"(type='Delete', node=->some)\"]","hint":"Keep going! Consider adding a signature of type Entry to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Entry}{.{field/signals{set of{sig/Signal}}}{sig/Speed}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":31555700,"targetExpr":"Entry in signals.Speed","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e: Entry| some t: Exit| e in Track and t in Track } pred inv2 { all s: Signal| one signals.s } pred inv3 { all t: Track| no t.succs <=> t in Exit } pred inv4 { all t: Track| no succs.t <=> t in Entry } pred inv5 { all t: Track| #succs.t>1 <=> t in Junction } pred inv6 { all e: Entry| some s: Speed| s in e.signals } pred inv7 { all t: Track| t not in t.succs } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}","nextExpr":"all t:Track | t not in t.^(succs)","sourceExpr":"all t:Track | t not in t.succs","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":86029900,"targetExpr":"all t:Track | t not in t.^(succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { all t:Track | t in t.^succs } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all t:Track | t not in t.^(succs)","sourceExpr":"all t: Track | t in t.^(succs)","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node=in, value=!in)\"]","hint":"One step away from the solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":41719900,"targetExpr":"all t:Track | t not in t.^(succs)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e: Entry| some t: Exit| e in Track and t in Track } pred inv2 { all s: Signal| one signals.s } pred inv3 { all t: Track| no t.succs <=> t in Exit } pred inv4 { all t: Track| no succs.t <=> t in Entry } pred inv5 { all t: Track| #succs.t>1 <=> t in Junction } pred inv6 { all e: Entry| some s: Speed| s in e.signals } pred inv7 { all t: Track| t not in succs.t } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{var0/Track}}}}","nextExpr":"all t : Track | t not in ^succs.t","sourceExpr":"all t : Track | t not in succs.t","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{^{field/succs{set of{sig/Track}}}}{var0/Track}}}}","operations":"[\"(type='Insert', node=^, parent=., position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=^, position=0)\"]","hint":"One step away from the solution! Consider adding a transitive closure operator ('^') to get the transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.","nextAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{^{field/succs{set of{sig/Track}}}}{var0/Track}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":91124700,"targetExpr":"all t : Track | t not in ^succs.t","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track|some s:Speed | t in Entry implies (s in t.signals) } pred inv7 { all t:Track | t in Entry implies t not in Exit } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{!in{var0/Track}{sig/Exit}}}}","nextExpr":"all t:Track | t not in t.^(succs)","sourceExpr":"all t:Track | t in Entry implies t not in Exit","predicate":"inv7","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node==>, value=!in)\", \"(type='Move', tree='{var0/Track}', parent==>, position=0)\", \"(type='Update', node=!in, value=.)\", \"(type='Insert', node=^, parent=!in, position=1)\", \"(type='Insert', node=field/succs, parent=^, position=0)\", \"(type='Insert', node=set of, parent=field/succs, position=0)\", \"(type='Update', node=sig/Exit, value=sig/Track)\", \"(type='Move', tree='{sig/Exit}', parent=set of, position=0)\", \"(type='Delete', node=sig/Entry)\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{!in{var0/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":67885300,"targetExpr":"all t:Track | t not in t.^(succs)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { all t : Track | t in Exit iff no t.succs } pred inv4 { all t : Track | t in Entry iff no succs.t } pred inv5 { all t : Track | t in Junction iff (some t2:Track | succs in t2 -> t and t != t2) } pred inv6 { all e:Entry | some s: Speed | s in e.signals } pred inv7 { all t : Track | t not in t.^succs } pred inv8 { all e:Entry, x:Exit | x in e.^succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}","nextExpr":"all et : Entry, ex : Exit | ex in et.*succs","sourceExpr":"all e: Entry | all x: Exit | x in e.^succs","predicate":"inv8","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{in{var1/Track}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}","operations":"[\"(type='Update', node=^, value=*)\"]","hint":"One step away from the solution! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.","nextAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{in{var1/Track}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":123720800,"targetExpr":"all et : Entry, ex : Exit | ex in et.*succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all e:Entry | Exit in e.^succs } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Entry}}{in{sig/Exit}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}","nextExpr":"all e : Entry | Exit in e.*succs","sourceExpr":"all e:Entry | Exit in e.^succs","predicate":"inv8","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Entry}}{in{sig/Exit}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Update', node=^, value=*)\"]","hint":"One step away from the solution! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.","nextAST":"{all{one of{var0}{sig/Entry}}{in{sig/Exit}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":54762200,"targetExpr":"all e : Entry | Exit in e.*succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { } pred inv6 { Entry in signals.Speed } pred inv7 { } pred inv8 { Exit in Entry.succs } pred inv9 { } pred inv10 { }","sourceAST":"{in{sig/Exit}{.{sig/Entry}{field/succs{set of{sig/Track}}}}}","nextExpr":"Entry -> Exit in *succs","sourceExpr":"Exit in Entry.succs","predicate":"inv8","isNewNode":true,"srcDstTED":4,"targetAST":"{in{->{sig/Entry}{sig/Exit}}{*{field/succs{set of{sig/Track}}}}}","operations":"[\"(type='Insert', node=->, parent=in, position=0)\", \"(type='Update', node=., value=*)\", \"(type='Insert', node=sig/Entry, parent=->, position=0)\", \"(type='Move', tree='{sig/Exit}', parent=->, position=1)\", \"(type='Delete', node=sig/Entry)\"]","hint":"Keep going! Consider adding a arrow operator ('->') to map a relation. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{->{sig/Entry}{sig/Exit}}{*{field/succs{set of{sig/Track}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":119624400,"targetExpr":"Entry -> Exit in *succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { signals in Track one -> Signal } pred inv3 { all t:Track | no t.succs iff t in Exit } pred inv4 { all t:Track | no t & Track.succs iff t in Entry } pred inv5 { } pred inv6 { Entry in signals.Speed } pred inv7 { } pred inv8 { Exit in Entry.*succs } pred inv9 { } pred inv10 { }","sourceAST":"{in{sig/Exit}{.{sig/Entry}{*{field/succs{set of{sig/Track}}}}}}","nextExpr":"all e:Entry | Exit in e.*succs","sourceExpr":"Exit in Entry.*(succs)","predicate":"inv8","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Entry}}{in{sig/Exit}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Entry}}', parent=all, position=0)\", \"(type='Move', tree='{in{sig/Exit}{.{sig/Entry}{*{field/succs{set of{sig/Track}}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Entry, value=var0/Track)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Entry\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Entry}}{in{sig/Exit}{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":48068900,"targetExpr":"all e:Entry | Exit in e.*succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track|some s:Speed | t in Entry implies (s in t.signals) } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all t:Track | t in Entry implies (all t1:Track | t1 in Exit implies t1 in t.succs) } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{all{one of{var1}{sig/Track}}{=>{in{var1/Track}{sig/Exit}}{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}}}","nextExpr":"all e: Entry , ex : Exit | e != ex => ex in e.^succs","sourceExpr":"all t:Track | t in Entry implies (all t1:Track | t1 in Exit implies t1 in t.succs)","predicate":"inv8","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{=>{!={var0/Track}{var1/Track}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var1}{sig/Track}}{=>{in{var1/Track}{sig/Exit}}{in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Track, value=sig/Entry)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Update', node=in, value=!=)\", \"(type='Insert', node=var0/Track, parent=in, position=0)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=^, position=0)\", \"(type='Delete', node=sig/Exit)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Entry}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{=>{!={var0/Track}{var1/Track}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":39931900,"targetExpr":"all e: Entry , ex : Exit | e != ex => ex in e.^succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track|some s:Speed | t in Entry implies (s in t.signals) } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all t:Track | t in Entry implies (all t1:Track | t1 in Exit implies t1 in t.^succs) } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{sig/Entry}}{all{one of{var1}{sig/Track}}{=>{in{var1/Track}{sig/Exit}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}}}","nextExpr":"all ent : Entry | all ext : Exit | ext != ent implies ext in ent.^succs","sourceExpr":"all t:Track | t in Entry implies (all t1:Track | t1 in Exit implies t1 in t.^succs)","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{=>{!={var0/Track}{var1/Track}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var1}{sig/Track}}{=>{in{var1/Track}{sig/Exit}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Track, value=sig/Entry)\", \"(type='Update', node=sig/Track, value=sig/Exit)\", \"(type='Update', node=in, value=!=)\", \"(type='Insert', node=var0/Track, parent=in, position=0)\", \"(type='Delete', node=sig/Exit)\", \"(type='TreeDelete', tree='{in{var0/Track}{sig/Entry}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Entry}}{all{one of{var1}{sig/Exit}}{=>{!={var0/Track}{var1/Track}}{in{var1/Track}{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}}}}}","totalTED":9,"challenge":"QxGnrFQnXPGh2Lh8C","time":35494500,"targetExpr":"all ent : Entry | all ext : Exit | ext != ent implies ext in ent.^succs","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t : Track | (t.^succs not in Junction) => (t.signals not in Semaphore) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{!in{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | (no t.succs & Junction) implies no (t.signals & Semaphore)","sourceExpr":"all t : Track | (t.^succs not in Junction) => (t.signals not in Semaphore)","predicate":"inv9","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=no, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}{sig/Junction}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=no, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":118190300,"targetExpr":"all t : Track | (no t.succs & Junction) implies no (t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all e:Entry | Exit in e.*succs } pred inv9 { all t:Track | Junction not in t.succs iff Semaphore not in t.signals } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{sig/Junction}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{!in{sig/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","sourceExpr":"all t:Track | Junction not in t.succs iff Semaphore not in t.signals","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Update', node=sig/Junction, value=var0/Track)\", \"(type='Update', node=sig/Semaphore, value=var0/Track)\", \"(type='Insert', node=sig/Junction, parent=., position=2)\", \"(type='Insert', node=sig/Semaphore, parent=., position=2)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":7,"challenge":"QxGnrFQnXPGh2Lh8C","time":34085600,"targetExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all e:Entry | Exit in e.*succs } pred inv9 { all t:Track | Junction not in t.succs implies Semaphore not in t.signals } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{!in{sig/Junction}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{!in{sig/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t : Track | no (Junction & t.succs) => no (Semaphore & t.signals)","sourceExpr":"all t1:Track | Junction not in t1.succs implies Semaphore not in (t1.signals)","predicate":"inv9","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=no, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{sig/Junction}{.{var0/Track}{field/succs{set of{sig/Track}}}}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{sig/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}', parent=no, position=0)\", \"(type='Insert', node=sig/Junction, parent=!in, position=2)\", \"(type='Insert', node=sig/Semaphore, parent=!in, position=2)\", \"(type='Delete', node=sig/Junction)\", \"(type='Delete', node=sig/Semaphore)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":93804500,"targetExpr":"all t : Track | no (Junction & t.succs) => no (Semaphore & t.signals)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t : Track | (t.succs not in Junction) => (t.signals not in Semaphore) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{!in{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | all s : Semaphore | (t.succs not in Junction) implies (s not in t.signals)","sourceExpr":"all t : Track | t.succs not in Junction => t.signals not in Semaphore","predicate":"inv9","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Semaphore}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{!in{var1/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Semaphore}}', parent=all, position=0)\", \"(type='Move', tree='{=>{!in{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}', parent=all, position=1)\", \"(type='Insert', node=var1/Semaphore, parent=!in, position=0)\", \"(type='Delete', node=sig/Semaphore)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Semaphore\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Semaphore}}{=>{!in{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}{!in{var1/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}","totalTED":8,"challenge":"QxGnrFQnXPGh2Lh8C","time":53834900,"targetExpr":"all t: Track, s:Semaphore | no t.succs & Junction => s not in t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t: Track | t in Junction.succs implies t not in signals.Semaphore } pred inv10 { all t: Track | t in succs.Junction implies t in signals.Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{sig/Junction}{field/succs{set of{sig/Track}}}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","nextExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","sourceExpr":"all t: Track | t in Junction.succs implies t not in signals.Semaphore","predicate":"inv9","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Insert', node=sig/Junction, parent=., position=2)\", \"(type='Delete', node=sig/Junction)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":3,"challenge":"QxGnrFQnXPGh2Lh8C","time":38375500,"targetExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t : Track | (t.^succs not in Junction) <=> (t.signals not in Semaphore) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | (no t.succs & Junction) implies no (t.signals & Semaphore)","sourceExpr":"all t : Track | (t.^succs not in Junction) <=> (t.signals not in Semaphore)","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=no, parent=<=>, position=0)\", \"(type='Insert', node=no, parent=<=>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{^{field/succs{set of{sig/Track}}}}}{sig/Junction}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=no, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=^)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":35075700,"targetExpr":"all t : Track | (no t.succs & Junction) implies no (t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all e:Entry | Exit in e.*succs } pred inv9 { all t:Track | Junction in t.succs implies Semaphore not in t.signals } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{sig/Junction}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{!in{sig/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}","nextExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","sourceExpr":"all t:Track | Junction in t.succs implies Semaphore not in t.signals","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Junction, value=var0/Track)\", \"(type='Update', node=sig/Semaphore, value=var0/Track)\", \"(type='Insert', node=sig/Junction, parent=., position=2)\", \"(type='Insert', node=sig/Semaphore, parent=., position=2)\", \"(type='Delete', node=var0/Track)\", \"(type='Delete', node=var0/Track)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":7,"challenge":"QxGnrFQnXPGh2Lh8C","time":40737500,"targetExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t: Track | t in succs.Junction implies t not in signals.Semaphore } pred inv10 { all t: Track | t in succs.Junction implies t in signals.Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","nextExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","sourceExpr":"all t: Track | t in succs.Junction implies t not in signals.Semaphore","predicate":"inv9","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=in, value=!in)\"]","hint":"One step away from the solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":1,"challenge":"QxGnrFQnXPGh2Lh8C","time":35161600,"targetExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry and some Exit } pred inv2 { all s:Signal | one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit <=> no t.^(succs) } pred inv4 { all t:Track | t in Entry <=> t not in Track.^(succs) } pred inv5 { all t:Track | t in Junction <=> #succs.t>1 } pred inv6 { all e:Entry | some s:Speed | s in e.signals } pred inv7 { all t:Track | t not in t.^(succs) } pred inv8 { all t1,t2:Track | t1 in Entry and t2 in Exit and t1!=t2 implies t2 in t1.^(succs) } pred inv9 { all t:Track, j:Junction, s:Semaphore | j not in t.succs implies s not in t.signals } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Junction}}{all{one of{var2}{sig/Semaphore}}{=>{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{!in{var2/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}}","nextExpr":"all t: Track, s:Semaphore | no t.succs & Junction => s not in t.signals","sourceExpr":"all t:Track, j:Junction, s:Semaphore | j not in t.succs implies s not in t.signals","predicate":"inv9","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Semaphore}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{!in{var1/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var2}{sig/Semaphore}}{=>{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}{!in{var2/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}', parent=all, position=1)\", \"(type='Update', node=var2, value=var1)\", \"(type='Insert', node=no, parent==>, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{var1/Track}{.{var0/Track}{field/succs{set of{sig/Track}}}}}', parent=no, position=0)\", \"(type='Update', node=var2/Semaphore, value=var1/Semaphore)\", \"(type='Insert', node=sig/Junction, parent=!in, position=2)\", \"(type='Delete', node=var1/Track)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Junction}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Semaphore}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{!in{var1/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}","totalTED":10,"challenge":"QxGnrFQnXPGh2Lh8C","time":48405000,"targetExpr":"all t: Track, s:Semaphore | no t.succs & Junction => s not in t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t : Track | (t.*succs not in Junction) <=> (t.signals not in Semaphore) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | (no t.succs & Junction) implies no (t.signals & Semaphore)","sourceExpr":"all t : Track | (t.*succs not in Junction) <=> (t.signals not in Semaphore)","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=no, parent=<=>, position=0)\", \"(type='Insert', node=no, parent=<=>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}{sig/Junction}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=no, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":34191100,"targetExpr":"all t : Track | (no t.succs & Junction) implies no (t.signals & Semaphore)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t: Track | t in Junction.*succs implies t not in signals.Semaphore } pred inv10 { all t: Track | t in succs.Junction implies t in signals.Semaphore }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{in{var0/Track}{.{sig/Junction}{*{field/succs{set of{sig/Track}}}}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","nextExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","sourceExpr":"all t: Track | t in Junction.*succs implies t not in signals.Semaphore","predicate":"inv9","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=0)\", \"(type='Insert', node=sig/Junction, parent=., position=1)\", \"(type='Delete', node=sig/Junction)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":4,"challenge":"QxGnrFQnXPGh2Lh8C","time":33023100,"targetExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t : Track | (succs.t not in Junction) <=> (t.signals not in Semaphore) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{.{field/succs{set of{sig/Track}}}{var0/Track}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","sourceExpr":"all t : Track | (succs.t not in Junction) <=> (t.signals not in Semaphore)","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=var0/Track, parent=!in, position=0)\", \"(type='Move', tree='{var0/Track}', parent=!in, position=0)\", \"(type='Insert', node=., parent=!in, position=1)\", \"(type='Update', node=var0/Track, value=sig/Junction)\", \"(type='Move', tree='{field/signals{set of{sig/Signal}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Semaphore}', parent=., position=1)\", \"(type='Delete', node=sig/Junction)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{!in{var0/Track}{.{field/succs{set of{sig/Track}}}{sig/Junction}}}{!in{var0/Track}{.{field/signals{set of{sig/Signal}}}{sig/Semaphore}}}}}","totalTED":6,"challenge":"QxGnrFQnXPGh2Lh8C","time":46837300,"targetExpr":"all t : Track | t not in succs.Junction implies t not in signals.Semaphore","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some Entry one Exit } pred inv2 { signals in Track one -> Signal } pred inv3 { no Exit.succs } pred inv4 { Track in Entry.*succs } pred inv5 { all t:Track | some t1, t2: Track | t1!=t2 and t in t1.succs and t in t2.succs implies t in Junction } pred inv6 { Entry in signals.Speed } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all e:Entry | Exit in e.*succs } pred inv9 { all t:Track | t.succs not in Junction iff t.signals not in Semaphore } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{<=>{!in{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | no (Junction & t.succs) => no (Semaphore & t.signals)","sourceExpr":"all t:Track | t.succs not in Junction iff t.signals not in Semaphore","predicate":"inv9","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Insert', node=no, parent=<=>, position=0)\", \"(type='Insert', node=no, parent=<=>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=no, position=0)\"]","hint":"Keep going! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":40890600,"targetExpr":"all t : Track | no (Junction & t.succs) => no (Semaphore & t.signals)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { some e:Entry,ex:Exit | e in Track and ex in Track } pred inv2 { all s:Signal|one t:Track | s in t.signals } pred inv3 { all t:Track | t in Exit iff no t.succs } pred inv4 { all t:Track | t in Entry iff t not in Track.succs } pred inv5 { } pred inv6 { all t:Track|some s:Speed | t in Entry implies (s in t.signals) } pred inv7 { all t:Track | t not in t.^succs } pred inv8 { all disj t,t1:Track | t in Entry and t1 in Exit implies t1 in t.^succs } pred inv9 { all t:Track,j:Junction |t.succs.next not in Junction implies t.signals.next not in Semaphore } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Junction}}{=>{!in{.{.{var0/Track}{field/succs{set of{sig/Track}}}}{field{next}}}{sig/Junction}}{!in{.{.{var0/Track}{field/signals{set of{sig/Signal}}}}{field{next}}}{sig/Semaphore}}}}}","nextExpr":"all t: Track, s:Semaphore | no t.succs & Junction => s not in t.signals","sourceExpr":"all t:Track,j:Junction |t.succs.next not in Junction implies t.signals.next not in Semaphore","predicate":"inv9","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Semaphore}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{!in{var1/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}","operations":"[\"(type='Update', node=sig/Junction, value=sig/Semaphore)\", \"(type='Insert', node=no, parent==>, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{.{var0/Track}{field/succs{set of{sig/Track}}}}{field{next}}}{sig/Junction}}', parent=no, position=0)\", \"(type='Insert', node=var1/Semaphore, parent=!in, position=0)\", \"(type='Move', tree='{.{var0/Track}{field/signals{set of{sig/Signal}}}}', parent=!in, position=1)\", \"(type='Move', tree='{.{var0/Track}{field/succs{set of{sig/Track}}}}', parent=!in, position=0)\", \"(type='TreeDelete', tree='{field{next}}')\", \"(type='Delete', node=.)\", \"(type='TreeDelete', tree='{field{next}}')\", \"(type='Delete', node=.)\", \"(type='Delete', node=sig/Semaphore)\"]","hint":"Keep going! Instead of using signature of type Junction, try using signature of type Semaphore to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Track}}{all{one of{var1}{sig/Semaphore}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{!in{var1/Semaphore}{.{var0/Track}{field/signals{set of{sig/Signal}}}}}}}}","totalTED":11,"challenge":"QxGnrFQnXPGh2Lh8C","time":67083200,"targetExpr":"all t: Track, s:Semaphore | no t.succs & Junction => s not in t.signals","createdShorterPath":false}
{"mapping":"APTED","code":"sig Track { succs : set Track, signals : set Signal } sig Junction, Entry, Exit in Track {} sig Signal {} sig Semaphore, Speed extends Signal {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { all t : Track | (t.*succs not in Junction) => (t.signals not in Semaphore) } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Track}}{=>{!in{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}{sig/Junction}}{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}","nextExpr":"all t : Track | no (Junction & t.succs) => no (Semaphore & t.signals)","sourceExpr":"all t: Track | t.*(succs) not in Junction implies t.signals not in Semaphore","predicate":"inv9","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","operations":"[\"(type='Insert', node=no, parent==>, position=0)\", \"(type='Insert', node=no, parent==>, position=1)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{*{field/succs{set of{sig/Track}}}}}{sig/Junction}}', parent=no, position=0)\", \"(type='Update', node=!in, value=&)\", \"(type='Move', tree='{!in{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}', parent=no, position=0)\", \"(type='Move', tree='{field/succs{set of{sig/Track}}}', parent=., position=1)\", \"(type='Delete', node=*)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/Track}}{=>{no{&{.{var0/Track}{field/succs{set of{sig/Track}}}}{sig/Junction}}}{no{&{.{var0/Track}{field/signals{set of{sig/Signal}}}}{sig/Semaphore}}}}}","totalTED":5,"challenge":"QxGnrFQnXPGh2Lh8C","time":81284000,"targetExpr":"all t : Track | no (Junction & t.succs) => no (Semaphore & t.signals)","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash and f in Trash } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{AND{!in{var0/File}{sig/Trash}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f : File | f not in Trash","sourceExpr":"all f:File | f not in Trash and f in Trash","predicate":"inv1","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{!in{var0/File}{sig/Trash}}}","operations":"[\"(type='Move', tree='{!in{var0/File}{sig/Trash}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{in{var0/File}{sig/Trash}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the exclusion operator ('!in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{!in{var0/File}{sig/Trash}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":112785900,"targetExpr":"all f : File | f not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | one t:Trash | f in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{one{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"all f : File | not f in Trash","sourceExpr":"all f:File | one t:Trash | f in t","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{!{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=one, value=!)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using negation operator ('!') to specify that the expression is false.","nextAST":"{all{one of{var0}{sig/File}}{!{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":29295400,"targetExpr":"all f : File | not f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File, t:Trash | f in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"all f : File | not f in Trash","sourceExpr":"all f:File, t:Trash | f in t","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{!{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=all, value=!)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using negation operator ('!') to specify that the expression is false.","nextAST":"{all{one of{var0}{sig/File}}{!{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":29438800,"targetExpr":"all f : File | not f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | one t:Trash | f not in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{one{one of{var1}{sig/Trash}}{!in{var0/File}{var1/File}}}}","nextExpr":"all f : File | f not in Trash","sourceExpr":"all f:File | one t:Trash | f not in t","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{!in{var0/File}{sig/Trash}}}","operations":"[\"(type='Move', tree='{!in{var0/File}{var1/File}}', parent=all, position=1)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\", \"(type='Delete', node=one)\"]","hint":"Keep going! It seems like the exclusion operator ('!in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{!in{var0/File}{sig/Trash}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":27340800,"targetExpr":"all f : File | f not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no f:File | all t:Trash | f in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{one of{var0}{sig/File}}{all{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"no f:File | f in Trash","sourceExpr":"no f:File | all t:Trash | f in t","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{no{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}","operations":"[\"(type='Move', tree='{in{var0/File}{var1/File}}', parent=no, position=1)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the inclusion operator ('in') is not in the right place. Try moving it to the inside of the no quantifier ('no') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{no{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":34169100,"targetExpr":"no f:File | f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | some t:Trash | f in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{some{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"all f : File | not f in Trash","sourceExpr":"all f:File | some t:Trash | f in t","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{!{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=!)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using negation operator ('!') to specify that the expression is false.","nextAST":"{all{one of{var0}{sig/File}}{!{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":27159900,"targetExpr":"all f : File | not f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { some f:File, t:Trash | f in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{some{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"not some f : File | f in Trash","sourceExpr":"some f:File, t:Trash | f in t","predicate":"inv1","isNewNode":true,"srcDstTED":6,"targetAST":"{!{some{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Insert', node=!, parent=root, position=0)\", \"(type='Move', tree='{some{one of{var0}{sig/File}}{some{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}', parent=!, position=0)\", \"(type='Move', tree='{in{var0/File}{var1/File}}', parent=some, position=1)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{!{some{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}}","totalTED":6,"challenge":"sDLK7uBCbgZon3znd","time":28437300,"targetExpr":"not some f : File | f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | some t:Trash | f not in t } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{some{one of{var1}{sig/Trash}}{!in{var0/File}{var1/File}}}}","nextExpr":"all f : File | f not in Trash","sourceExpr":"all f:File | some t:Trash | f not in t","predicate":"inv1","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{!in{var0/File}{sig/Trash}}}","operations":"[\"(type='Move', tree='{!in{var0/File}{var1/File}}', parent=all, position=1)\", \"(type='Update', node=var1/File, value=sig/Trash)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Trash}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! It seems like the exclusion operator ('!in') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/File}}{!in{var0/File}{sig/Trash}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":29176600,"targetExpr":"all f : File | f not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f: File | f in Trash } pred inv2 { all f : File | f in Trash } pred inv3 { some f : File | f in Trash } pred inv4 { all f : File | f in Protected implies f not in Trash } pred inv5 { all f : File | f not in Protected implies f in Trash } pred inv6 { all f1,f2,f3:File | f1 -> f2 in link and f1 -> f3 in link implies f2 = f3 } pred inv7 { all f1,f2:File | f1 -> f2 in link implies f2 not in Trash } pred inv8 { all f1,f2:File | f1 -> f2 not in link } pred inv9 { all f1,f2,f3:File | f1 -> f2 in link implies f2 -> f3 not in link } pred inv10 { all f1,f2:File | f1 -> f2 in link and f2 in Trash implies f1 in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var1/File}{sig/Trash}}}{in{var0/File}{sig/Trash}}}}}","nextExpr":"all x, y : File | x -> y in link and x in Trash implies y in Trash","sourceExpr":"all f, l : File | (f->l in link and l in Trash) implies f in Trash","predicate":"inv10","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var0/File}{sig/Trash}}}{in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=var0/File, value=var1/File)\", \"(type='Update', node=var1/File, value=var0/File)\"]","hint":"Near a solution! Instead of using variable of type File, try using variable of type File to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var0/File}{sig/Trash}}}{in{var1/File}{sig/Trash}}}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":92007400,"targetExpr":"all x, y : File | x -> y in link and x in Trash implies y in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { all f:File | lone f.link } pred inv7 { all f:File | f.link & Trash = none } pred inv8 { no link } pred inv9 { no f:File | no f.link.link } pred inv10 { all f:File | f in File.link }","sourceAST":"{all{one of{var0}{sig/File}}{in{var0/File}{.{sig/File}{field/link{set of{sig/File}}}}}}","nextExpr":"all f:Trash | f.link in Trash","sourceExpr":"all f:File | f in File.link","predicate":"inv10","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}","operations":"[\"(type='Update', node=sig/File, value=sig/Trash)\", \"(type='Insert', node=sig/Trash, parent=in, position=2)\", \"(type='Update', node=sig/File, value=var0/File)\", \"(type='Delete', node=var0/File)\"]","hint":"Keep going! Instead of using signature of type File, try using signature of type Trash to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Trash}}{in{.{var0/File}{field/link{set of{sig/File}}}}{sig/Trash}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":114146500,"targetExpr":"all f:Trash | f.link in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f not in Trash implies f in Protected } pred inv6 { all f1, f2, f3:File | f1 -> f2 in link and f1 -> f3 in link implies f2 = f3 } pred inv7 { all f1, f2:File | f1 -> f2 in link implies f2 not in Trash } pred inv8 { all f1, f2:File | f1 -> f2 not in link } pred inv9 { all f1, f2:File | f1 -> f2 in link implies all f3:File | f2->f3 not in link } pred inv10 { all f1, f2:File | f1 -> f2 in link implies (f1 in Trash and f2 in Trash) }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{AND{in{var0/File}{sig/Trash}}{in{var1/File}{sig/Trash}}}}}}","nextExpr":"all f1, f2 : File | (f1->f2 in link and f1 in Trash) implies f2 in Trash","sourceExpr":"all f1,f2 : File | f1->f2 in link implies f1 in Trash and f2 in Trash","predicate":"inv10","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var0/File}{sig/Trash}}}{in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{var0/File}{sig/Trash}}', parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var1/File}{sig/Trash}}', parent=AND, position=1)\", \"(type='Update', node=var0/File, value=var1/File)\", \"(type='Update', node=var1/File, value=var0/File)\", \"(type='Delete', node=AND)\"]","hint":"Near a solution! Consider adding a conjunction operator ('and') to combine two boolean expressions. Think about how you can incorporate this within the implication operator ('=>') expression.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var0/File}{sig/Trash}}}{in{var1/File}{sig/Trash}}}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":57855700,"targetExpr":"all f1, f2 : File | (f1->f2 in link and f1 in Trash) implies f2 in Trash","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File, t:Trash | f not in t } pred inv2 { all f:File, t:Trash | f in t } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","nextExpr":"all f : File | one t : Trash | f in t","sourceExpr":"all f:File, t:Trash | f in t","predicate":"inv2","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{one{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","operations":"[\"(type='Update', node=all, value=one)\"]","hint":"One step away from the solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/File}}{one{one of{var1}{sig/Trash}}{in{var0/File}{var1/File}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":91905300,"targetExpr":"all f : File | one t : Trash | f in t","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { some f:File | f in Trash implies f not in Protected } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{!in{var0/File}{sig/Protected}}}}","nextExpr":"all f : File |f in Trash implies f not in Protected","sourceExpr":"some f:File | f in Trash implies f not in Protected","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{!in{var0/File}{sig/Protected}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{!in{var0/File}{sig/Protected}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":90916900,"targetExpr":"all f : File |f in Trash implies f not in Protected","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { not all f:Protected | f in Trash } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!{all{one of{var0}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"not some p:Protected | p in Trash","sourceExpr":"not all f:Protected | f in Trash","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{!{some{one of{var0}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=all, value=some)\"]","hint":"One step away from the solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{!{some{one of{var0}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":34980400,"targetExpr":"not some p:Protected | p in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { not all f:Protected | f not in Trash } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{!{all{one of{var0}{sig/Protected}}{!in{var0/File}{sig/Trash}}}}","nextExpr":"all f:Protected | f not in Trash","sourceExpr":"not all f:Protected | f not in Trash","predicate":"inv4","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Protected}}{!in{var0/File}{sig/Trash}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/Protected}}{!in{var0/File}{sig/Trash}}}', parent=root, position=0)\", \"(type='Delete', node=!)\"]","hint":"One step away from the solution! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Protected}}{!in{var0/File}{sig/Trash}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":57641000,"targetExpr":"all f:Protected | f not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{in{var0/File}{sig/Protected}}}","nextExpr":"all f:File | all t:Trash | f!=t","sourceExpr":"all f:File | f in Protected","predicate":"inv4","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Protected}}{all{one of{var1}{sig/Trash}}{!={var0/File}{var1/File}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Trash}}', parent=all, position=0)\", \"(type='Update', node=in, value=!=)\", \"(type='Move', tree='{in{var0/File}{sig/Protected}}', parent=all, position=1)\", \"(type='Update', node=sig/Protected, value=var1/File)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Trash\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Trash}}{!={var0/File}{var1/File}}}}","totalTED":7,"challenge":"sDLK7uBCbgZon3znd","time":95424500,"targetExpr":"all p:Protected | all t:Trash | p!=t","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { no p:Protected | p in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{no{one of{var0}{sig/Protected}}{in{var0/File}{sig/Trash}}}","nextExpr":"all f : File - Protected | f in Trash","sourceExpr":"no p:Protected | p in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{-{sig/File}{sig/Protected}}}{in{var0/File}{sig/Trash}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Insert', node=sig/File, parent=-, position=0)\", \"(type='Move', tree='{sig/Protected}', parent=-, position=1)\"]","hint":"Near a solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{-{sig/File}{sig/Protected}}}{in{var0/File}{sig/Trash}}}","totalTED":3,"challenge":"sDLK7uBCbgZon3znd","time":114626500,"targetExpr":"all f : File - Protected | f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File, p:Protected | f in Trash implies f != p } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Protected}}{=>{in{var0/File}{sig/Trash}}{!={var0/File}{var1/File}}}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"all f:File, p:Protected | f in Trash implies f != p","predicate":"inv5","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Update', node=one of, value=!in)\", \"(type='Move', tree='{in{var0/File}{sig/Trash}}', parent=all, position=1)\", \"(type='Update', node=var1, value=var0/File)\", \"(type='TreeDelete', tree='{!={var0/File}{var1/File}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":7,"challenge":"sDLK7uBCbgZon3znd","time":40624800,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{var0/File}{sig/Protected}}}}","nextExpr":"all f:File|f not in Protected implies f in Trash","sourceExpr":"all f:File | f in Trash implies f in Protected","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Trash, value=sig/Protected)\", \"(type='Update', node=sig/Protected, value=sig/Trash)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":3,"challenge":"sDLK7uBCbgZon3znd","time":36513700,"targetExpr":"all f:File|f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { some f:File | f in Trash or f not in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{OR{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f : File| f not in Protected implies f in Trash","sourceExpr":"some f:File | f in Trash or f not in Protected","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=OR, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":36594800,"targetExpr":"all f : File| f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { some f:File | f in Trash implies f not in Protected } pred inv6 { all f1, f2, f3:File | (f1 -> f2 in link) and (f1 -> f3 in link) implies f2 = f3 } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{!in{var0/File}{sig/Protected}}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"some f:File | f in Trash implies f not in Protected","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=sig/Trash, value=sig/Protected)\", \"(type='Update', node=sig/Protected, value=sig/Trash)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":27990300,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File, p:Protected | f in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"all f:File, p:Protected | f in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=all, value==>)\", \"(type='Update', node=one of, value=!in)\", \"(type='Update', node=var1, value=var0/File)\"]","hint":"Near a solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":3,"challenge":"sDLK7uBCbgZon3znd","time":74625100,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{in{var0/File}{sig/Trash}}}","nextExpr":"all f : File - Protected | f in Trash","sourceExpr":"all f:File | f in Trash","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{-{sig/File}{sig/Protected}}}{in{var0/File}{sig/Trash}}}","operations":"[\"(type='Insert', node=-, parent=one of, position=1)\", \"(type='Move', tree='{sig/File}', parent=-, position=0)\", \"(type='Insert', node=sig/Protected, parent=-, position=1)\"]","hint":"Near a solution! Consider adding a difference operator ('-') to remove elements from a set. Think about how you can incorporate this within the unique quantifier ('one') expression.","nextAST":"{all{one of{var0}{-{sig/File}{sig/Protected}}}{in{var0/File}{sig/Trash}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":91211800,"targetExpr":"all f : File - Protected | f in Trash","createdShorterPath":true}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) = Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={-{sig/File}{sig/Protected}}{sig/Trash}}","nextExpr":"File - Protected in Trash","sourceExpr":"File - Protected = Trash","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{in{-{sig/File}{sig/Protected}}{sig/Trash}}","operations":"[\"(type='Update', node==, value=in)\"]","hint":"One step away from the solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{-{sig/File}{sig/Protected}}{sig/Trash}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":40577100,"targetExpr":"File - Protected in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { some f:File | f in Trash and f not in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{AND{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f:File|f not in Protected implies f in Trash","sourceExpr":"some f : File | f not in Protected and f in Trash","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":33740400,"targetExpr":"all f:File|f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f1:File | f1 not in Protected and f1 in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{AND{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"all f:File | f not in Protected and f in Trash","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=AND, value==>)\"]","hint":"One step away from the solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":35138000,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { some f:File, p:Protected | f in Trash and p not in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{some{one of{var1}{sig/Protected}}{AND{!in{var1/File}{sig/Trash}}{in{var0/File}{sig/Trash}}}}}","nextExpr":"all f:File | f not in Protected implies f in Trash","sourceExpr":"some f:File, p:Protected | f in Trash and p not in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{var1/File}{sig/Trash}}{in{var0/File}{sig/Trash}}}', parent=some, position=1)\", \"(type='Update', node=var1/File, value=var0/File)\", \"(type='Update', node=sig/Trash, value=sig/Protected)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Protected}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":8,"challenge":"sDLK7uBCbgZon3znd","time":56662700,"targetExpr":"all f:File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash or f not in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{OR{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"all f:File | f in Trash or f not in Protected","predicate":"inv5","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=OR, value==>)\"]","hint":"One step away from the solution! Instead of using disjunction operator ('or') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":28706400,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { some f:File | f in Trash implies f in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{in{var0/File}{sig/Protected}}}}","nextExpr":"all f:File|f not in Protected implies f in Trash","sourceExpr":"some f:File | f in Trash implies f in Protected","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=sig/Trash, value=sig/Protected)\", \"(type='Update', node=sig/Protected, value=sig/Trash)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":29197800,"targetExpr":"all f:File|f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:Protected | f not in Trash } pred inv5 { all f:Protected | f in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/Protected}}{in{var0/File}{sig/Trash}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"all p : Protected | p in Trash","predicate":"inv5","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=sig/Protected, value=sig/File)\", \"(type='TreeInsert', tree='{!in{var0/File}{sig/Protected}}', parent==>, position=0)\", \"(type='Move', tree='{in{var0/File}{sig/Trash}}', parent==>, position=1)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":79050800,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File, p:Protected | f in Trash implies f not in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Protected}}{=>{in{var0/File}{sig/Trash}}{!in{var0/File}{sig/Protected}}}}}","nextExpr":"all f : File | f in Protected or (f in Trash and f not in Protected)","sourceExpr":"all f:File, p:Protected | f in Trash implies f not in Protected","predicate":"inv5","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/File}}{OR{AND{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}{in{var0/File}{sig/Protected}}}}","operations":"[\"(type='Update', node=all, value=OR)\", \"(type='Insert', node=AND, parent=all, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/File}{sig/Protected}}', parent=all, position=1)\", \"(type='Update', node=one of, value=!in)\", \"(type='Move', tree='{one of{var1}{sig/Protected}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var0/File}{sig/Trash}}', parent=AND, position=1)\", \"(type='Update', node=var1, value=var0/File)\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using disjunction operator ('or') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/File}}{OR{AND{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}{in{var0/File}{sig/Protected}}}}","totalTED":6,"challenge":"sDLK7uBCbgZon3znd","time":32815700,"targetExpr":"all f : File | f in Protected or (f in Trash and f not in Protected)","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Protected implies f not in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Protected}}{!in{var0/File}{sig/Trash}}}}","nextExpr":"all f:File|f not in Protected implies f in Trash","sourceExpr":"all f:File | f in Protected implies f not in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=!in, value=in)\"]","hint":"Near a solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":34550200,"targetExpr":"all f:File|f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { some f:File | all p:Protected | f in Trash and p not in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{all{one of{var1}{sig/Protected}}{AND{!in{var1/File}{sig/Trash}}{in{var0/File}{sig/Trash}}}}}","nextExpr":"all f:File|f not in Protected implies f in Trash","sourceExpr":"some f:File | all p:Protected | f in Trash and p not in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{var1/File}{sig/Trash}}{in{var0/File}{sig/Trash}}}', parent=some, position=1)\", \"(type='Update', node=var1/File, value=var0/File)\", \"(type='Update', node=sig/Trash, value=sig/Protected)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Protected}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":8,"challenge":"sDLK7uBCbgZon3znd","time":27732900,"targetExpr":"all f:File|f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f not in Protected } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{!in{var0/File}{sig/Protected}}}}","nextExpr":"all f : File | f not in Protected implies f in Trash","sourceExpr":"all f : File | f in Trash implies f not in Protected","predicate":"inv5","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=in, value=!in)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=sig/Trash, value=sig/Protected)\", \"(type='Update', node=sig/Protected, value=sig/Trash)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":42499400,"targetExpr":"all f : File | f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File, p:Protected | f not in Protected and f in Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/Protected}}{AND{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}}","nextExpr":"all f:File|f not in Protected implies f in Trash","sourceExpr":"all f:File, p:Protected | f not in Protected and f in Trash","predicate":"inv5","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Move', tree='{AND{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}', parent=all, position=1)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Protected}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":28825700,"targetExpr":"all f:File|f not in Protected implies f in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { File = Trash } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{={sig/File}{sig/Trash}}","nextExpr":"File - Protected in Trash","sourceExpr":"File = Trash","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{in{-{sig/File}{sig/Protected}}{sig/Trash}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=-, parent==, position=0)\", \"(type='Move', tree='{sig/File}', parent=-, position=0)\", \"(type='Insert', node=sig/Protected, parent=-, position=1)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{-{sig/File}{sig/Protected}}{sig/Trash}}","totalTED":3,"challenge":"sDLK7uBCbgZon3znd","time":35945400,"targetExpr":"File - Protected in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f not in Protected } pred inv6 { some f1, f2, f3:File | (f1 -> f2 in link) and (f1 -> f3 in link) implies f2 = f3 } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{some{one of{var2}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var0/File}{var2/File}}{field/link{set of{sig/File}}}}}{={var1/File}{var2/File}}}}}}","nextExpr":"all f1,f2,f3 : File | (f1->f2 in link and f1->f3 in link) => f2 = f3","sourceExpr":"some f1,f2,f3:File | f1->f2 in link and f1->f3 in link implies f2=f3","predicate":"inv6","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var0/File}{var2/File}}{field/link{set of{sig/File}}}}}{={var1/File}{var2/File}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var0/File}{var2/File}}{field/link{set of{sig/File}}}}}{={var1/File}{var2/File}}}}}}","totalTED":3,"challenge":"sDLK7uBCbgZon3znd","time":97597100,"targetExpr":"all f1,f2,f3 : File | (f1->f2 in link and f1->f3 in link) => f2 = f3","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { one link } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{one{field/link{set of{sig/File}}}}","nextExpr":"link in File -> lone File","sourceExpr":"one link","predicate":"inv6","isNewNode":true,"srcDstTED":4,"targetAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","operations":"[\"(type='Update', node=one, value=in)\", \"(type='TreeInsert', tree='{->lone{sig/File}{sig/File}}', parent=one, position=1)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":121779800,"targetExpr":"link in File -> lone File","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { all f:File | lone File.link } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{lone{.{sig/File}{field/link{set of{sig/File}}}}}}","nextExpr":"all f:File | lone f.link","sourceExpr":"all f:File | lone File.link","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Update', node=sig/File, value=var0/File)\"]","hint":"One step away from the solution! Instead of using signature of type File, try using variable of type File to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":38169600,"targetExpr":"all f:File | lone f.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { link in File one -> one File } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/link{set of{sig/File}}}{one->one{sig/File}{sig/File}}}","nextExpr":"link in File -> lone File","sourceExpr":"link in File one -> one File","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","operations":"[\"(type='Update', node=one->one, value=->lone)\"]","hint":"One step away from the solution! Instead of using one->one, try using ->lone to help satisfy the required property.","nextAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":59569200,"targetExpr":"link in File -> lone File","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected implies f not in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { link in File set -> one File } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/link{set of{sig/File}}}{->one{sig/File}{sig/File}}}","nextExpr":"link in File -> lone File","sourceExpr":"link in File -> one File","predicate":"inv6","isNewNode":false,"srcDstTED":1,"targetAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","operations":"[\"(type='Update', node=->one, value=->lone)\"]","hint":"One step away from the solution! Instead of using ->one, try using ->lone to help satisfy the required property.","nextAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":70203400,"targetExpr":"link in File -> lone File","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected implies f not in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { all f:File | f not in Protected implies f in Trash } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}}","nextExpr":"all f:File | lone f.link","sourceExpr":"all f:File | f not in Protected implies f in Trash","predicate":"inv6","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Insert', node=lone, parent=all, position=1)\", \"(type='Update', node==>, value=.)\", \"(type='Move', tree='{=>{!in{var0/File}{sig/Protected}}{in{var0/File}{sig/Trash}}}', parent=lone, position=0)\", \"(type='Move', tree='{var0/File}', parent==>, position=0)\", \"(type='Insert', node=field/link, parent==>, position=1)\", \"(type='Update', node=in, value=set of)\", \"(type='Move', tree='{in{var0/File}{sig/Trash}}', parent=field/link, position=0)\", \"(type='Update', node=var0/File, value=sig/File)\", \"(type='Delete', node=sig/Trash)\", \"(type='Delete', node=sig/Protected)\", \"(type='Delete', node=!in)\"]","hint":"Keep going! Consider adding a lone quantifier ('lone') to specify that there is at most one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","totalTED":8,"challenge":"sDLK7uBCbgZon3znd","time":55453600,"targetExpr":"all f:File | lone f.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { lone link } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{lone{field/link{set of{sig/File}}}}","nextExpr":"link in File -> lone File","sourceExpr":"lone link","predicate":"inv6","isNewNode":true,"srcDstTED":4,"targetAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","operations":"[\"(type='Update', node=lone, value=in)\", \"(type='TreeInsert', tree='{->lone{sig/File}{sig/File}}', parent=lone, position=1)\"]","hint":"Keep going! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":46420300,"targetExpr":"link in File -> lone File","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected implies f not in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { link in File some -> one File } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/link{set of{sig/File}}}{some->one{sig/File}{sig/File}}}","nextExpr":"link in File -> lone File","sourceExpr":"link in File some -> one File","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","operations":"[\"(type='Update', node=some->one, value=->lone)\"]","hint":"One step away from the solution! Instead of using some->one, try using ->lone to help satisfy the required property.","nextAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":33685700,"targetExpr":"link in File -> lone File","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { lone File.link } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{lone{.{sig/File}{field/link{set of{sig/File}}}}}","nextExpr":"all f:File |lone (f.link)","sourceExpr":"lone (File.link)","predicate":"inv6","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/File}}', parent=all, position=0)\", \"(type='Move', tree='{lone{.{sig/File}{field/link{set of{sig/File}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/File, value=var0/File)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"File\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/File}}{lone{.{var0/File}{field/link{set of{sig/File}}}}}}","totalTED":5,"challenge":"sDLK7uBCbgZon3znd","time":85631700,"targetExpr":"all f:File |lone (f.link)","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { no Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected implies f not in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { link in File set -> set File } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{in{field/link{set of{sig/File}}}{->{sig/File}{sig/File}}}","nextExpr":"link in File -> lone File","sourceExpr":"link in File set -> set File","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","operations":"[\"(type='Update', node=->, value=->lone)\"]","hint":"One step away from the solution! Instead of using arrow operator ('->') to map a relation, try using ->lone to help satisfy the required property.","nextAST":"{in{field/link{set of{sig/File}}}{->lone{sig/File}{sig/File}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":56841500,"targetExpr":"link in File -> lone File","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected implies f not in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { all f1,f2,f3:File | f1 -> f2 in link and f1 -> f3 in link implies f2 = f3 } pred inv7 { all f1,f2:File | f1 -> f2 in link implies f1 not in Trash } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var0/File}{sig/Trash}}}}}","nextExpr":"all f,lk1 : File | f->lk1 in link implies lk1 not in Trash","sourceExpr":"all x, y : File | x->y in link implies x not in Trash","predicate":"inv7","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=var0/File, value=var1/File)\"]","hint":"One step away from the solution! Instead of using variable of type File, try using variable of type File to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":123602700,"targetExpr":"all f,lk1 : File | f->lk1 in link implies lk1 not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f not in Protected } pred inv6 { all f1, f2, f3:File | (f1 -> f2 in link) and (f1 -> f3 in link) implies f2 = f3 } pred inv7 { some f1:File | some f2:File | f1 -> f2 in link implies (f2 not in Trash) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","nextExpr":"all f,lk1 : File | f->lk1 in link implies lk1 not in Trash","sourceExpr":"some f1:File | some f2:File | f1 -> f2 in link implies (f2 not in Trash)","predicate":"inv7","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","totalTED":2,"challenge":"sDLK7uBCbgZon3znd","time":117543500,"targetExpr":"all f,lk1 : File | f->lk1 in link implies lk1 not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { all f1,f2,f3:File | f1 -> f2 in link and f1 -> f3 in link implies f2 = f3 } pred inv7 { all f:File | f in Trash implies no f2:File | f->f2 in link } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{=>{in{var0/File}{sig/Trash}}{no{one of{var1}{sig/File}}{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}}}}","nextExpr":"all f1,f2:File| f1->f2 in link implies f2 not in Trash","sourceExpr":"all f:File | f in Trash implies no f2:File | f->f2 in link","predicate":"inv7","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Move', tree='{no{one of{var1}{sig/File}}{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}}', parent=all, position=1)\", \"(type='Insert', node==>, parent=no, position=1)\", \"(type='Move', tree='{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{!in{var1/File}{sig/Trash}}', parent==>, position=1)\", \"(type='TreeDelete', tree='{in{var0/File}{sig/Trash}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","totalTED":9,"challenge":"sDLK7uBCbgZon3znd","time":35319600,"targetExpr":"all f1,f2:File| f1->f2 in link implies f2 not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f not in Protected } pred inv6 { all f1, f2, f3:File | (f1 -> f2 in link) and (f1 -> f3 in link) implies f2 = f3 } pred inv7 { all f1:File | some f2:File | f1 -> f2 in link and (f2 not in Trash) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{AND{!in{var1/File}{sig/Trash}}{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}}}}","nextExpr":"all f1,f2:File| f1->f2 in link implies f2 not in Trash","sourceExpr":"all f1:File | some f2:File | f1 -> f2 in link and (f2 not in Trash)","predicate":"inv7","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='TreeInsert', tree='{!in{var1/File}{sig/Trash}}', parent=AND, position=2)\", \"(type='TreeDelete', tree='{!in{var1/File}{sig/Trash}}')\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","totalTED":8,"challenge":"sDLK7uBCbgZon3znd","time":31873900,"targetExpr":"all f1,f2:File| f1->f2 in link implies f2 not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f not in Protected } pred inv6 { all f1, f2, f3:File | (f1 -> f2 in link) and (f1 -> f3 in link) implies f2 = f3 } pred inv7 { some f1:File | some f2:File | f1 -> f2 in link and (f2 not in Trash) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{some{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{AND{!in{var1/File}{sig/Trash}}{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}}}}","nextExpr":"not some l, f : File | (l->f in link) and (f in Trash)","sourceExpr":"some f1:File | some f2:File | f1 -> f2 in link and (f2 not in Trash)","predicate":"inv7","isNewNode":true,"srcDstTED":7,"targetAST":"{!{some{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var1/File}{sig/Trash}}}}}}","operations":"[\"(type='Insert', node=!, parent=root, position=0)\", \"(type='Move', tree='{some{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}', parent=!, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='TreeInsert', tree='{in{var1/File}{sig/Trash}}', parent=AND, position=2)\", \"(type='Update', node=field/link, value=->)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=!in, position=0)\", \"(type='Update', node=sig/Trash, value=field/link)\", \"(type='Update', node=sig/File, value=var0/File)\", \"(type='Move', tree='{sig/File}', parent=field/link, position=0)\", \"(type='Update', node=set of, value=var1/File)\", \"(type='Update', node=var1/File, value=set of)\", \"(type='Move', tree='{var1/File}', parent=sig/Trash, position=0)\", \"(type='Update', node=in, value=sig/File)\", \"(type='Move', tree='{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}', parent=var1/File, position=0)\", \"(type='TreeDelete', tree='{->{var0/File}{var1/File}}')\"]","hint":"Keep going! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within your expression to ensure the required property.","nextAST":"{!{some{one of{var0}{sig/File}}{some{one of{var1}{sig/File}}{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{var1/File}{sig/Trash}}}}}}","totalTED":7,"challenge":"sDLK7uBCbgZon3znd","time":73480500,"targetExpr":"not some l, f : File | (l->f in link) and (f in Trash)","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { all f:File | f not in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all p:Protected | p not in Trash } pred inv5 { all f:File | f in Trash implies f not in Protected } pred inv6 { all f1, f2, f3:File | (f1 -> f2 in link) and (f1 -> f3 in link) implies f2 = f3 } pred inv7 { all f1, f2:File | f1 -> f2 in link and (f2 not in Trash) } pred inv8 { } pred inv9 { } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{AND{!in{var1/File}{sig/Trash}}{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}}}}","nextExpr":"all f1,f2:File| f1->f2 in link implies f2 not in Trash","sourceExpr":"all x, y : File | x->y in link and y not in Trash","predicate":"inv7","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='TreeInsert', tree='{!in{var1/File}{sig/Trash}}', parent=AND, position=2)\", \"(type='TreeDelete', tree='{!in{var1/File}{sig/Trash}}')\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{var1/File}{sig/Trash}}}}}","totalTED":7,"challenge":"sDLK7uBCbgZon3znd","time":72582400,"targetExpr":"all f1,f2:File| f1->f2 in link implies f2 not in Trash","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { all f:File | lone f.link } pred inv7 { all f:File | f.link & Trash = none } pred inv8 { no link } pred inv9 { all f1, f2:File | f2 in f1.link and no f2.link } pred inv10 { all f:File | f in Trash implies f.link in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{AND{in{var1/File}{.{var0/File}{field/link{set of{sig/File}}}}}{no{.{var1/File}{field/link{set of{sig/File}}}}}}}}","nextExpr":"all f : File | all l : f.link | no l.link","sourceExpr":"all f1, f2:File | f2 in f1.link and no f2.link","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{.{var0/File}{field/link{set of{sig/File}}}}}{no{.{var1/File}{field/link{set of{sig/File}}}}}}}","operations":"[\"(type='Insert', node=one of, parent=all, position=0)\", \"(type='Move', tree='{no{.{var1/File}{field/link{set of{sig/File}}}}}', parent=all, position=1)\", \"(type='Move', tree='{var1}', parent=one of, position=0)\", \"(type='Move', tree='{.{var0/File}{field/link{set of{sig/File}}}}', parent=one of, position=1)\", \"(type='Delete', node=sig/File)\", \"(type='Delete', node=one of)\", \"(type='Delete', node=var1/File)\", \"(type='Delete', node=in)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Consider adding a unique quantifier ('one') to specify that there is exactly one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{.{var0/File}{field/link{set of{sig/File}}}}}{no{.{var1/File}{field/link{set of{sig/File}}}}}}}","totalTED":6,"challenge":"sDLK7uBCbgZon3znd","time":130522400,"targetExpr":"all f : File | all l : f.link | no l.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f: File | f in Trash } pred inv2 { all f : File | f in Trash } pred inv3 { some f : File | f in Trash } pred inv4 { all f : File | f in Protected implies f not in Trash } pred inv5 { all f : File | f not in Protected implies f in Trash } pred inv6 { all f1,f2,f3:File | f1 -> f2 in link and f1 -> f3 in link implies f2 = f3 } pred inv7 { all f1,f2:File | f1 -> f2 in link implies f2 not in Trash } pred inv8 { all f1,f2:File | f1 -> f2 not in link } pred inv9 { all f1,f2,f3:File | f1 -> f2 in link and f2 -> f3 not in link } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{AND{!in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}}}}}","nextExpr":"all x,y,z : File | x->y in link implies y->z not in link","sourceExpr":"all x : File | all y : File | all z : File | x->y in link and y->z not in link","predicate":"inv9","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=in, value=!in)\", \"(type='Insert', node=var0/File, parent=->, position=0)\", \"(type='Insert', node=var2/File, parent=->, position=2)\", \"(type='Delete', node=var2/File)\", \"(type='Delete', node=var0/File)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{=>{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{!in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}}}}}","totalTED":7,"challenge":"sDLK7uBCbgZon3znd","time":88843000,"targetExpr":"all x,y,z : File | x->y in link implies y->z not in link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { not some f:File | f in Trash } pred inv2 { all f:File | f in Trash } pred inv3 { some f:File | f in Trash } pred inv4 { all f:File | f in Protected implies f not in Trash } pred inv5 { all f:File | f not in Protected implies f in Trash } pred inv6 { all f1,f2,f3:File | f1->f2 in link and f1->f3 in link implies f2 = f3 } pred inv7 { all f1,f2:File | f1->f2 in link implies f2 not in Trash } pred inv8 { all f1,f2:File | f1->f2 not in link } pred inv9 { all f1,f2,f3:File | f1->f2 in link and f2->f3 in link implies f1=f2 } pred inv10 { }","sourceAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{=>{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}}{={var0/File}{var1/File}}}}}}","nextExpr":"all f1, f2, f3 : File | not (f1 -> f2 in link && f2 -> f3 in link)","sourceExpr":"all f1,f2,f3:File | f1->f2 in link and f2->f3 in link implies f1=f2","predicate":"inv9","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{!{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}}}}}}","operations":"[\"(type='Update', node==>, value=!)\", \"(type='TreeDelete', tree='{={var0/File}{var1/File}}')\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using negation operator ('!') to specify that the expression is false.","nextAST":"{all{one of{var0}{sig/File}}{all{one of{var1}{sig/File}}{all{one of{var2}{sig/File}}{!{AND{in{->{var0/File}{var1/File}}{field/link{set of{sig/File}}}}{in{->{var1/File}{var2/File}}{field/link{set of{sig/File}}}}}}}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":47618500,"targetExpr":"all f1, f2, f3 : File | not (f1 -> f2 in link && f2 -> f3 in link)","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { all f:File | lone f.link } pred inv7 { all f:File | f.link & Trash = none } pred inv8 { no link } pred inv9 { no f:File | no f.link.link } pred inv10 { }","sourceAST":"{no{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","nextExpr":"all f : File | no f.link.link","sourceExpr":"no f:File | no f.link.link","predicate":"inv9","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Update', node=no, value=all)\"]","hint":"One step away from the solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","totalTED":1,"challenge":"sDLK7uBCbgZon3znd","time":32874900,"targetExpr":"all f : File | no f.link.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig File { link : set File } sig Trash in File {} sig Protected in File {} pred inv1 { File & Trash = none } pred inv2 { File = Trash } pred inv3 { some (File & Trash) } pred inv4 { no(Protected & Trash) } pred inv5 { (File - Protected) in Trash } pred inv6 { all f:File | lone f.link } pred inv7 { all f:File | f.link & Trash = none } pred inv8 { no link } pred inv9 { all f:File | f.link not in File.link } pred inv10 { all f:File | f in Trash implies f.link in Trash }","sourceAST":"{all{one of{var0}{sig/File}}{!in{.{var0/File}{field/link{set of{sig/File}}}}{.{sig/File}{field/link{set of{sig/File}}}}}}","nextExpr":"all f : File | no f.link.link","sourceExpr":"all f:File | f.link not in File.link","predicate":"inv9","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","operations":"[\"(type='Insert', node=no, parent=all, position=1)\", \"(type='Update', node=!in, value=.)\", \"(type='Move', tree='{!in{.{var0/File}{field/link{set of{sig/File}}}}{.{sig/File}{field/link{set of{sig/File}}}}}', parent=no, position=0)\", \"(type='Move', tree='{field/link{set of{sig/File}}}', parent=!in, position=1)\", \"(type='Delete', node=sig/File)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Consider adding a no quantifier ('no') to specify that there are no elements in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/File}}{no{.{.{var0/File}{field/link{set of{sig/File}}}}{field/link{set of{sig/File}}}}}}","totalTED":4,"challenge":"sDLK7uBCbgZon3znd","time":92959600,"targetExpr":"all f : File | no f.link.link","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { some Student } pred inv2 { no Teacher } pred inv3 { no Student & Teacher } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{sig/Student}}","nextExpr":"Person in Student","sourceExpr":"some Student","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{in{sig/Person}{sig/Student}}","operations":"[\"(type='Update', node=some, value=in)\", \"(type='Insert', node=sig/Person, parent=some, position=0)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{sig/Person}{sig/Student}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":115852700,"targetExpr":"Person in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { no Teacher } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{sig/Teacher}}","nextExpr":"Person in Student","sourceExpr":"no Teacher","predicate":"inv1","isNewNode":true,"srcDstTED":3,"targetAST":"{in{sig/Person}{sig/Student}}","operations":"[\"(type='Update', node=no, value=in)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=sig/Student, parent=no, position=1)\"]","hint":"Near a solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{in{sig/Person}{sig/Student}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":31361000,"targetExpr":"Person in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| one g:Group | c->s->g in Groups } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{one{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all c:Class,s:Student | some g:Group | c->s->g in Groups","sourceExpr":"all c:Class,s:Student| one g:Group | c->s->g in Groups","predicate":"inv10","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","operations":"[\"(type='Update', node=one, value=some)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":95961300,"targetExpr":"all c:Class,s:Student | some g:Group | c->s->g in Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c:Class | some Student.Groups } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{.{sig/Student}{field/Groups{->{sig/Person}{sig/Group}}}}}}","nextExpr":"all c:Class , s:Student| some s.(c.Groups)","sourceExpr":"all c:Class | some Student.Groups","predicate":"inv10","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Student}}', parent=all, position=0)\", \"(type='Move', tree='{some{.{sig/Student}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent=all, position=1)\", \"(type='Insert', node=., parent=some, position=0)\", \"(type='Insert', node=var1/Person, parent=., position=0)\", \"(type='Move', tree='{.{sig/Student}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=., position=1)\", \"(type='Update', node=sig/Student, value=var0/Class)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Student\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":61019000,"targetExpr":"all c:Class , s:Student| some s.(c.Groups)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g: Group | c.Groups[s] = g } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{={.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{var2/Group}}}}}","nextExpr":"all c:Class , s:Student| some s.(c.Groups)","sourceExpr":"all c: Class, s: Student | some g: Group | c.Groups[s] = g","predicate":"inv10","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","operations":"[\"(type='Move', tree='{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent=some, position=0)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Group}}')\", \"(type='Delete', node=var2/Group)\", \"(type='Delete', node==)\"]","hint":"Keep going! It seems like the dot join operator ('.') is not in the right place. Try moving it to the inside of the existential quantifier ('some') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":27709800,"targetExpr":"all c:Class , s:Student| some s.(c.Groups)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c:Class | one c.Groups } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{one{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}","nextExpr":"all c:Class , s:Student| some s.(c.Groups)","sourceExpr":"all c:Class | one c.Groups","predicate":"inv10","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Student}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=one, value=.)\", \"(type='Move', tree='{one{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent=some, position=0)\", \"(type='Insert', node=var1/Person, parent=one, position=0)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Student\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{.{var1/Person}{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":33152400,"targetExpr":"all c:Class , s:Student| some s.(c.Groups)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student, g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all c : Class, s : Student | some g : Group | c->s->g in Groups","sourceExpr":"all c: Class, s:Student, g:Group | c->s->g in Groups","predicate":"inv10","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\"]","hint":"One step away from the solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":101734800,"targetExpr":"all c : Class, s : Student | some g : Group | c->s->g in Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (s->g->c) in Groups } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var1/Person}{->{var2/Group}{var0/Class}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all c:Class,s:Student | some g:Group | c->s->g in Groups","sourceExpr":"all c:Class | all s:Student | some g:Group | (s->g->c) in Groups","predicate":"inv10","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","operations":"[\"(type='Update', node=var1/Person, value=var0/Class)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Delete', node=var0/Class)\"]","hint":"Near a solution! Instead of using variable of type Person, try using variable of type Class to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":32765700,"targetExpr":"all c:Class,s:Student | some g:Group | c->s->g in Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some t:Teacher | all s:Student | some g:Group | (c->s->g in Groups) implies (t->c in Teaches) } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Student}}{some{one of{var3}{sig/Group}}{=>{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"all c:Class | some t:Teacher | all s:Student | some g:Group | (c->s->g in Groups) implies (t->c in Teaches)","predicate":"inv11","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Group)\", \"(type='Update', node=sig/Group, value=sig/Person)\", \"(type='Insert', node=AND, parent==>, position=1)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var3/Group, value=var2/Group)\", \"(type='Update', node=var1/Person, value=var3/Person)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":11,"challenge":"YH3ANm7Y5Qe5dSYem","time":118077700,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some p:Person,g:Group,t:Teacher | (c->p->g) in Groups implies t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"all c : Class | some p : Person, g : Group, t : Teacher | c->p->g in Groups implies t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=some, value==>)\", \"(type='Insert', node=some, parent=some, position=0)\", \"(type='Insert', node=some, parent=some, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Person}}', parent=some, position=0)\", \"(type='Insert', node=some, parent=some, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Teacher}}', parent=some, position=0)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=some, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Group}}', parent=some, position=0)\", \"(type='Move', tree='{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=some, position=1)\", \"(type='TreeDelete', tree='{one of{var3}{sig/Teacher}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":93816300,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some t:Teacher | some s:Student | some g:Group | (c->s->g in Groups) implies (t->c in Teaches) } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{some{one of{var2}{sig/Student}}{some{one of{var3}{sig/Group}}{=>{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c : Class | some t : Teacher | some s : Student | some g : Group | c->s->g in Groups implies t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Move', tree='{some{one of{var3}{sig/Group}}{=>{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}', parent=some, position=1)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=var3, value=var2)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='TreeInsert', tree='{one of{var3}{sig/Teacher}}', parent=some, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=some, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var3/Group, value=var2/Group)\", \"(type='Update', node=var1/Person, value=var3/Person)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Student}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":15,"challenge":"YH3ANm7Y5Qe5dSYem","time":54588200,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some s:Student,g:Group | some t:Teacher | (c->s->g) in Groups implies t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Student, g : Group | some t : Teacher | c->s->g in Groups implies t->c in Teaches","sourceExpr":"(all c : Class | some s : Student | some g : Group | some t : Teacher | c->s->g in Groups implies t->c in Teaches)","predicate":"inv11","isNewNode":false,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":53701600,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { no c:Class | some s:Person | some g:Group | some t:Teacher | (c->s->g) in Groups implies t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"no c:Class | some s:Person | some g:Group | some t:Teacher | (c->s->g) in Groups implies t->c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent==>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":42086700,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some s:Student,g:Group | (c->s->g) in Groups } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"all c:Class | some s:Student,g:Group | (c->s->g) in Groups","predicate":"inv11","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}', parent==>, position=1)\", \"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"Keep going! Consider adding a implication operator ('=>') to specify that if the left side is true, then the right side must also be true. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":43905000,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some s:Student,g:Group | (c->s->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class | some p : Person, g : Group | c->p->g in Groups implies some t : Teacher | t->c in Teaches","sourceExpr":"all c : Class | some s : Student | some g : Group | c->s->g in Groups implies (some t : Teacher | t->c in Teaches)","predicate":"inv11","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":58236400,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | c not in Person.Teaches implies no c->Group } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{=>{!in{var0/Class}{.{sig/Person}{field/Teaches{set of{sig/Class}}}}}{no{->{var0/Class}{sig/Group}}}}}","nextExpr":"all c:Class | some c.Groups implies some Teacher&Teaches.c","sourceExpr":"all c:Class | c not in Person.Teaches implies no c->Group","predicate":"inv11","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='Insert', node=., parent=some, position=0)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Move', tree='{var0/Class}', parent=., position=0)\", \"(type='Insert', node=field/Groups, parent=., position=1)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='Update', node=sig/Group, value=sig/Teacher)\", \"(type='Move', tree='{sig/Group}', parent=&, position=1)\", \"(type='Insert', node=->, parent=field/Groups, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Class}', parent=., position=1)\", \"(type='Move', tree='{sig/Person}', parent=->, position=0)\", \"(type='Insert', node=sig/Group, parent=->, position=1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=->)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":61897800,"targetExpr":"all c:Class | some c.Groups implies some Teacher&Teaches.c","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { no c:Class | some t:Teacher | some s:Student | some g:Group | (c->s->g in Groups) and (t->c in Teaches) } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{some{one of{var2}{sig/Student}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"no c:Class | some t:Teacher | some s:Student | some g:Group | (c->s->g in Groups) and (t->c in Teaches)","predicate":"inv11","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Group)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Group, value=sig/Person)\", \"(type='Insert', node=AND, parent=AND, position=1)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var3/Group, value=var2/Group)\", \"(type='Update', node=var1/Person, value=var3/Person)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":14,"challenge":"YH3ANm7Y5Qe5dSYem","time":67757500,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some s:Person,g:Group | (c->s->g in Groups)) implies (some t:Person | t->c in Teaches) } pred inv12 { } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Person}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"all c:Class | (some s:Person,g:Group | (c->s->g in Groups)) implies (some t:Person | t->c in Teaches)","predicate":"inv11","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Teacher)\"]","hint":"One step away from the solution! Instead of using signature of type Person, try using signature of type Teacher to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":36937900,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some s:Student,g:Group | (c->s->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"all c : Class | (some s : Student | some g : Group | c->s->g in Groups) => some t : Teacher | t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":62453200,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies p in Teacher } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{var1/Person}{sig/Teacher}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c:Class, p : Person, g:Group | c->p->g in Groups implies p in Teacher","predicate":"inv11","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=one of)\", \"(type='Move', tree='{in{var1/Person}{sig/Teacher}}', parent=some, position=0)\", \"(type='TreeInsert', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=some, position=1)\", \"(type='Update', node=var1/Person, value=var3)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using unique quantifier ('one') to specify that there is exactly one element in a set.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":60473200,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | c not in Person.Teaches implies no Group } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{=>{!in{var0/Class}{.{sig/Person}{field/Teaches{set of{sig/Class}}}}}{no{sig/Group}}}}","nextExpr":"all c : Class | (some c.Groups) implies (some (Teacher & c.~Teaches))","sourceExpr":"all c:Class | c not in Person.Teaches implies no Group","predicate":"inv11","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{&{.{var0/Class}{~{field/Teaches{set of{sig/Class}}}}}{sig/Teacher}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='Insert', node=., parent=some, position=0)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Move', tree='{var0/Class}', parent=., position=0)\", \"(type='TreeInsert', tree='{field/Groups{->{sig/Person}{sig/Group}}}', parent=., position=1)\", \"(type='Move', tree='{.{sig/Person}{field/Teaches{set of{sig/Class}}}}', parent=&, position=0)\", \"(type='Update', node=sig/Group, value=sig/Teacher)\", \"(type='Move', tree='{sig/Group}', parent=&, position=1)\", \"(type='Update', node=sig/Person, value=var0/Class)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=~, position=0)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{&{.{var0/Class}{~{field/Teaches{set of{sig/Class}}}}}{sig/Teacher}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":33793700,"targetExpr":"all c : Class | (some c.Groups) implies (some (Teacher & c.~Teaches))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups implies some p:Person | p -> c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Person}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c: Class, s: Student | some g:Group | c -> s -> g in Groups implies some p:Person | p -> c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":34651500,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { no c:Class | some s:Student,g:Group | some t:Teacher | c->s->g in Groups and t->c not in Teaches } pred inv12 { } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{AND{!in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"no c:Class | some s:Student,g:Group | some t:Teacher | c->s->g in Groups and t->c not in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":24,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='TreeInsert', tree='{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}', parent=AND, position=2)\", \"(type='TreeDelete', tree='{!in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}')\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":24,"challenge":"YH3ANm7Y5Qe5dSYem","time":54586200,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | c not in Teacher.Teaches implies no c->Group } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{=>{!in{var0/Class}{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{no{->{var0/Class}{sig/Group}}}}}","nextExpr":"all c:Class | some c.Groups implies some Teacher&Teaches.c","sourceExpr":"all c:Class | c not in Teacher.Teaches implies no c->Group","predicate":"inv11","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}}","operations":"[\"(type='Insert', node=some, parent==>, position=0)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='Insert', node=., parent=some, position=0)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Move', tree='{var0/Class}', parent=., position=0)\", \"(type='Insert', node=field/Groups, parent=., position=1)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='Update', node=sig/Group, value=sig/Teacher)\", \"(type='Move', tree='{sig/Group}', parent=&, position=1)\", \"(type='Insert', node=->, parent=field/Groups, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=., position=0)\", \"(type='Move', tree='{var0/Class}', parent=., position=1)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{sig/Teacher}', parent=->, position=0)\", \"(type='Insert', node=sig/Group, parent=->, position=1)\", \"(type='Delete', node=.)\", \"(type='Delete', node=!in)\", \"(type='Delete', node=->)\", \"(type='Delete', node=no)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the existential quantifier ('some') expression.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{.{var0/Class}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}}","totalTED":14,"challenge":"YH3ANm7Y5Qe5dSYem","time":36406500,"targetExpr":"all c:Class | some c.Groups implies some Teacher&Teaches.c","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | (c->p->g in Groups) implies p in Teacher and c->p in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{var1/Person}{sig/Teacher}}{in{->{var0/Class}{var1/Person}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c:Class, p:Person, g:Group | (c->p->g in Groups) implies p in Teacher and c->p in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=some)\", \"(type='Update', node=in, value=one of)\", \"(type='Update', node=var1/Person, value=var3)\", \"(type='Insert', node=var3/Person, parent=->, position=0)\", \"(type='Delete', node=var1/Person)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":39682600,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some s:Student,g:Group | (c->s->g in Groups)) implies (some t:Person | t->c in Teaches) } pred inv12 { } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Person}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"(all c:Class | (some s:Student, g:Group | c->s->g in Groups) implies (some t:Person | t->c in Teaches))","predicate":"inv11","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":44384900,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person | some g:Group | c->p->g in Groups implies p in Teacher } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{var1/Person}{sig/Teacher}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c : Class, p : Person | some g : Group | c -> p -> g in Groups implies p in Teacher","predicate":"inv11","isNewNode":false,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='Update', node=in, value=one of)\", \"(type='Move', tree='{in{var1/Person}{sig/Teacher}}', parent=some, position=0)\", \"(type='TreeInsert', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=some, position=1)\", \"(type='Update', node=var1/Person, value=var3)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":11,"challenge":"YH3ANm7Y5Qe5dSYem","time":62333200,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | all s:Student | some g:Group,t:Teacher | (c->s->g) in Groups implies t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Student, g : Group | some t : Teacher | c->s->g in Groups implies t->c in Teaches","sourceExpr":"all c : Class, s : Student | some g : Group, t : Teacher | c->s->g in Groups implies t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":43680800,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class, s: Student | some g:Group, t:Teacher | c -> s -> g in Groups iff t -> c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{<=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"all c:Class, s: Student | some g:Group, t:Teacher | c -> s -> g in Groups iff t -> c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=<=>, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent=<=>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":34212500,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | some s:Person, g:Group | (c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"all c : Class | some p : Person, g : Group | c->p->g in Groups implies some t : Teacher | t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=some, value==>)\", \"(type='Insert', node=some, parent=some, position=0)\", \"(type='Move', tree='{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}', parent=some, position=1)\", \"(type='Move', tree='{one of{var1}{sig/Person}}', parent=some, position=0)\", \"(type='Insert', node=some, parent=some, position=1)\", \"(type='Move', tree='{one of{var2}{sig/Group}}', parent=some, position=0)\", \"(type='Move', tree='{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=some, position=1)\", \"(type='Delete', node==>)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":51562300,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups implies some t:Teacher | t -> c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c:Class,s:Student | some g:Group | c->s->g in Groups implies some t:Teacher | t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":63401400,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { no c:Class | no t:Teacher | some s:Student | some g:Group | (c->s->g in Groups) and (t->c in Teaches) } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{no{one of{var1}{sig/Teacher}}{some{one of{var2}{sig/Student}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"no c:Class | no t:Teacher | some s:Student | some g:Group | (c->s->g in Groups) and (t->c in Teaches)","predicate":"inv11","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Group)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Group, value=sig/Person)\", \"(type='Insert', node=AND, parent=AND, position=1)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var3/Group, value=var2/Group)\", \"(type='Update', node=var1/Person, value=var3/Person)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":14,"challenge":"YH3ANm7Y5Qe5dSYem","time":44877400,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class,s:Student,g:Group | some t:Teacher | c->s->g in Groups implies t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Student, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"all c : Class, s : Student, g : Group | some t : Teacher | c->s->g in Groups implies t->c in Teaches","predicate":"inv11","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent==>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":49821800,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies p in Teacher and p not in Student } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{!in{var1/Person}{sig/Student}}{in{var1/Person}{sig/Teacher}}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c:Class, p:Person, g:Group | c->p->g in Groups implies p in Teacher and p not in Student","predicate":"inv11","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=some)\", \"(type='Update', node=!in, value=one of)\", \"(type='Update', node=var1/Person, value=var3)\", \"(type='Update', node=sig/Student, value=sig/Teacher)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='TreeInsert', tree='{field/Teaches{set of{sig/Class}}}', parent=in, position=1)\", \"(type='Update', node=var1/Person, value=var3/Person)\", \"(type='Move', tree='{var1/Person}', parent=->, position=0)\", \"(type='Update', node=sig/Teacher, value=var0/Class)\", \"(type='Move', tree='{sig/Teacher}', parent=->, position=1)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":37784000,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | some s: Student, g:Group, t:Teacher | c -> s -> g in Groups iff t -> c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{<=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"all c:Class | some s: Student, g:Group, t:Teacher | c -> s -> g in Groups iff t -> c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=<=>, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent=<=>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":36278600,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { no c:Class | some s:Student,g:Group | some t:Teacher | (c->s->g) in Groups implies t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"no c:Class | some s:Student,g:Group | some t:Teacher | (c->s->g) in Groups implies t->c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent==>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":33150200,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | some s:Student,g:Group,t:Teacher | (c->s->g) in Groups and t->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{AND{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","sourceExpr":"all c:Class | some s:Student,g:Group,t:Teacher | (c->s->g) in Groups and t->c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=var2/Group, value=in)\", \"(type='Move', tree='{var2/Group}', parent=AND, position=0)\", \"(type='Insert', node=AND, parent=AND, position=1)\", \"(type='Update', node=set of, value=->)\", \"(type='Move', tree='{set of{sig/Class}}', parent=var2/Group, position=0)\", \"(type='Update', node=var1/Person, value=field/Groups)\", \"(type='Move', tree='{var1/Person}', parent=var2/Group, position=1)\", \"(type='Move', tree='{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{var3/Person}{sig/Teacher}}', parent=AND, position=1)\", \"(type='Update', node=var3/Person, value=var0/Class)\", \"(type='Move', tree='{var3/Person}', parent=set of, position=0)\", \"(type='Update', node=sig/Class, value=->)\", \"(type='Update', node=var0/Class, value=->)\", \"(type='Move', tree='{var0/Class}', parent=var1/Person, position=0)\", \"(type='Update', node=sig/Person, value=->)\", \"(type='Move', tree='{sig/Person}', parent=in, position=0)\", \"(type='Update', node=field/Groups, value=field/Teaches)\", \"(type='Update', node=var0/Class, value=var1/Person)\", \"(type='Move', tree='{var0/Class}', parent=sig/Class, position=0)\", \"(type='Update', node=->, value=var2/Group)\", \"(type='Move', tree='{->{var3/Person}{var0/Class}}', parent=sig/Class, position=1)\", \"(type='Update', node=field/Teaches, value=sig/Person)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=var0/Class, position=0)\", \"(type='Update', node=in, value=sig/Group)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=var0/Class, position=1)\", \"(type='Update', node=->, value=var3/Person)\", \"(type='Move', tree='{->{var1/Person}{var2/Group}}', parent=sig/Person, position=0)\", \"(type='Update', node=->, value=var0/Class)\", \"(type='Move', tree='{->{var0/Class}{->{var1/Person}{var2/Group}}}', parent=sig/Person, position=1)\", \"(type='Update', node=->, value=set of)\", \"(type='Update', node=sig/Group, value=sig/Class)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":32796600,"targetExpr":"all c : Class, s : Person, g : Group | some t : Person | c->s->g in Groups implies t->c in Teaches and t in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some s:Student,g:Group | (c->s->g in Groups)) and (some t:Teacher | t->c in Teaches) } pred inv12 { } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{AND{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","nextExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","sourceExpr":"all c:Class | (some s:Student,g:Group | (c->s->g in Groups)) and (some t:Teacher | t->c in Teaches)","predicate":"inv11","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"Near a solution! Instead of using conjunction operator ('and') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Class}}{=>{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":29809900,"targetExpr":"all x : Class | (some y : Person, z : Group | x->y->z in Groups) implies some v : Teacher | v->x in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies p in Teacher and p->c in Teaches } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{var1/Person}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","sourceExpr":"all c:Class, p:Person, g:Group | c->p->g in Groups implies p in Teacher and p->c in Teaches","predicate":"inv11","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=AND, value=some)\", \"(type='Update', node=in, value=one of)\", \"(type='Update', node=var1/Person, value=var3)\", \"(type='Update', node=var1/Person, value=var3/Person)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":4,"challenge":"YH3ANm7Y5Qe5dSYem","time":42068900,"targetExpr":"all c: Class, p:Person, g:Group | c->p->g in Groups => some t: Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { Teaches in Teacher -> some Class } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->some{sig/Teacher}{sig/Class}}}","nextExpr":"all t : Teacher | some t.Teaches.Groups","sourceExpr":"Teaches in Teacher -> some Class","predicate":"inv12","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Teacher}}', parent=all, position=0)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Move', tree='{in{field/Teaches{set of{sig/Class}}}{->some{sig/Teacher}{sig/Class}}}', parent=some, position=0)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=field/Groups, parent=in, position=1)\", \"(type='Insert', node=var0/Person, parent=., position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=., position=1)\", \"(type='Update', node=->some, value=->)\", \"(type='Move', tree='{->some{sig/Teacher}{sig/Class}}', parent=field/Groups, position=0)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Class, value=sig/Group)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Teacher\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","totalTED":12,"challenge":"YH3ANm7Y5Qe5dSYem","time":139184700,"targetExpr":"all t : Teacher | some t.Teaches.Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { some p:Person, c:Class | p -> Class in Teaches implies p in Teacher } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{=>{in{->{var0/Person}{sig/Class}}{field/Teaches{set of{sig/Class}}}}{in{var0/Person}{sig/Teacher}}}}}","nextExpr":"all t : Teacher | some t.Teaches.Groups","sourceExpr":"some p:Person, c:Class | p -> Class in Teaches implies p in Teacher","predicate":"inv12","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Update', node==>, value=.)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/Groups, parent==>, position=1)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Update', node=in, value=->)\", \"(type='Move', tree='{in{var0/Person}{sig/Teacher}}', parent=field/Groups, position=0)\", \"(type='Update', node=var0/Person, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Group)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Class}}')\", \"(type='Delete', node=sig/Class)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":40652100,"targetExpr":"all t : Teacher | some t.Teaches.Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no p:Person | p in Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { all p:Person | p in Teacher or p in Student } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all p:Teacher | some c:Class | p->c in Teaches } pred inv7 { all c:Class | some p:Teacher | p->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all c:Class, t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,p:Student,g:Group | t->c in Teaches and c->p->g in Groups } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Student}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var1/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","nextExpr":"all t : Teacher | some c : Class, p : Person, g : Group | t->c in Teaches and c->p->g in Groups","sourceExpr":"all t:Teacher | some c:Class,p:Student,g:Group | t->c in Teaches and c->p->g in Groups","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Person}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var1/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Person}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var1/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":37827800,"targetExpr":"all t : Teacher | some c : Class, p : Person, g : Group | t->c in Teaches and c->p->g in Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher, c:Class | some g:Group | c->g->t in Groups } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var2/Group}{var0/Person}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all t:Teacher | some t.Teaches.Groups","sourceExpr":"all t:Teacher, c:Class | some g:Group | c->g->t in Groups","predicate":"inv12","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","operations":"[\"(type='Move', tree='{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var2/Group}{var0/Person}}}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent=all, position=1)\", \"(type='Update', node=in, value=.)\", \"(type='Update', node=->, value=.)\", \"(type='Update', node=var1/Class, value=var0/Person)\", \"(type='Insert', node=field/Teaches, parent=->, position=1)\", \"(type='Update', node=->, value=set of)\", \"(type='Move', tree='{->{var2/Group}{var0/Person}}', parent=field/Teaches, position=0)\", \"(type='Update', node=var2/Group, value=sig/Class)\", \"(type='TreeDelete', tree='{one of{var2}{sig/Group}}')\", \"(type='Delete', node=var0/Person)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Class}}')\", \"(type='Delete', node=all)\"]","hint":"Keep going! It seems like the existential quantifier ('some') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","totalTED":14,"challenge":"YH3ANm7Y5Qe5dSYem","time":28840600,"targetExpr":"all t:Teacher | some t.Teaches.Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups implies t->c in Teaches } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{=>{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all t : Teacher | some c : Class, g : Group, p : Person | (c -> p -> g in Groups and t -> c in Teaches)","sourceExpr":"all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups implies t->c in Teaches","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node==>, value=AND)\"]","hint":"One step away from the solution! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using conjunction operator ('and') to combine two boolean expressions.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":30111400,"targetExpr":"all t : Teacher | some c : Class, g : Group, p : Person | (c -> p -> g in Groups and t -> c in Teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { some p:Person, c:Class | p -> c in Teaches implies p in Teacher } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{=>{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{var0/Person}{sig/Teacher}}}}}","nextExpr":"all t : Teacher | some t.Teaches.Groups","sourceExpr":"some p:Person, c:Class | p -> c in Teaches implies p in Teacher","predicate":"inv12","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Update', node==>, value=.)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/Groups, parent==>, position=1)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Update', node=in, value=->)\", \"(type='Move', tree='{in{var0/Person}{sig/Teacher}}', parent=field/Groups, position=0)\", \"(type='Update', node=var0/Person, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Group)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Class}}')\", \"(type='Delete', node=var1/Class)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":31788700,"targetExpr":"all t : Teacher | some t.Teaches.Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { all p:Person, c:Class | p -> c in Teaches implies p in Teacher } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{var0/Person}{sig/Teacher}}}}}","nextExpr":"all t : Teacher | some (t.Teaches.Groups)","sourceExpr":"all p:Person, c:Class | p -> c in Teaches implies p in Teacher","predicate":"inv12","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Update', node==>, value=.)\", \"(type='Update', node=in, value=.)\", \"(type='Insert', node=field/Groups, parent==>, position=1)\", \"(type='Move', tree='{var0/Person}', parent=in, position=0)\", \"(type='Update', node=in, value=->)\", \"(type='Move', tree='{in{var0/Person}{sig/Teacher}}', parent=field/Groups, position=0)\", \"(type='Update', node=var0/Person, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Group)\", \"(type='TreeDelete', tree='{one of{var1}{sig/Class}}')\", \"(type='Delete', node=var1/Class)\", \"(type='Delete', node=->)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{.{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":29898800,"targetExpr":"all t : Teacher | some (t.Teaches.Groups)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class | (some g:Group,p:Person | c->p->g in Groups) implies t->c in Teaches } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}","nextExpr":"all t: Teacher | some c: Class, g: Group, p: Person | c->p->g in Groups and t->c in Teaches","sourceExpr":"all t:Teacher | some c:Class | (some g:Group,p:Person | c->p->g in Groups) implies t->c in Teaches","predicate":"inv12","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node==>, value=some)\", \"(type='Move', tree='{one of{var2}{sig/Group}}', parent==>, position=0)\", \"(type='Insert', node=some, parent==>, position=1)\", \"(type='Move', tree='{one of{var3}{sig/Person}}', parent=some, position=0)\", \"(type='Insert', node=AND, parent=some, position=1)\", \"(type='Move', tree='{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=1)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":54802900,"targetExpr":"all t: Teacher | some c: Class, g: Group, p: Person | c->p->g in Groups and t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher, c:Class | some g:Group | c->t->g in Groups } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all t : Teacher | some c : Class, g : Group | c->t->g in Groups","sourceExpr":"all t : Teacher, c : Class | some g : Group | c -> t -> g in Groups","predicate":"inv12","isNewNode":false,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","totalTED":14,"challenge":"YH3ANm7Y5Qe5dSYem","time":96104300,"targetExpr":"all t:Teacher | some c:Class, g:Group, p:Person | t->c in Teaches and c->p->g in Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher, c:Class | some g:Group, p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all t: Teacher | some c: Class, g: Group, p: Person | c->p->g in Groups and t->c in Teaches","sourceExpr":"all t:Teacher, c:Class | some g:Group, p:Person | c->p->g in Groups and t->c in Teaches","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\"]","hint":"One step away from the solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Class}{->{var3/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":32450800,"targetExpr":"all t: Teacher | some c: Class, g: Group, p: Person | c->p->g in Groups and t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no p:Person | p in Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { all p:Person | p in Teacher or p in Student } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all p:Teacher | some c:Class | p->c in Teaches } pred inv7 { all c:Class | some p:Teacher | p->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all c:Class, t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some s:Student,c:Class,g:Group | t->c in Teaches and c->s->g in Groups } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Student}}{some{one of{var2}{sig/Class}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","nextExpr":"all t:Teacher | some p:Person,c:Class,g:Group | t->c in Teaches and c->p->g in Groups","sourceExpr":"all t:Teacher | some s:Student,c:Class,g:Group | t->c in Teaches and c->s->g in Groups","predicate":"inv12","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Class}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Class}}{some{one of{var3}{sig/Group}}{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":35357100,"targetExpr":"all t:Teacher | some p:Person,c:Class,g:Group | t->c in Teaches and c->p->g in Groups","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { } pred inv13 { all t:Teacher, s:Student | (t.Tutors & s.Tutors) = none all t:Teacher, s:Student | (t.Teaches & s.Teaches) = none } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{={&{.{var0/Person}{field/Tutors{set of{sig/Person}}}}{.{var1/Person}{field/Tutors{set of{sig/Person}}}}}{none}}}}{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{={&{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}{none}}}}}","nextExpr":"all t, s : Person | t->s in Tutors implies t in Teacher and s in Student","sourceExpr":"all t:Teacher, s:Student | (t.Tutors & s.Tutors) = none all t:Teacher, s:Student | (t.Teaches & s.Teaches) = none","predicate":"inv13","isNewNode":true,"srcDstTED":35,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var0}{sig/Teacher}}', parent=AND, position=0)\", \"(type='Insert', node=all, parent=AND, position=1)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{one of{var1}{sig/Student}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=&, value=in)\", \"(type='Move', tree='{&{.{var0/Person}{field/Tutors{set of{sig/Person}}}}{.{var1/Person}{field/Tutors{set of{sig/Person}}}}}', parent==>, position=0)\", \"(type='Update', node=&, value=AND)\", \"(type='Move', tree='{&{.{var0/Person}{field/Teaches{set of{sig/Class}}}}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}', parent==>, position=1)\", \"(type='Update', node=., value=->)\", \"(type='Move', tree='{field/Tutors{set of{sig/Person}}}', parent=&, position=1)\", \"(type='Update', node=., value=in)\", \"(type='Update', node=., value=in)\", \"(type='Update', node=sig/Person, value=var1/Person)\", \"(type='Move', tree='{sig/Person}', parent=., position=1)\", \"(type='Update', node=sig/Class, value=sig/Teacher)\", \"(type='Move', tree='{sig/Class}', parent=., position=1)\", \"(type='Update', node=sig/Class, value=sig/Student)\", \"(type='Move', tree='{sig/Class}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/Tutors)\", \"(type='Delete', node=var1/Person)\", \"(type='Delete', node=.)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/Teaches)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/Teaches)\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\", \"(type='TreeDelete', tree='{one of{var0}{sig/Teacher}}')\", \"(type='TreeDelete', tree='{one of{var1}{sig/Student}}')\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\", \"(type='Delete', node=all)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":35,"challenge":"YH3ANm7Y5Qe5dSYem","time":132005200,"targetExpr":"all t, s : Person | t->s in Tutors implies t in Teacher and s in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { some p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","nextExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","sourceExpr":"(some t,s : Person | t->s in Tutors implies( t in Teacher and s in Student))","predicate":"inv13","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":102123000,"targetExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { some p1:Person, p2:Person | p1 -> p2 in Tutors iff (p1 in Teacher and p2 in Student) } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{<=>{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}","nextExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","sourceExpr":"some p1:Person, p2:Person | p1 -> p2 in Tutors iff (p1 in Teacher and p2 in Student)","predicate":"inv13","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=<=>, value==>)\", \"(type='TreeInsert', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent=<=>, position=0)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}')\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":17,"challenge":"YH3ANm7Y5Qe5dSYem","time":61110700,"targetExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher | some g:Group, p:Person, c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all t:Teacher, s:Student | t->s in Tutors and t->t not in Tutors and s->s not in Tutors } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{AND{!in{->{var0/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{!in{->{var1/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}","nextExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","sourceExpr":"all t:Teacher, s:Student | t->s in Tutors and t->t not in Tutors and s->s not in Tutors","predicate":"inv13","isNewNode":true,"srcDstTED":18,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=!in, value=in)\", \"(type='Insert', node=AND, parent=AND, position=1)\", \"(type='Update', node=->, value=in)\", \"(type='Move', tree='{->{var1/Person}{var1/Person}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=1)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var1/Person, value=sig/Teacher)\", \"(type='Move', tree='{var1/Person}', parent=in, position=0)\", \"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Move', tree='{sig/Person}', parent=in, position=1)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=->)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/Tutors)\", \"(type='TreeDelete', tree='{field/Tutors{set of{sig/Person}}}')\", \"(type='Delete', node=!in)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":18,"challenge":"YH3ANm7Y5Qe5dSYem","time":36830000,"targetExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher | some g:Group, p:Person, c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all t:Teacher, s:Student | t->s in Tutors } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}","nextExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","sourceExpr":"all p1 : Teacher , p2 : Student | p1 -> p2 in Tutors","predicate":"inv13","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}', parent==>, position=1)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":53176700,"targetExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { } pred inv12 { } pred inv13 { all t:Teacher, s:Student | (t.Tutors & s.Tutors) = none } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{={&{.{var0/Person}{field/Tutors{set of{sig/Person}}}}{.{var1/Person}{field/Tutors{set of{sig/Person}}}}}{none}}}}","nextExpr":"all p1,p2:Person | p2 in p1.Tutors implies p1 in Teacher and p2 in Student","sourceExpr":"all t:Teacher, s:Student | (t.Tutors & s.Tutors) = none","predicate":"inv13","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{var1/Person}{.{var0/Person}{field/Tutors{set of{sig/Person}}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=&, value==>)\", \"(type='Move', tree='{&{.{var0/Person}{field/Tutors{set of{sig/Person}}}}{.{var1/Person}{field/Tutors{set of{sig/Person}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Insert', node=in, parent=&, position=0)\", \"(type='Insert', node=AND, parent=&, position=1)\", \"(type='Insert', node=var1/Person, parent=in, position=0)\", \"(type='Move', tree='{.{var0/Person}{field/Tutors{set of{sig/Person}}}}', parent=in, position=1)\", \"(type='TreeInsert', tree='{in{var0/Person}{sig/Teacher}}', parent=AND, position=0)\", \"(type='Update', node=., value=in)\", \"(type='Move', tree='{.{var1/Person}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=1)\", \"(type='Update', node=sig/Person, value=sig/Student)\", \"(type='Move', tree='{sig/Person}', parent=., position=1)\", \"(type='Delete', node=set of)\", \"(type='Delete', node=field/Tutors)\", \"(type='Delete', node=none)\", \"(type='Delete', node==)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{var1/Person}{.{var0/Person}{field/Tutors{set of{sig/Person}}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":15,"challenge":"YH3ANm7Y5Qe5dSYem","time":32442000,"targetExpr":"all p1,p2:Person | p2 in p1.Tutors implies p1 in Teacher and p2 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher | some g:Group, p:Person, c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all t:Teacher, s:Student | t->s in Tutors and t!=s } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{AND{!={var0/Person}{var1/Person}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}","nextExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","sourceExpr":"all t:Teacher, s:Student | t->s in Tutors and t!=s","predicate":"inv13","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='TreeInsert', tree='{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}', parent=AND, position=2)\", \"(type='TreeDelete', tree='{!={var0/Person}{var1/Person}}')\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Student}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":28181200,"targetExpr":"all p1,p2 : Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Student,c:Class | (some g:Group | c->s->g in Groups)","predicate":"inv14","isNewNode":true,"srcDstTED":21,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent==>, position=0)\", \"(type='TreeInsert', tree='{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}', parent==>, position=1)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":21,"challenge":"YH3ANm7Y5Qe5dSYem","time":119505500,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all c:Class,t:Teacher | all p:Person | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all p, q : Person, c : Class | (some g : Group | c->p->g in Groups) and q->c in Teaches implies q->p in Tutors","sourceExpr":"all c:Class,t:Teacher | all p:Person | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Person, value=sig/Class)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var2/Class)\", \"(type='Update', node=var0/Class, value=var2/Class)\", \"(type='Update', node=var2/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Class, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":42994500,"targetExpr":"all p, q : Person, c : Class | (some g : Group | c->p->g in Groups) and q->c in Teaches implies q->p in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (all t:Teacher | t->c in Teaches and t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Teacher}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (all t:Teacher | t->c in Teaches and t->s in Tutors)","predicate":"inv14","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":134449900,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { no p:Person | (some c:Class,g:Group | c->p->g in Groups and (some t:Teacher | t->c in Teaches and t->p not in Tutors)) } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{AND{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{AND{!in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}}","nextExpr":"all s:Person,c:Class,g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"no p:Person | (some c:Class,g:Group | c->p->g in Groups and (some t:Teacher | t->c in Teaches and t->p not in Tutors))","predicate":"inv14","isNewNode":true,"srcDstTED":14,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=field/Tutors, value=field/Teaches)\", \"(type='Update', node=field/Teaches, value=field/Tutors)\", \"(type='Update', node=var0/Person, value=var1/Class)\", \"(type='Update', node=var1/Class, value=var0/Person)\", \"(type='Update', node=sig/Person, value=sig/Class)\", \"(type='Update', node=sig/Class, value=sig/Person)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":14,"challenge":"YH3ANm7Y5Qe5dSYem","time":61400600,"targetExpr":"all s:Person,c:Class,g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Student | some c:Class, g:Group | c -> s -> g in Groups implies (some t:Person | t -> c in Teaches and t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Person}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"all s:Student | some c:Class, g:Group | c -> s -> g in Groups implies (some t:Person | t -> c in Teaches and t -> s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":37349100,"targetExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Student | some c:Class, g:Group | c -> s -> g in Groups implies (some t:Teacher | t -> c in Teaches and t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"all s:Student | some c:Class, g:Group | c -> s -> g in Groups implies (some t:Teacher | t -> c in Teaches and t -> s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":60031600,"targetExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no p:Person | p in Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { all p:Person | p in Teacher or p in Student } pred inv5 { some c:Class, p:Person | p -> c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher,c1,c2:Class | t->c1 in Teaches and t->c2 in Teaches implies c1 = c2 } pred inv9 { all c:Class,t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1 = t2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,p:Student,g:Group | t->c in Teaches and c->p->g in Groups } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies some t:Person | t->c in Teaches and t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{one of{var3}{sig/Person}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies some t:Person | t->c in Teaches and t->s in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":37067400,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher | some g:Group, p:Person, c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2: Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student, c:Class, t:Person |some g:Group | c->s->g in Groups implies t->c in Teaches and t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{some{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c: Class, t: Person, g: Group | c->s->g in Groups => (t->c in Teaches => t->s in Tutors)","sourceExpr":"all s:Student, c:Class, t:Person |some g:Group | c->s->g in Groups implies t->c in Teaches and t->s in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":63863000,"targetExpr":"all s: Person, c: Class, t: Person, g: Group | c->s->g in Groups => (t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all p:Person,c:Class,t:Teacher | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","sourceExpr":"all x : Person, y : Class, v : Teacher | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","predicate":"inv14","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":55889600,"targetExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all c:Class,s:Student,g:Group,t:Teacher | c->s->g in Groups implies t->c in Teaches and t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{all{one of{var3}{sig/Teacher}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all c : Class , s, t : Person | all g : Group | ((c->s->g in Groups) and (t->c in Teaches)) implies t->s in Tutors","sourceExpr":"all c:Class,s:Student,g:Group,t:Teacher | c->s->g in Groups implies t->c in Teaches and t->s in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Group, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Group)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{->{var3/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=1)\", \"(type='Update', node=var3/Person, value=var2/Person)\", \"(type='Update', node=var3/Person, value=var2/Person)\", \"(type='Update', node=var2/Group, value=var3/Group)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":72007800,"targetExpr":"all c : Class , s, t : Person | all g : Group | ((c->s->g in Groups) and (t->c in Teaches)) implies t->s in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { no p:Student | (some c:Class,g:Group | c->p->g in Groups and (some t:Teacher | t->c in Teaches and t->p not in Tutors)) } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Student}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{AND{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{AND{!in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}}","nextExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"no p:Student | (some c:Class,g:Group | c->p->g in Groups and (some t:Teacher | t->c in Teaches and t->p not in Tutors))","predicate":"inv14","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=field/Tutors, value=field/Teaches)\", \"(type='Update', node=field/Teaches, value=field/Tutors)\", \"(type='Update', node=var0/Person, value=var1/Class)\", \"(type='Update', node=var1/Class, value=var0/Person)\", \"(type='Update', node=sig/Person, value=sig/Class)\", \"(type='Update', node=sig/Class, value=sig/Person)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":15,"challenge":"YH3ANm7Y5Qe5dSYem","time":33079300,"targetExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (some t:Teacher | t->c in Teaches and t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{one of{var3}{sig/Teacher}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (some t:Teacher | t->c in Teaches and t->s in Tutors)","predicate":"inv14","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":4,"challenge":"YH3ANm7Y5Qe5dSYem","time":75465700,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no p:Person | p in Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { all p:Person | p in Teacher or p in Student } pred inv5 { some c:Class, p:Person | p -> c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher,c1,c2:Class | t->c1 in Teaches and t->c2 in Teaches implies c1 = c2 } pred inv9 { all c:Class,t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1 = t2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,p:Student,g:Group | t->c in Teaches and c->p->g in Groups } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class | (some g:Group | c->s->g in Groups) implies (some t:Person | t->c in Teaches and t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{one of{var3}{sig/Person}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Person,c:Class | (some g:Group | c->s->g in Groups) implies (some t:Person | t->c in Teaches and t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":59653500,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (all t:Person | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (all t:Person | t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":39298800,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all p:Person,t:Teacher | some c:Class | (some g:Group | c->p->g in Groups) and t->c in Teaches implies p->t in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Teacher}}{some{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all x, v : Person, y : Class | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","sourceExpr":"all p:Person,t:Teacher | some c:Class | (some g:Group | c->p->g in Groups) and t->c in Teaches implies p->t in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Delete', node=var1/Person)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":4,"challenge":"YH3ANm7Y5Qe5dSYem","time":37775700,"targetExpr":"all x, v : Person, y : Class | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no p:Person | p in Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { all p:Person | p in Teacher or p in Student } pred inv5 { some c:Class, p:Person | p -> c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher,c1,c2:Class | t->c1 in Teaches and t->c2 in Teaches implies c1 = c2 } pred inv9 { all c:Class,t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1 = t2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,p:Student,g:Group | t->c in Teaches and c->p->g in Groups } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class | (some g:Group | c->s->g in Groups) implies (some t:Teacher | t->c in Teaches and t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{one of{var3}{sig/Teacher}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Person,c:Class | (some g:Group | c->s->g in Groups) implies (some t:Teacher | t->c in Teaches and t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":44600100,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class| (some g:Group | c->s->g in Groups) and (all t:Teacher | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{AND{all{one of{var3}{sig/Teacher}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","nextExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","sourceExpr":"all s:Student,c:Class| (some g:Group | c->s->g in Groups) and (all t:Teacher | t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":25,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var3}{sig/Teacher}}', parent=AND, position=0)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=var3, value=var2)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='Move', tree='{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent=AND, position=1)\", \"(type='Update', node=var3/Person, value=var2/Person)\", \"(type='Update', node=var2, value=var3)\", \"(type='Update', node=var2/Group, value=var3/Group)\", \"(type='TreeDelete', tree='{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":25,"challenge":"YH3ANm7Y5Qe5dSYem","time":63436300,"targetExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,t:Teacher | (some c:Class,g:Group | c->s->g in Groups and t->c in Teaches) implies t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Teacher}}{=>{some{one of{var2}{sig/Class}}{some{one of{var3}{sig/Group}}{AND{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}","nextExpr":"all s, t : Person, c : Class, g : Group | c -> s -> g in Groups and t -> c in Teaches implies t -> s in Tutors","sourceExpr":"all s : Student, t: Teacher | (some c : Class, g : Group | c -> s -> g in Groups and t -> c in Teaches) implies (t -> s in Tutors)","predicate":"inv14","isNewNode":false,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node==>, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{one of{var2}{sig/Class}}', parent==>, position=0)\", \"(type='Insert', node=all, parent==>, position=1)\", \"(type='Move', tree='{one of{var3}{sig/Group}}', parent=all, position=0)\", \"(type='Insert', node==>, parent=all, position=1)\", \"(type='Move', tree='{AND{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Delete', node=some)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":71443800,"targetExpr":"all s, t : Person, c : Class, g : Group | c -> s -> g in Groups and t -> c in Teaches implies t -> s in Tutors","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all c:Class,s:Student,g:Group | c->s->g in Groups implies (all t:Teacher | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Teacher}}{=>{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"all c:Class,s:Student,g:Group | c->s->g in Groups implies (all t:Teacher | t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Class)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Class, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":32792300,"targetExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all c:Class | all t:Teacher | all p:Person | some g:Group | c->p->g in Groups and t->c in Teaches implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Person}}{some{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all c : Class , s, t : Person | all g : Group | ((c->s->g in Groups) and (t->c in Teaches)) implies t->s in Tutors","sourceExpr":"all c:Class | all t:Teacher | all p:Person | some g:Group | c->p->g in Groups and t->c in Teaches implies t->p in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Delete', node=var2/Person)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":39626600,"targetExpr":"all c : Class , s, t : Person | all g : Group | ((c->s->g in Groups) and (t->c in Teaches)) implies t->s in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all c:Class,t:Teacher,p:Person | some g:Group | c->p->g in Groups implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Person}}{some{one of{var3}{sig/Group}}{=>{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all c : Class , s, t : Person | all g : Group | ((c->s->g in Groups) and (t->c in Teaches)) implies t->s in Tutors","sourceExpr":"all c:Class,t:Teacher,p:Person | some g:Group | c->p->g in Groups implies t->p in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='Move', tree='{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent=AND, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=1)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Delete', node=var2/Person)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{AND{in{->{var0/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":36550800,"targetExpr":"all c : Class , s, t : Person | all g : Group | ((c->s->g in Groups) and (t->c in Teaches)) implies t->s in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person | some c:Class |(some g:Group | c -> s -> g in Groups) implies (some t:Person | t -> c in Teaches and t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{one of{var3}{sig/Person}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Person | some c:Class |(some g:Group | c -> s -> g in Groups) implies (some t:Person | t -> c in Teaches and t -> s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":42332400,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person | some c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Person | some c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\"]","hint":"One step away from the solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":31227300,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class,t:Teacher | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","sourceExpr":"all s : Student, c : Class, t : Teacher | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","predicate":"inv14","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":41037800,"targetExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | some g:Group,t:Teacher | c->s->g in Groups and t->c in Teaches implies t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{some{one of{var3}{sig/Teacher}}{=>{AND{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all s : Person, c : Class, g : Group, t : Person | c -> s -> g in Groups and t -> c in Teaches implies t -> s in Tutors","sourceExpr":"all s : Student, c : Class | some g : Group, t : Teacher | (c -> s -> g in Groups and t -> c in Teaches) implies (t -> s in Tutors)","predicate":"inv14","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":4,"challenge":"YH3ANm7Y5Qe5dSYem","time":70101300,"targetExpr":"all s : Person, c : Class, g : Group, t : Person | c -> s -> g in Groups and t -> c in Teaches implies t -> s in Tutors","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all t:Teacher, s:Student,c:Class | t->s in Tutors implies (some g:Group | c->s->g in Groups ) and t->c in Teaches } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Class}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}}}","nextExpr":"all p1, p2 : Person, c : Class | ((some g : Group | c -> p2 -> g in Groups) and p1 -> c in Teaches) implies p1 -> p2 in Tutors","sourceExpr":"all t:Teacher, s:Student,c:Class | t->s in Tutors implies (some g:Group | c->s->g in Groups ) and t->c in Teaches","predicate":"inv14","isNewNode":true,"srcDstTED":16,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='TreeInsert', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=2)\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}')\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":16,"challenge":"YH3ANm7Y5Qe5dSYem","time":35299700,"targetExpr":"all p1, p2 : Person, c : Class | ((some g : Group | c -> p2 -> g in Groups) and p1 -> c in Teaches) implies p1 -> p2 in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all p:Student,t:Teacher | some c:Class | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Teacher}}{some{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all x, v : Person, y : Class | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","sourceExpr":"all p:Student,t:Teacher | some c:Class | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":34594300,"targetExpr":"all x, v : Person, y : Class | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all c:Class,s:Student | (some g:Group | c->s->g in Groups) implies (all t:Person | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{=>{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all c:Class,s:Student | (some g:Group | c->s->g in Groups) implies (all t:Person | t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Class)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Class, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":38638900,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all t:Teacher, s:Student,c:Class | (some g:Group | c->s->g in Groups ) and t->c in Teaches implies t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all p1, p2 : Person, c : Class | ((some g : Group | c -> p2 -> g in Groups) and p1 -> c in Teaches) implies p1 -> p2 in Tutors","sourceExpr":"all t:Teacher, s:Student,c:Class | (some g:Group | c->s->g in Groups ) and t->c in Teaches implies t->s in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Person)\"]","hint":"Near a solution! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var0/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var1/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":38783000,"targetExpr":"all p1, p2 : Person, c : Class | ((some g : Group | c -> p2 -> g in Groups) and p1 -> c in Teaches) implies p1 -> p2 in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person | some c:Class | (some g:Group | c -> s -> g in Groups) implies (some t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{some{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s:Person | some c:Class | (some g:Group | c -> s -> g in Groups) implies (some t:Person | t -> c in Teaches implies t -> s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":35444600,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { no p:Person | (some c:Class,g:Group | c->p->g in Groups and (some t:Teacher | t->c in Teaches and p->t not in Tutors)) } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{AND{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{AND{!in{->{var0/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}}","nextExpr":"all s : Person, c : Class, g : Group | (c -> s -> g in Groups => all t : Person | t -> c in Teaches => t -> s in Tutors)","sourceExpr":"no p:Person | (some c:Class,g:Group | c->p->g in Groups and (some t:Teacher | t->c in Teaches and p->t not in Tutors))","predicate":"inv14","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=field/Tutors, value=field/Teaches)\", \"(type='Update', node=field/Teaches, value=field/Tutors)\", \"(type='Insert', node=var1/Class, parent=->, position=2)\", \"(type='Update', node=var1/Class, value=var0/Person)\", \"(type='Update', node=sig/Person, value=sig/Class)\", \"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":15,"challenge":"YH3ANm7Y5Qe5dSYem","time":37151100,"targetExpr":"all s : Person, c : Class, g : Group | (c -> s -> g in Groups => all t : Person | t -> c in Teaches => t -> s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) implies (all t:Teacher | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Teacher}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s :Student, c:Class | (some g:Group | c->s->g in Groups) implies (all t:Teacher| t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":41074300,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { all c:Class,p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { all c:Class,s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some c:Class,g:Group,p:Person | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class | (some g:Group | c->s->g in Groups) implies (all t:Teacher | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Teacher}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all s : Person, c : Class | (some g : Group | c->s->g in Groups) implies (all t : Teacher | t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":false,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Teacher, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":44450600,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all c:Class,s:Student | (some g:Group | c->s->g in Groups) implies (all t:Teacher | t->c in Teaches implies t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{=>{some{one of{var2}{sig/Group}}{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Teacher}}{=>{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","nextExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","sourceExpr":"all c:Class,s:Student | (some g:Group | c->s->g in Groups) implies (all t:Teacher | t->c in Teaches implies t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Class)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Class, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{=>{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":34072100,"targetExpr":"all p : Person, c : Class | (some g : Group | c->p->g in Groups) implies (all t : Person | t->c in Teaches implies t->p in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all p:Person,t:Teacher | some c:Class | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Teacher}}{some{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all p, q : Person, c : Class | (some g : Group | c->p->g in Groups) and q->c in Teaches implies q->p in Tutors","sourceExpr":"all p:Person,t:Teacher | some c:Class | (some g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Near a solution! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":33713700,"targetExpr":"all p, q : Person, c : Class | (some g : Group | c->p->g in Groups) and q->c in Teaches implies q->p in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person | some c:Class, g:Group | c -> s -> g in Groups implies (some t:Person | t -> c in Teaches and t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Person}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"all p : Person | some c : Class, g : Group | c->p->g in Groups implies some q : Person | q->c in Teaches and q->p in Tutors","predicate":"inv14","isNewNode":false,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":4,"challenge":"YH3ANm7Y5Qe5dSYem","time":60091700,"targetExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone c:Class | t->c in Teaches } pred inv9 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv10 { all c:Class,s:Student| some g:Group | c->s->g in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | c->p->g in Groups) implies some t:Teacher | t->c in Teaches } pred inv12 { all t:Teacher | some c:Class,p:Person,g:Group | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all c:Class,s:Student,g:Group | c->s->g in Groups implies (all t:Teacher | t->c in Teaches and t->s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Student}}{all{one of{var2}{sig/Group}}{=>{in{->{var0/Class}{->{var1/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Teacher}}{AND{in{->{var3/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","sourceExpr":"all c:Class,s:Student,g:Group | c->s->g in Groups implies (all t:Teacher | t->c in Teaches and t->s in Tutors)","predicate":"inv14","isNewNode":true,"srcDstTED":8,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Class)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Class, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":35883300,"targetExpr":"all s: Person, c:Class, g:Group | (c->s->g in Groups => all t:Person | t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all p:Person,c:Class,t:Teacher | (all g:Group | c->p->g in Groups) and t->c in Teaches implies t->p in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Teacher}}{=>{AND{all{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all s: Person, c: Class, t: Person, g: Group | c->s->g in Groups => (t->c in Teaches => t->s in Tutors)","sourceExpr":"all s : Person, c : Class, t : Teacher | (all g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","predicate":"inv14","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node==>, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{one of{var3}{sig/Group}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}', parent==>, position=0)\", \"(type='Insert', node==>, parent==>, position=1)\", \"(type='Move', tree='{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Delete', node=all)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using implication operator ('=>') to specify that if the left side is true, then the right side must also be true, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":63841600,"targetExpr":"all s: Person, c: Class, t: Person, g: Group | c->s->g in Groups => (t->c in Teaches => t->s in Tutors)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person | some c:Class, g:Group | c -> s -> g in Groups implies (some t:Teacher | t -> c in Teaches and t -> s in Tutors) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{some{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{some{one of{var3}{sig/Teacher}}{AND{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s : Person, c : Class, g : Group | (c -> s -> g in Groups => all t : Person | t -> c in Teaches => t -> s in Tutors)","sourceExpr":"all p : Person | some c : Class, g : Group | c->p->g in Groups implies some t : Teacher | t->c in Teaches and t->p in Tutors","predicate":"inv14","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=AND, value==>)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{all{one of{var3}{sig/Person}}{=>{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var3/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":71054700,"targetExpr":"all s : Person, c : Class, g : Group | (c -> s -> g in Groups => all t : Person | t -> c in Teaches => t -> s in Tutors)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all c:Class,t:Teacher,s:Student | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Student}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var0/Class}{->{var2/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","nextExpr":"all x, v : Person, y : Class | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","sourceExpr":"all c:Class,t:Teacher,s:Student | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Student, value=sig/Class)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var2/Class)\", \"(type='Update', node=var0/Class, value=var2/Class)\", \"(type='Update', node=var2/Person, value=var0/Person)\"]","hint":"Keep going! Instead of using signature of type Class, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Class}}{=>{AND{in{->{var1/Person}{var2/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var2/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":38826700,"targetExpr":"all x, v : Person, y : Class | (some z : Group | y->x->z in Groups) and v->y in Teaches implies v->x in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student,c:Class | (some g:Group | c->s->g in Groups) and (all t:Teacher | t->c in Teaches) } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{AND{all{one of{var3}{sig/Teacher}}{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}}}","nextExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","sourceExpr":"all s:Student,c:Class | (some g:Group | c->s->g in Groups) and (all t:Teacher | t->c in Teaches)","predicate":"inv14","isNewNode":true,"srcDstTED":17,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=AND, value=all)\", \"(type='Move', tree='{one of{var3}{sig/Teacher}}', parent=AND, position=0)\", \"(type='Insert', node==>, parent=AND, position=1)\", \"(type='Update', node=var3, value=var2)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Insert', node=AND, parent==>, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Move', tree='{in{->{var3/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}', parent=AND, position=0)\", \"(type='Move', tree='{some{one of{var2}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var2/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}', parent=AND, position=1)\", \"(type='Update', node=var3/Person, value=var2/Person)\", \"(type='Update', node=var2, value=var3)\", \"(type='Update', node=var2/Group, value=var3/Group)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{some{one of{var3}{sig/Group}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":17,"challenge":"YH3ANm7Y5Qe5dSYem","time":37432700,"targetExpr":"all s : Person, c : Class, t : Person | (some g : Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher | some g:Group, p:Person, c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2: Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student, c:Class, t:Person |some g:Group | c->s->g in Groups implies t->c in Teaches implies t->s in Tutors } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{some{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","nextExpr":"all s: Person, c: Class, t: Person, g: Group | c->s->g in Groups => (t->c in Teaches => t->s in Tutors)","sourceExpr":"all s:Student, c:Class, t:Person |some g:Group | c->s->g in Groups implies t->c in Teaches implies t->s in Tutors","predicate":"inv14","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Person)\", \"(type='Update', node=some, value=all)\"]","hint":"Near a solution! Instead of using signature of type Student, try using signature of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Group}}{=>{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}{=>{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":37617600,"targetExpr":"all s: Person, c: Class, t: Person, g: Group | c->s->g in Groups => (t->c in Teaches => t->s in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher, c1,c2 :Class | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher , c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class, s:Student | some g:Group | c->s->g in Groups } pred inv11 { all c:Class, p:Person, g:Group | c->p->g in Groups implies (some t:Teacher| t->c in Teaches) } pred inv12 { all t:Teacher | some g:Group, p:Person, c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2: Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Student, c:Class | some t:Teacher, g:Group | t->s in Tutors and c->s->g in Groups implies t->c in Teaches } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Student}}{all{one of{var1}{sig/Class}}{some{one of{var2}{sig/Teacher}}{some{one of{var3}{sig/Group}}{=>{AND{in{->{var2/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var1/Class}{->{var0/Person}{var3/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}}}}","nextExpr":"all c : Class, g : Group, p1, p2 : Person | (p1->c in Teaches and c->p2->g in Groups) implies (p1->p2 in Tutors)","sourceExpr":"all s:Student, c:Class | some t:Teacher, g:Group | t->s in Tutors and c->s->g in Groups implies t->c in Teaches","predicate":"inv14","isNewNode":true,"srcDstTED":15,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Group}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var0/Class}{->{var3/Person}{var1/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=sig/Student, value=sig/Class)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Class, value=sig/Group)\", \"(type='Update', node=some, value=all)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Update', node=sig/Group, value=sig/Person)\", \"(type='Update', node=field/Teaches, value=field/Tutors)\", \"(type='Update', node=field/Tutors, value=field/Teaches)\", \"(type='Update', node=var1/Class, value=var3/Person)\", \"(type='Update', node=var0/Person, value=var0/Class)\", \"(type='Update', node=var1/Class, value=var0/Class)\", \"(type='Update', node=sig/Class, value=sig/Person)\", \"(type='Update', node=sig/Person, value=sig/Class)\", \"(type='Update', node=var0/Person, value=var3/Person)\", \"(type='Update', node=var3/Group, value=var1/Group)\"]","hint":"Keep going! Instead of using signature of type Student, try using signature of type Class to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Group}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var0/Class}{->{var3/Person}{var1/Group}}}{field/Groups{->{sig/Person}{sig/Group}}}}}{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":15,"challenge":"YH3ANm7Y5Qe5dSYem","time":34880900,"targetExpr":"all c : Class, g : Group, p1, p2 : Person | (p1->c in Teaches and c->p2->g in Groups) implies (p1->p2 in Tutors)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { (all p:Person | p in Teacher) or (all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher) or (all p1, p2, p3:Person | p1->p2 in Tutors and p2->p3 in Tutors implies p1 in Teacher) }","sourceAST":"{OR{all{one of{var0}{sig/Person}}{in{var0/Person}{sig/Teacher}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}}}}}","nextExpr":"all p1 : Person | (some p2 : Teacher | p2 -> p1 in Tutors) or (some p2, p3 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p3 in Teacher) or (some p2, p3, p4 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p4 -> p3 in Tutors and p4 in Teacher)","sourceExpr":"(all p:Person | p in Teacher) or (all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher) or (all p1, p2, p3:Person | p1->p2 in Tutors and p2->p3 in Tutors implies p1 in Teacher)","predicate":"inv15","isNewNode":true,"srcDstTED":39,"targetAST":"{all{one of{var0}{sig/Person}}{OR{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='Move', tree='{OR{all{one of{var0}{sig/Person}}{in{var0/Person}{sig/Teacher}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}}}}}', parent=all, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=var0, value=var1)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Insert', node=field/Tutors, parent=in, position=1)\", \"(type='Update', node==>, value=AND)\", \"(type='Update', node=all, value=some)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Person}', parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Tutors, position=0)\", \"(type='TreeInsert', tree='{in{var2/Person}{sig/Teacher}}', parent==>, position=2)\", \"(type='Update', node==>, value=AND)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{sig/Teacher}', parent=set of, position=0)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Insert', node=field/Tutors, parent=in, position=1)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='TreeInsert', tree='{in{->{var3/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=2)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Move', tree='{var1/Person}', parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Tutors, position=0)\", \"(type='Update', node=var1/Person, value=var3/Person)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{sig/Teacher}', parent=set of, position=0)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var3/Person, value=var1/Person)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Person\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Person}}{OR{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":39,"challenge":"YH3ANm7Y5Qe5dSYem","time":119469000,"targetExpr":"all p1 : Person | (some p2 : Teacher | p2 -> p1 in Tutors) or (some p2, p3 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p3 in Teacher) or (some p2, p3, p4 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p4 -> p3 in Tutors and p4 in Teacher)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (some p3: Person | (p2->p3 in Tutors and p3 in Teacher) or (some p4:Person | p3->p4 in Tutors and p4 in Teacher )) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{some{one of{var2}{sig/Person}}{OR{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}{some{one of{var3}{sig/Person}}{AND{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}}}","nextExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","sourceExpr":"all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (some p3: Person | (p2->p3 in Tutors and p3 in Teacher) or (some p4:Person | p3->p4 in Tutors and p4 in Teacher ))","predicate":"inv15","isNewNode":true,"srcDstTED":30,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Person}}', parent=some, position=0)\", \"(type='Update', node=OR, value=AND)\", \"(type='Move', tree='{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{some{one of{var2}{sig/Person}}{OR{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}{some{one of{var3}{sig/Person}}{AND{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}', parent=some, position=1)\", \"(type='Insert', node=OR, parent=OR, position=0)\", \"(type='Move', tree='{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}', parent=OR, position=1)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Move', tree='{in{var2/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Insert', node=OR, parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var3/Person, value=var0/Person)\", \"(type='Move', tree='{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}', parent=OR, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Person}}', parent=OR, position=1)\", \"(type='Update', node=var2, value=var2/Person)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Delete', node=var2/Person)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{one of{var3}{sig/Person}}')\", \"(type='TreeDelete', tree='{in{var3/Person}{sig/Teacher}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\", \"(type='Delete', node=OR)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":30,"challenge":"YH3ANm7Y5Qe5dSYem","time":36443400,"targetExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { all p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{OR{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}}","nextExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","sourceExpr":"all p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher))","predicate":"inv15","isNewNode":true,"srcDstTED":27,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node==>, value=in)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Move', tree='{var1/Person}', parent==>, position=0)\", \"(type='Update', node=OR, value=.)\", \"(type='Move', tree='{var0/Person}', parent=OR, position=0)\", \"(type='Update', node==>, value=^)\", \"(type='Move', tree='{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}', parent=OR, position=1)\", \"(type='Update', node=in, value=~)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/Tutors{set of{sig/Person}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{->{var1/Person}{var2/Person}}')\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node=sig/Teacher)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{in{var1/Person}{sig/Teacher}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/Person}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":27,"challenge":"YH3ANm7Y5Qe5dSYem","time":36329500,"targetExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (all p3: Person | (p2->p3 in Tutors and p3 in Teacher) or (some p4:Person | p3->p4 in Tutors and p4 in Teacher )) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{all{one of{var2}{sig/Person}}{OR{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}{some{one of{var3}{sig/Person}}{AND{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}}}","nextExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","sourceExpr":"all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (all p3: Person | (p2->p3 in Tutors and p3 in Teacher) or (some p4:Person | p3->p4 in Tutors and p4 in Teacher ))","predicate":"inv15","isNewNode":true,"srcDstTED":30,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Person}}', parent=some, position=0)\", \"(type='Update', node=OR, value=AND)\", \"(type='Move', tree='{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{all{one of{var2}{sig/Person}}{OR{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}{some{one of{var3}{sig/Person}}{AND{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}', parent=some, position=1)\", \"(type='Insert', node=OR, parent=OR, position=0)\", \"(type='Move', tree='{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}', parent=OR, position=1)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Move', tree='{in{var2/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Insert', node=OR, parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Update', node=var3/Person, value=var0/Person)\", \"(type='Move', tree='{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}', parent=OR, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Person}}', parent=OR, position=1)\", \"(type='Update', node=var2, value=var2/Person)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Delete', node=var2/Person)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{one of{var3}{sig/Person}}')\", \"(type='TreeDelete', tree='{in{var3/Person}{sig/Teacher}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\", \"(type='Delete', node=OR)\", \"(type='Delete', node=all)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":30,"challenge":"YH3ANm7Y5Qe5dSYem","time":37249800,"targetExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { Teacher in Person.*Tutors }","sourceAST":"{in{sig/Teacher}{.{sig/Person}{*{field/Tutors{set of{sig/Person}}}}}}","nextExpr":"all p:Person | some Teacher&(^Tutors).p","sourceExpr":"Teacher in Person.*Tutors","predicate":"inv15","isNewNode":false,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Person}}{some{&{.{^{field/Tutors{set of{sig/Person}}}}{var0/Person}}{sig/Teacher}}}}","operations":"[\"(type='Update', node=in, value=all)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Insert', node=some, parent=in, position=1)\", \"(type='Update', node=sig/Teacher, value=var0)\", \"(type='Move', tree='{sig/Teacher}', parent=one of, position=0)\", \"(type='Move', tree='{sig/Person}', parent=one of, position=1)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='Insert', node=sig/Teacher, parent=&, position=1)\", \"(type='Update', node=*, value=^)\", \"(type='Move', tree='{*{field/Tutors{set of{sig/Person}}}}', parent=., position=0)\", \"(type='Insert', node=var0/Person, parent=., position=1)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{&{.{^{field/Tutors{set of{sig/Person}}}}{var0/Person}}{sig/Teacher}}}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":148958600,"targetExpr":"all p:Person | some Teacher&(^Tutors).p","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { all p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (all p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{OR{all{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}}}}}","nextExpr":"all p:Person | some t :Teacher | t in ^Tutors.p","sourceExpr":"all p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (all p3:Person | p2 -> p3 in Tutors implies p3 in Teacher))","predicate":"inv15","isNewNode":true,"srcDstTED":27,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{^{field/Tutors{set of{sig/Person}}}}{var0/Person}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node==>, value=in)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Move', tree='{var1/Person}', parent==>, position=0)\", \"(type='Update', node=OR, value=.)\", \"(type='Update', node=in, value=^)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=OR, position=0)\", \"(type='Move', tree='{var0/Person}', parent=OR, position=1)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/Tutors{set of{sig/Person}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{->{var1/Person}{var2/Person}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/Person}}')\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=all)\", \"(type='Delete', node=sig/Teacher)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{in{var1/Person}{sig/Teacher}}')\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{^{field/Tutors{set of{sig/Person}}}}{var0/Person}}}}}","totalTED":27,"challenge":"YH3ANm7Y5Qe5dSYem","time":38493400,"targetExpr":"all p:Person | some t :Teacher | t in ^Tutors.p","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { Teacher in Person.Tutors }","sourceAST":"{in{sig/Teacher}{.{sig/Person}{field/Tutors{set of{sig/Person}}}}}","nextExpr":"all p:Person | some Teacher&(^Tutors).p","sourceExpr":"Teacher in Person.Tutors","predicate":"inv15","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Person}}{some{&{.{^{field/Tutors{set of{sig/Person}}}}{var0/Person}}{sig/Teacher}}}}","operations":"[\"(type='Update', node=in, value=all)\", \"(type='Insert', node=one of, parent=in, position=0)\", \"(type='Insert', node=some, parent=in, position=1)\", \"(type='Update', node=sig/Teacher, value=var0)\", \"(type='Move', tree='{sig/Teacher}', parent=one of, position=0)\", \"(type='Move', tree='{sig/Person}', parent=one of, position=1)\", \"(type='Insert', node=&, parent=some, position=0)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='Insert', node=sig/Teacher, parent=&, position=1)\", \"(type='Insert', node=^, parent=., position=0)\", \"(type='Insert', node=var0/Person, parent=., position=1)\", \"(type='Move', tree='{field/Tutors{set of{sig/Person}}}', parent=^, position=0)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{&{.{^{field/Tutors{set of{sig/Person}}}}{var0/Person}}{sig/Teacher}}}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":45642200,"targetExpr":"all p:Person | some Teacher&(^Tutors).p","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1,p2,p3:Person | p1->p2 in Tutors and p2->p3 in Tutors implies p3 in Teacher }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{=>{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var2/Person}{sig/Teacher}}}}}}","nextExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","sourceExpr":"all p1, p2, p3 : Person | (p1 -> p2 in Tutors and p2 -> p3 in Tutors) implies p3 in Teacher","predicate":"inv15","isNewNode":false,"srcDstTED":22,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=in)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Update', node=var2, value=var1/Person)\", \"(type='Move', tree='{var2}', parent=all, position=0)\", \"(type='Update', node=AND, value=.)\", \"(type='Move', tree='{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}', parent=all, position=1)\", \"(type='Move', tree='{var0/Person}', parent=AND, position=0)\", \"(type='Insert', node=^, parent=AND, position=1)\", \"(type='Update', node=in, value=~)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=^, position=0)\", \"(type='TreeDelete', tree='{->{var1/Person}{var2/Person}}')\", \"(type='Delete', node=var1/Person)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/Tutors{set of{sig/Person}}}')\", \"(type='Delete', node=in)\", \"(type='Delete', node=sig/Person)\", \"(type='Delete', node=one of)\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node==>)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":22,"challenge":"YH3ANm7Y5Qe5dSYem","time":68407100,"targetExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { some p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) and p1 not in Student }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{!in{var0/Person}{sig/Student}}{OR{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}}}","nextExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","sourceExpr":"some p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) and p1 not in Student","predicate":"inv15","isNewNode":true,"srcDstTED":30,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=some, parent=some, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Person}}', parent=some, position=0)\", \"(type='Update', node==>, value=AND)\", \"(type='Move', tree='{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{!in{var0/Person}{sig/Student}}{OR{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}', parent=some, position=1)\", \"(type='Insert', node=OR, parent==>, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Person}}', parent=OR, position=1)\", \"(type='Insert', node=OR, parent=AND, position=0)\", \"(type='Move', tree='{in{var1/Person}{sig/Teacher}}', parent=AND, position=1)\", \"(type='Update', node=var2, value=var1/Person)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Insert', node=field/Tutors, parent=in, position=1)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=0)\", \"(type='Update', node=!in, value=in)\", \"(type='Move', tree='{!in{var0/Person}{sig/Student}}', parent=AND, position=1)\", \"(type='Update', node=var0/Person, value=var2/Person)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Move', tree='{var1/Person}', parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Tutors, position=0)\", \"(type='Update', node=sig/Student, value=sig/Teacher)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{sig/Teacher}', parent=set of, position=0)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=some)\", \"(type='Delete', node=OR)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":30,"challenge":"YH3ANm7Y5Qe5dSYem","time":38883200,"targetExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1: Person | p1 in Teacher or (some p2:Person | p1->p2 in Tutors => (p2 in Teacher or (some p3:Person | p2->p3 in Tutors and p3 in Teacher))) }","sourceAST":"{all{one of{var0}{sig/Person}}{OR{in{var0/Person}{sig/Teacher}}{some{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{OR{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}}}","nextExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","sourceExpr":"all p1: Person | p1 in Teacher or (some p2:Person | p1->p2 in Tutors => (p2 in Teacher or (some p3:Person | p2->p3 in Tutors and p3 in Teacher)))","predicate":"inv15","isNewNode":true,"srcDstTED":28,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Move', tree='{some{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{OR{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}', parent=all, position=1)\", \"(type='Update', node=OR, value=in)\", \"(type='Move', tree='{OR{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}', parent=some, position=1)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Move', tree='{var1/Person}', parent=OR, position=0)\", \"(type='Update', node=some, value=.)\", \"(type='Update', node=var2, value=var0/Person)\", \"(type='Move', tree='{var2}', parent=some, position=0)\", \"(type='Update', node=AND, value=^)\", \"(type='Update', node=in, value=~)\", \"(type='Delete', node=sig/Teacher)\", \"(type='Delete', node=in)\", \"(type='Delete', node=sig/Person)\", \"(type='Delete', node=one of)\", \"(type='TreeDelete', tree='{->{var1/Person}{var2/Person}}')\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='TreeDelete', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}')\", \"(type='Delete', node==>)\", \"(type='TreeDelete', tree='{in{var0/Person}{sig/Teacher}}')\", \"(type='Delete', node=OR)\"]","hint":"Keep going! It seems like the existential quantifier ('some') is not in the right place. Try moving it to the inside of the universal quantifier ('all') expression. Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":28,"challenge":"YH3ANm7Y5Qe5dSYem","time":43143000,"targetExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { some p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{OR{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}}","nextExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","sourceExpr":"some p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher))","predicate":"inv15","isNewNode":true,"srcDstTED":27,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node==>, value=in)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Move', tree='{var1/Person}', parent==>, position=0)\", \"(type='Update', node=OR, value=.)\", \"(type='Move', tree='{var0/Person}', parent=OR, position=0)\", \"(type='Update', node==>, value=^)\", \"(type='Move', tree='{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}', parent=OR, position=1)\", \"(type='Update', node=in, value=~)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/Tutors{set of{sig/Person}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{->{var1/Person}{var2/Person}}')\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node=sig/Teacher)\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{in{var1/Person}{sig/Teacher}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/Person}}')\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":27,"challenge":"YH3ANm7Y5Qe5dSYem","time":36783900,"targetExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { (all p:Person | p in Teacher) or (all p1,p2:Person | p1->p2 in Tutors implies p2 in Teacher) or (all p1, p2, p3:Person | p1->p2 in Tutors and p2->p3 in Tutors implies p3 in Teacher) }","sourceAST":"{OR{all{one of{var0}{sig/Person}}{in{var0/Person}{sig/Teacher}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var3/Person}{sig/Teacher}}}}}}}","nextExpr":"all p1 : Person | (some p2 : Teacher | p2 -> p1 in Tutors) or (some p2, p3 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p3 in Teacher) or (some p2, p3, p4 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p4 -> p3 in Tutors and p4 in Teacher)","sourceExpr":"(all p:Person | p in Teacher) or (all p1,p2:Person | p1->p2 in Tutors implies p2 in Teacher) or (all p1, p2, p3:Person | p1->p2 in Tutors and p2->p3 in Tutors implies p3 in Teacher)","predicate":"inv15","isNewNode":true,"srcDstTED":37,"targetAST":"{all{one of{var0}{sig/Person}}{OR{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='Move', tree='{OR{all{one of{var0}{sig/Person}}{in{var0/Person}{sig/Teacher}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{all{one of{var3}{sig/Person}}{=>{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var3/Person}{sig/Teacher}}}}}}}', parent=all, position=1)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=var0, value=var1)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Insert', node=field/Tutors, parent=in, position=1)\", \"(type='Update', node==>, value=AND)\", \"(type='Update', node=all, value=some)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Person}', parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Tutors, position=0)\", \"(type='TreeInsert', tree='{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='Update', node==>, value=AND)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{sig/Teacher}', parent=set of, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=0)\", \"(type='Move', tree='{in{->{var2/Person}{var3/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=1)\", \"(type='TreeInsert', tree='{in{->{var3/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent==>, position=2)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node=var3/Person, value=var1/Person)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Person\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Person}}{OR{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{some{one of{var3}{sig/Person}}{AND{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var3/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var3/Person}{sig/Teacher}}}}}}}}","totalTED":37,"challenge":"YH3ANm7Y5Qe5dSYem","time":38795500,"targetExpr":"all p1 : Person | (some p2 : Teacher | p2 -> p1 in Tutors) or (some p2, p3 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p3 in Teacher) or (some p2, p3, p4 : Person | p2 -> p1 in Tutors and p3 -> p2 in Tutors and p4 -> p3 in Tutors and p4 in Teacher)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { some p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) and (p1 not in Student and p1 in Teacher) }","sourceAST":"{some{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{!in{var0/Person}{sig/Student}}{OR{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{in{var0/Person}{sig/Teacher}}}}}}","nextExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","sourceExpr":"some p1, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher or p2 in Teacher or (some p3:Person | p2 -> p3 in Tutors implies p3 in Teacher)) and (p1 not in Student and p1 in Teacher)","predicate":"inv15","isNewNode":true,"srcDstTED":30,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Insert', node=some, parent=some, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Person}}', parent=some, position=0)\", \"(type='Update', node==>, value=AND)\", \"(type='Move', tree='{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{AND{!in{var0/Person}{sig/Student}}{OR{in{var0/Person}{sig/Teacher}}{in{var1/Person}{sig/Teacher}}{some{one of{var2}{sig/Person}}{=>{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}{in{var0/Person}{sig/Teacher}}}}', parent=some, position=1)\", \"(type='Insert', node=OR, parent==>, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Teacher}}', parent==>, position=1)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Move', tree='{in{var2/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Insert', node=field/Tutors, parent=in, position=1)\", \"(type='Insert', node=OR, parent=AND, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var1/Person)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Person}', parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Tutors, position=0)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Move', tree='{in{var1/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Update', node=sig/Teacher, value=sig/Person)\", \"(type='Move', tree='{sig/Teacher}', parent=set of, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=0)\", \"(type='Move', tree='{in{var0/Person}{sig/Teacher}}', parent=AND, position=1)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Delete', node=var2/Person)\", \"(type='TreeDelete', tree='{!in{var0/Person}{sig/Student}}')\", \"(type='TreeDelete', tree='{one of{var2}{sig/Person}}')\", \"(type='Delete', node==>)\", \"(type='Delete', node=some)\", \"(type='Delete', node=OR)\", \"(type='Delete', node=AND)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":30,"challenge":"YH3ANm7Y5Qe5dSYem","time":37786100,"targetExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1,p2,p3:Person | (p1 in Teacher) or (p1->p2 in Tutors implies p2 in Teacher) or (p1->p2 in Tutors and p2->p3 in Tutors implies p3 in Teacher) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{all{one of{var2}{sig/Person}}{OR{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{=>{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var2/Person}{sig/Teacher}}}{in{var0/Person}{sig/Teacher}}}}}}","nextExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","sourceExpr":"all p1, p2, p3 : Person | (p1 -> p2 in Tutors implies p2 in Teacher) or (p1 -> p2 in Tutors and p2 -> p3 in Tutors implies p3 in Teacher) or p1 in Teacher","predicate":"inv15","isNewNode":false,"srcDstTED":25,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=OR, value=AND)\", \"(type='Insert', node=OR, parent=OR, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=OR, position=1)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='TreeInsert', tree='{in{var1/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Insert', node=OR, parent=AND, position=0)\", \"(type='Move', tree='{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}', parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Update', node==>, value=AND)\", \"(type='Move', tree='{=>{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}', parent=OR, position=0)\", \"(type='TreeInsert', tree='{in{var2/Person}{sig/Teacher}}', parent=OR, position=1)\", \"(type='Update', node=var0/Person, value=var2/Person)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Delete', node=AND)\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node==>)\", \"(type='TreeDelete', tree='{in{var0/Person}{sig/Teacher}}')\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":25,"challenge":"YH3ANm7Y5Qe5dSYem","time":54678600,"targetExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (some p3: Person | p2->p3 in Tutors and p3 in Teacher) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{some{one of{var2}{sig/Person}}{AND{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}","nextExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","sourceExpr":"all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (some p3: Person | p2->p3 in Tutors and p3 in Teacher)","predicate":"inv15","isNewNode":true,"srcDstTED":25,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=OR, value=in)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Move', tree='{var1/Person}', parent=OR, position=0)\", \"(type='Update', node=some, value=.)\", \"(type='Update', node=var2, value=var0/Person)\", \"(type='Move', tree='{var2}', parent=some, position=0)\", \"(type='Update', node=AND, value=^)\", \"(type='Update', node=in, value=~)\", \"(type='Delete', node=var0/Person)\", \"(type='Delete', node=->)\", \"(type='TreeDelete', tree='{field/Tutors{set of{sig/Person}}}')\", \"(type='Delete', node=in)\", \"(type='TreeDelete', tree='{in{var1/Person}{sig/Teacher}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=sig/Person)\", \"(type='Delete', node=one of)\", \"(type='TreeDelete', tree='{->{var1/Person}{var2/Person}}')\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":25,"challenge":"YH3ANm7Y5Qe5dSYem","time":33290900,"targetExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { Person = (Person - Teacher) } pred inv3 { Student & Teacher = none } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all c:Class, t1, t2:Teacher | (t1 -> c in Teaches) and (t2 -> c in Teaches) implies t1 = t2 } pred inv10 { all c: Class, s: Student | some g:Group | c -> s -> g in Groups } pred inv11 { all c:Class | (some s:Person, g:Group | c -> s -> g in Groups) implies (some t:Teacher | t -> c in Teaches) } pred inv12 { all t:Teacher | some c:Class, p:Person, g:Group | c -> p -> g in Groups and t -> c in Teaches } pred inv13 { all p1:Person, p2:Person | p1 -> p2 in Tutors implies (p1 in Teacher and p2 in Student) } pred inv14 { all s:Person, c:Class | (some g:Group | c -> s -> g in Groups) implies (all t:Person | t -> c in Teaches implies t -> s in Tutors) } pred inv15 { some t:Teacher | t in Person.*Tutors }","sourceAST":"{some{one of{var0}{sig/Teacher}}{in{var0/Person}{.{sig/Person}{*{field/Tutors{set of{sig/Person}}}}}}}","nextExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","sourceExpr":"some t:Teacher| t in Person.*Tutors","predicate":"inv15","isNewNode":false,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Person}}', parent=all, position=0)\", \"(type='Move', tree='{some{one of{var0}{sig/Teacher}}{in{var0/Person}{.{sig/Person}{*{field/Tutors{set of{sig/Person}}}}}}}', parent=all, position=1)\", \"(type='Update', node=var0, value=var1)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=sig/Person, value=var0/Person)\", \"(type='Insert', node=^, parent=., position=1)\", \"(type='Update', node=*, value=~)\", \"(type='Move', tree='{*{field/Tutors{set of{sig/Person}}}}', parent=^, position=0)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Person\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Teacher}}{in{var1/Person}{.{var0/Person}{^{~{field/Tutors{set of{sig/Person}}}}}}}}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":61825400,"targetExpr":"all p:Person | some t:Teacher | t in p.^~Tutors","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c1,c2:Class | all t:Teacher | t->c1 in Teaches and t->c2 in Teaches implies c1=c2 } pred inv9 { all t1,t2:Teacher | all c:Class | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv10 { all c:Class | all s:Student | some g:Group | (c->s->g) in Groups } pred inv11 { all c:Class | (some p:Person,g:Group | (c->p->g in Groups)) implies (some t:Teacher | t->c in Teaches) } pred inv12 { all t:Teacher | some p:Person,g:Group,c:Class | c->p->g in Groups and t->c in Teaches } pred inv13 { all p1,p2:Person | p1->p2 in Tutors implies p1 in Teacher and p2 in Student } pred inv14 { all s:Person,c:Class,t:Person | (some g:Group | c->s->g in Groups) and t->c in Teaches implies t->s in Tutors } pred inv15 { all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (some p3: Person | p1 != p3 and p2 != p3 and p2->p3 in Tutors and p3 in Teacher) }","sourceAST":"{all{one of{var0}{sig/Person}}{all{one of{var1}{sig/Person}}{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{some{one of{var2}{sig/Person}}{AND{!={var0/Person}{var2/Person}}{!={var1/Person}{var2/Person}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}}}","nextExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","sourceExpr":"all p1,p2:Person | (p1->p2 in Tutors and p2 in Teacher) or (some p3: Person | p1 != p3 and p2 != p3 and p2->p3 in Tutors and p3 in Teacher)","predicate":"inv15","isNewNode":true,"srcDstTED":29,"targetAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Insert', node=some, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var2}{sig/Person}}', parent=some, position=0)\", \"(type='Update', node=OR, value=AND)\", \"(type='Move', tree='{OR{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}{some{one of{var2}{sig/Person}}{AND{!={var0/Person}{var2/Person}}{!={var1/Person}{var2/Person}}{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var2/Person}{sig/Teacher}}}}}', parent=some, position=1)\", \"(type='Insert', node=OR, parent=OR, position=0)\", \"(type='Move', tree='{in{->{var1/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}', parent=OR, position=1)\", \"(type='Insert', node=AND, parent=OR, position=0)\", \"(type='Update', node=!=, value=in)\", \"(type='Move', tree='{!={var1/Person}{var2/Person}}', parent=OR, position=1)\", \"(type='Insert', node=OR, parent=AND, position=0)\", \"(type='Insert', node=in, parent=AND, position=1)\", \"(type='Update', node=var2/Person, value=sig/Teacher)\", \"(type='Update', node=var2/Person, value=var0/Person)\", \"(type='Move', tree='{AND{in{->{var0/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}{in{var1/Person}{sig/Teacher}}}', parent=OR, position=0)\", \"(type='Update', node=one of, value=in)\", \"(type='Move', tree='{one of{var2}{sig/Person}}', parent=OR, position=1)\", \"(type='Update', node=!=, value=->)\", \"(type='Move', tree='{!={var0/Person}{var2/Person}}', parent=in, position=0)\", \"(type='TreeInsert', tree='{field/Tutors{set of{sig/Person}}}', parent=in, position=1)\", \"(type='Update', node=var2, value=var2/Person)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=var1/Person, parent=!=, position=2)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Delete', node=var0/Person)\", \"(type='TreeDelete', tree='{in{var2/Person}{sig/Teacher}}')\", \"(type='Delete', node=AND)\", \"(type='Delete', node=some)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Person}}{some{one of{var2}{sig/Person}}{AND{OR{AND{OR{AND{in{->{var0/Person}{var2/Person}}{field/Tutors{set of{sig/Person}}}}{in{var0/Person}{sig/Teacher}}}{in{var2/Person}{sig/Teacher}}}{in{->{var2/Person}{var1/Person}}{field/Tutors{set of{sig/Person}}}}}{in{var1/Person}{sig/Teacher}}}{in{->{var1/Person}{var0/Person}}{field/Tutors{set of{sig/Person}}}}}}}}","totalTED":29,"challenge":"YH3ANm7Y5Qe5dSYem","time":31482400,"targetExpr":"all p1 : Person | some p2, p3 : Person | (p2->p1 in Tutors) and ((p2 in Teacher) or (p3->p2 in Tutors) and ((p3 in Teacher) or (p1->p3 in Tutors) and (p1 in Teacher)))","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Teacher implies p in Student } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Teacher}}{in{var0/Person}{sig/Student}}}}","nextExpr":"all p:Person | p in Teacher implies p not in Student","sourceExpr":"all p:Person | p in Teacher implies p in Student","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Teacher}}{!in{var0/Person}{sig/Student}}}}","operations":"[\"(type='Update', node=in, value=!in)\"]","hint":"One step away from the solution! Instead of using inclusion operator ('in') to specify that some element(s) belong to a set, try using exclusion operator ('!in') to specify that some element(s) do not belong to a set.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Teacher}}{!in{var0/Person}{sig/Student}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":86546400,"targetExpr":"all p:Person | p in Teacher implies p not in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student or p in Teacher } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{OR{in{var0/Person}{sig/Student}}{in{var0/Person}{sig/Teacher}}}}","nextExpr":"all p : Person | p in Student implies p not in Teacher","sourceExpr":"all p : Person | p in Student or p in Teacher","predicate":"inv3","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Student}}{!in{var0/Person}{sig/Teacher}}}}","operations":"[\"(type='Update', node=OR, value==>)\", \"(type='Update', node=in, value=!in)\"]","hint":"Near a solution! Instead of using disjunction operator ('or') to combine two boolean expressions, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Student}}{!in{var0/Person}{sig/Teacher}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":81170700,"targetExpr":"all p : Person | p in Student implies p not in Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student iff p not in Teacher } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{<=>{!in{var0/Person}{sig/Teacher}}{in{var0/Person}{sig/Student}}}}","nextExpr":"all p:Person | p in Teacher implies p not in Student","sourceExpr":"all p:Person | p in Student iff p not in Teacher","predicate":"inv3","isNewNode":false,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Teacher}}{!in{var0/Person}{sig/Student}}}}","operations":"[\"(type='Update', node=<=>, value==>)\", \"(type='Update', node=!in, value=in)\", \"(type='Update', node=in, value=!in)\"]","hint":"Near a solution! Instead of using equivalence operator ('<=>') to specify the equivalence of the right and left side of the expression, try using implication operator ('=>') to specify that if the left side is true, then the right side must also be true.","nextAST":"{all{one of{var0}{sig/Person}}{=>{in{var0/Person}{sig/Teacher}}{!in{var0/Person}{sig/Student}}}}","totalTED":3,"challenge":"YH3ANm7Y5Qe5dSYem","time":93940600,"targetExpr":"all p:Person | p in Teacher implies p not in Student","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Teacher or p in Student } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{OR{in{var0/Person}{sig/Teacher}}{in{var0/Person}{sig/Student}}}}","nextExpr":"all p:Person | not (p in Teacher and p in Student)","sourceExpr":"all p : Person | (p in Teacher or p in Student)","predicate":"inv3","isNewNode":false,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{!{AND{in{var0/Person}{sig/Teacher}}{in{var0/Person}{sig/Student}}}}}","operations":"[\"(type='Insert', node=!, parent=all, position=1)\", \"(type='Update', node=OR, value=AND)\", \"(type='Move', tree='{OR{in{var0/Person}{sig/Teacher}}{in{var0/Person}{sig/Student}}}', parent=!, position=0)\"]","hint":"Near a solution! Consider adding a negation operator ('!') to specify that the expression is false. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Person}}{!{AND{in{var0/Person}{sig/Teacher}}{in{var0/Person}{sig/Student}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":43776800,"targetExpr":"all p:Person | not (p in Teacher and p in Student)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"some c:Class | some t:Teacher | t->c in Teaches","sourceExpr":"some c: Class | some p: Person | p->c in Teaches","predicate":"inv5","isNewNode":false,"srcDstTED":1,"targetAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=sig/Person, value=sig/Teacher)\"]","hint":"One step away from the solution! Instead of using signature of type Person, try using signature of type Teacher to help satisfy the required property.","nextAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":153040600,"targetExpr":"some c:Class | some t:Teacher | t->c in Teaches","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { all c:Class | c in Person.Teaches } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{in{var0/Class}{.{sig/Person}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"some c : Class | c in Teacher.Teaches","sourceExpr":"all c:Class | c in Person.Teaches","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{some{one of{var0}{sig/Class}}{in{var0/Class}{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\"]","hint":"Near a solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Class}}{in{var0/Class}{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":89743600,"targetExpr":"some c : Class | c in Teacher.Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class | lone t:Teacher | t->c in Teaches } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Class}}{lone{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"some c:Class | some t:Teacher | t->c in Teaches","sourceExpr":"some c:Class | lone t:Teacher | t->c in Teaches","predicate":"inv5","isNewNode":true,"srcDstTED":1,"targetAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=lone, value=some)\"]","hint":"One step away from the solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":41542300,"targetExpr":"some c:Class | some t:Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class | lone t:Person | t->c in Teaches } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Class}}{lone{one of{var1}{sig/Person}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"some c : Class | some t : Teacher | t->c in Teaches","sourceExpr":"some c:Class | lone t:Person | t->c in Teaches","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=lone, value=some)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\"]","hint":"Near a solution! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":34380900,"targetExpr":"some c : Class | some t : Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { all c:Class | lone t:Teacher | t->c in Teaches } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{lone{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"some c : Class | some t : Teacher | t->c in Teaches","sourceExpr":"all c:Class | lone t:Teacher | t->c in Teaches","predicate":"inv5","isNewNode":true,"srcDstTED":2,"targetAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=lone, value=some)\"]","hint":"Near a solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":38092700,"targetExpr":"some c : Class | some t : Teacher | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { all t:Teacher, c:Class | t -> c in Teaches } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"some t:Teacher, c:Class | t->c in Teaches","sourceExpr":"all t:Teacher,c:Class | t->c in Teaches","predicate":"inv5","isNewNode":false,"srcDstTED":2,"targetAST":"{some{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=all, value=some)\"]","hint":"Near a solution! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":2,"challenge":"YH3ANm7Y5Qe5dSYem","time":41356500,"targetExpr":"some t:Teacher, c:Class | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { Teaches in Teacher -> some Class } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->some{sig/Teacher}{sig/Class}}}","nextExpr":"Teacher in Teaches.Class","sourceExpr":"Teaches in Teacher -> some Class","predicate":"inv6","isNewNode":true,"srcDstTED":4,"targetAST":"{in{sig/Teacher}{.{field/Teaches{set of{sig/Class}}}{sig/Class}}}","operations":"[\"(type='Insert', node=sig/Teacher, parent=in, position=0)\", \"(type='Insert', node=., parent=in, position=1)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=., position=0)\", \"(type='Move', tree='{sig/Class}', parent=., position=1)\", \"(type='Delete', node=sig/Teacher)\", \"(type='Delete', node=->some)\"]","hint":"Keep going! Consider adding a signature of type Teacher to help satisfy the required property. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{sig/Teacher}{.{field/Teaches{set of{sig/Class}}}{sig/Class}}}","totalTED":4,"challenge":"YH3ANm7Y5Qe5dSYem","time":117623700,"targetExpr":"Teacher in Teaches.Class","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { some t:Teacher | all c:Class | t -> c in Teaches } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"(all c : Class | some t : Teacher | t -> c in Teaches)","sourceExpr":"some t : Teacher | all c : Class | t->c in Teaches","predicate":"inv7","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=some, value=all)\", \"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node=sig/Class, value=sig/Teacher)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Class, value=var0/Class)\"]","hint":"Keep going! Instead of using existential quantifier ('some') to specify that some elements in a set satisfy a condition, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":94842200,"targetExpr":"(all c : Class | some t : Teacher | t -> c in Teaches)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all t:Teacher, c:Class | t -> c in Teaches } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{all{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"(all c : Class | some t : Teacher | t -> c in Teaches)","sourceExpr":"all x : Teacher | all c : Class | x->c in Teaches","predicate":"inv7","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node=sig/Class, value=sig/Teacher)\", \"(type='Update', node=var0/Person, value=var1/Person)\", \"(type='Update', node=var1/Class, value=var0/Class)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":85091499,"targetExpr":"(all c : Class | some t : Teacher | t -> c in Teaches)","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Teacher one -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Teacher one -> Class","predicate":"inv8","isNewNode":true,"srcDstTED":8,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=one->, value=<:)\", \"(type='Move', tree='{one->{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=one->, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":121222800,"targetExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Person one -> lone Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->lone{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Person one -> lone Class","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=one->lone, value=<:)\", \"(type='Move', tree='{one->lone{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=one->lone, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":33820699,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Teacher one -> lone Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->lone{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Teacher one -> lone Class","predicate":"inv8","isNewNode":true,"srcDstTED":8,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=one->lone, value=<:)\", \"(type='Move', tree='{one->lone{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=one->lone, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":39002001,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class | some t:Teacher | t->c in Teaches } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all c:Class | all t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2 } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{={var1/Person}{var2/Person}}}}}}","nextExpr":"all c1:Class,c2:Class,t:Teacher | (t->c1 in Teaches and t->c2 in Teaches) implies c1 = c2","sourceExpr":"all c:Class | all t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2","predicate":"inv8","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{={var0/Class}{var1/Class}}}}}}","operations":"[\"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node=var1/Person, value=var0/Class)\", \"(type='Update', node=var2/Person, value=var1/Class)\", \"(type='Update', node=var1/Person, value=var2/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\"]","hint":"Keep going! Instead of using signature of type Teacher, try using signature of type Class to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Class}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}{={var0/Class}{var1/Class}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":58293800,"targetExpr":"all c1:Class,c2:Class,t:Teacher | (t->c1 in Teaches and t->c2 in Teaches) implies c1 = c2","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | one t.Teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{one{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"all t : Teacher | lone t.Teaches","sourceExpr":"all t:Teacher | one t.Teaches","predicate":"inv8","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Teacher}}{lone{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=one, value=lone)\"]","hint":"One step away from the solution! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/Teacher}}{lone{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","totalTED":1,"challenge":"YH3ANm7Y5Qe5dSYem","time":30419501,"targetExpr":"all t : Teacher | lone t.Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { lone Teacher.Teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{lone{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}","nextExpr":"all t : Teacher | lone t.Teaches","sourceExpr":"lone Teacher.Teaches","predicate":"inv8","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Teacher}}{lone{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Teacher}}', parent=all, position=0)\", \"(type='Move', tree='{lone{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/Teacher, value=var0/Person)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Teacher\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Teacher}}{lone{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":90494199,"targetExpr":"all t : Teacher | lone t.Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Person -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Person -> Class","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->, value=<:)\", \"(type='Move', tree='{->{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=->, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":59283801,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teacher <:Teaches in Teacher -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->one{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teacher <:Teaches in Teacher -> one Class","predicate":"inv8","isNewNode":true,"srcDstTED":6,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->one, value=<:)\", \"(type='Move', tree='{->one{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Move', tree='{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}', parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=->one, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":47927601,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Person -> lone Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->lone{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Person set -> lone Class","predicate":"inv8","isNewNode":false,"srcDstTED":9,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->lone, value=<:)\", \"(type='Move', tree='{->lone{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=->lone, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":56734200,"targetExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Teacher -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Teacher -> Class","predicate":"inv8","isNewNode":true,"srcDstTED":8,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->, value=<:)\", \"(type='Move', tree='{->{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=->, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":31402100,"targetExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Person one -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Person one -> Class","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=one->, value=<:)\", \"(type='Move', tree='{one->{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=one->, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":63347700,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Teacher one -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->one{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Teacher one -> one Class","predicate":"inv8","isNewNode":true,"srcDstTED":8,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=one->one, value=<:)\", \"(type='Move', tree='{one->one{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=one->one, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":43626000,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no p:Person | p in Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { all p:Person | p in Teacher or p in Student } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all p:Teacher | some c:Class | p->c in Teaches } pred inv7 { all c:Class | some p:Teacher | p->c in Teaches } pred inv8 { all c:Class | one t:Teacher | t->c in Teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{one{one of{var1}{sig/Teacher}}{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"all t : Teacher | lone c : Class | t->c in Teaches","sourceExpr":"all c:Class | one t:Teacher | t->c in Teaches","predicate":"inv8","isNewNode":true,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/Teacher}}{lone{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node=one, value=lone)\", \"(type='Update', node=sig/Class, value=sig/Teacher)\", \"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node=var1/Person, value=var0/Person)\", \"(type='Update', node=var0/Class, value=var1/Class)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using lone quantifier ('lone') to specify that there is at most one element in a set.","nextAST":"{all{one of{var0}{sig/Teacher}}{lone{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":5,"challenge":"YH3ANm7Y5Qe5dSYem","time":51992500,"targetExpr":"all t : Teacher | lone c : Class | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Teacher -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->one{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Teacher set -> one Class","predicate":"inv8","isNewNode":false,"srcDstTED":8,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->one, value=<:)\", \"(type='Move', tree='{->one{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=->one, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":86630701,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Person lone -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{lone->{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Person lone -> Class","predicate":"inv8","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=lone->, value=<:)\", \"(type='Move', tree='{lone->{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=lone->, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":66254300,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teacher <:Teaches in Person -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","sourceExpr":"Teacher <:Teaches in Person -> Class","predicate":"inv8","isNewNode":true,"srcDstTED":7,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->, value=<:)\", \"(type='Move', tree='{->{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Move', tree='{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}', parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":30795400,"targetExpr":"~(Teacher <: Teaches).(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teacher <:Teaches in Person -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->one{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teacher <:Teaches in Person -> one Class","predicate":"inv8","isNewNode":true,"srcDstTED":7,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->one, value=<:)\", \"(type='Move', tree='{->one{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Move', tree='{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}', parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=->one, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":7,"challenge":"YH3ANm7Y5Qe5dSYem","time":51241501,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p: Person | p in Student } pred inv2 { all p:Person | not p in Teacher } pred inv3 { no p:Person | p in Student and p in Teacher } pred inv4 { no p:Person | p not in Student and p not in Teacher } pred inv5 { some c:Class, p:Person | p->c in Teaches and p in Teacher } pred inv6 { all t:Teacher | some c:Class | t->c in Teaches } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { Teaches in Person -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->one{sig/Person}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Person set -> one Class","predicate":"inv8","isNewNode":false,"srcDstTED":9,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=->one, value=<:)\", \"(type='Move', tree='{->one{sig/Person}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=->one, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":53608201,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { Teaches in Teacher lone -> Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{lone->{sig/Teacher}{sig/Class}}}","nextExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","sourceExpr":"Teaches in Teacher lone -> set Class","predicate":"inv8","isNewNode":false,"srcDstTED":8,"targetAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=~, parent=., position=0)\", \"(type='Update', node=lone->, value=<:)\", \"(type='Move', tree='{lone->{sig/Teacher}{sig/Class}}', parent=., position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=lone->, position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":50207201,"targetExpr":"~(Teacher<:Teaches).(Teacher<:Teaches) in iden","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { lone Teacher->Teaches } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{lone{->{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}","nextExpr":"all t : Teacher | lone t.Teaches","sourceExpr":"lone Teacher->Teaches","predicate":"inv8","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Teacher}}{lone{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/Teacher}}', parent=all, position=0)\", \"(type='Move', tree='{lone{->{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}', parent=all, position=1)\", \"(type='Update', node=->, value=.)\", \"(type='Update', node=sig/Teacher, value=var0/Person)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Teacher\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/Teacher}}{lone{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":28580600,"targetExpr":"all t : Teacher | lone t.Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all p:Teacher | some c: Class | p -> c in Teaches Teacher <:Teaches in Teacher -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->one{sig/Teacher}{sig/Class}}}}","nextExpr":"all t : Teacher | lone c : Class | t->c in Teaches","sourceExpr":"all p:Teacher | some c: Class | p -> c in Teaches Teacher <:Teaches in Teacher -> one Class","predicate":"inv8","isNewNode":true,"srcDstTED":11,"targetAST":"{all{one of{var0}{sig/Teacher}}{lone{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/Teacher}}{some{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=lone)\", \"(type='TreeDelete', tree='{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->one{sig/Teacher}{sig/Class}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Teacher}}{lone{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":11,"challenge":"YH3ANm7Y5Qe5dSYem","time":33411701,"targetExpr":"all t : Teacher | lone c : Class | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all p:Person | some c: Class | p -> c in Teaches Teacher <:Teaches in Teacher -> one Class } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->one{sig/Teacher}{sig/Class}}}}","nextExpr":"all t : Teacher | lone c : Class | t->c in Teaches","sourceExpr":"all p:Person | some c: Class | p -> c in Teaches Teacher <:Teaches in Teacher -> one Class","predicate":"inv8","isNewNode":true,"srcDstTED":12,"targetAST":"{all{one of{var0}{sig/Teacher}}{lone{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Move', tree='{all{one of{var0}{sig/Person}}{some{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}', parent=root, position=0)\", \"(type='Update', node=some, value=lone)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='TreeDelete', tree='{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{->one{sig/Teacher}{sig/Class}}}')\", \"(type='Delete', node=AND)\"]","hint":"Keep going! It seems like the universal quantifier ('all') is not in the right place.  Try moving it so that you correctly ensure the required property.","nextAST":"{all{one of{var0}{sig/Teacher}}{lone{one of{var1}{sig/Class}}{in{->{var0/Person}{var1/Class}}{field/Teaches{set of{sig/Class}}}}}}","totalTED":12,"challenge":"YH3ANm7Y5Qe5dSYem","time":51350299,"targetExpr":"all t : Teacher | lone c : Class | t->c in Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teacher <: Teaches in Teacher one -> Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{one->{sig/Teacher}{sig/Class}}}","nextExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","sourceExpr":"Teacher <: Teaches in Teacher one -> Class","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Move', tree='{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}', parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Update', node=one->, value=<:)\", \"(type='Move', tree='{one->{sig/Teacher}{sig/Class}}', parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=one->, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":112228100,"targetExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teaches in Person one -> Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->{sig/Person}{sig/Class}}}","nextExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Person one -> Class","predicate":"inv9","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=<:, parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Update', node=one->, value=<:)\", \"(type='Move', tree='{one->{sig/Person}{sig/Class}}', parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=one->, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":45997000,"targetExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teaches in Class one -> Person } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->{sig/Class}{sig/Person}}}","nextExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Class one -> Person","predicate":"inv9","isNewNode":true,"srcDstTED":10,"targetAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Update', node=sig/Person, value=iden)\", \"(type='Move', tree='{sig/Person}', parent=in, position=1)\", \"(type='Insert', node=<:, parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Insert', node=<:, parent=~, position=0)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Insert', node=field/Teaches, parent=<:, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\", \"(type='Delete', node=one->)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":36278799,"targetExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teaches in Teacher one -> Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->{sig/Teacher}{sig/Class}}}","nextExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Teacher one -> Class","predicate":"inv9","isNewNode":true,"srcDstTED":8,"targetAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=<:, parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Update', node=one->, value=<:)\", \"(type='Move', tree='{one->{sig/Teacher}{sig/Class}}', parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=one->, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":30799201,"targetExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all p:Teacher | one p.Teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{one{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"all c:Class | lone Teacher&Teaches.c","sourceExpr":"all t:Teacher | one t.Teaches","predicate":"inv9","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","operations":"[\"(type='Insert', node=lone, parent=all, position=1)\", \"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node=one, value=&)\", \"(type='Move', tree='{one{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}', parent=lone, position=0)\", \"(type='Insert', node=sig/Teacher, parent=one, position=1)\", \"(type='Insert', node=var0/Class, parent=., position=2)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Consider adding a lone quantifier ('lone') to specify that there is at most one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":139628300,"targetExpr":"all c:Class | lone Teacher&Teaches.c","createdShorterPath":true}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teaches in Person -> Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{->{sig/Person}{sig/Class}}}","nextExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Person -> Class","predicate":"inv9","isNewNode":true,"srcDstTED":9,"targetAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=<:, parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Update', node=->, value=<:)\", \"(type='Move', tree='{->{sig/Person}{sig/Class}}', parent=~, position=0)\", \"(type='Update', node=sig/Person, value=sig/Teacher)\", \"(type='Insert', node=field/Teaches, parent=->, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":35321299,"targetExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all p:univ | one p.Teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{univ}}{one{.{var0/univ}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"all c:Class | lone Teaches.c & Teacher","sourceExpr":"all p:univ | one p.Teaches","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","operations":"[\"(type='Insert', node=lone, parent=all, position=1)\", \"(type='Update', node=univ, value=sig/Class)\", \"(type='Update', node=one, value=&)\", \"(type='Move', tree='{one{.{var0/univ}{field/Teaches{set of{sig/Class}}}}}', parent=lone, position=0)\", \"(type='Insert', node=sig/Teacher, parent=one, position=1)\", \"(type='Insert', node=var0/Class, parent=., position=2)\", \"(type='Delete', node=var0/univ)\"]","hint":"Keep going! Consider adding a lone quantifier ('lone') to specify that there is at most one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":29923500,"targetExpr":"all c:Class | lone Teaches.c & Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { no c:Class | all p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2 } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}{in{var0/Class}{.{var2/Person}{field/Teaches{set of{sig/Class}}}}}}{={var1/Person}{var2/Person}}}}}}","nextExpr":"all c:Class , t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2","sourceExpr":"no c:Class | all p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1=p2","predicate":"inv9","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{={var1/Person}{var2/Person}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=in, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=in, position=1)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Class}', parent=->, position=1)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Class}', parent=->, position=1)\", \"(type='Delete', node=var1/Person)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Person)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{={var1/Person}{var2/Person}}}}}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":54736500,"targetExpr":"all c:Class , t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teaches in Teacher one -> one Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{in{field/Teaches{set of{sig/Class}}}{one->one{sig/Teacher}{sig/Class}}}","nextExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","sourceExpr":"Teaches in Teacher one -> one Class","predicate":"inv9","isNewNode":true,"srcDstTED":8,"targetAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","operations":"[\"(type='Insert', node=., parent=in, position=0)\", \"(type='Insert', node=iden, parent=in, position=1)\", \"(type='Insert', node=<:, parent=., position=0)\", \"(type='Insert', node=~, parent=., position=1)\", \"(type='Insert', node=sig/Teacher, parent=<:, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=<:, position=1)\", \"(type='Update', node=one->one, value=<:)\", \"(type='Move', tree='{one->one{sig/Teacher}{sig/Class}}', parent=~, position=0)\", \"(type='Insert', node=field/Teaches, parent=one->one, position=1)\", \"(type='Insert', node=set of, parent=field/Teaches, position=0)\", \"(type='Move', tree='{sig/Class}', parent=set of, position=0)\"]","hint":"Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the inclusion operator ('in') expression.","nextAST":"{in{.{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{~{<:{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}{iden}}","totalTED":8,"challenge":"YH3ANm7Y5Qe5dSYem","time":28317200,"targetExpr":"(Teacher <: Teaches).~(Teacher <: Teaches) in iden","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { Teaches in Person one -> Class Teaches in Teacher one -> Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{AND{in{field/Teaches{set of{sig/Class}}}{one->{sig/Person}{sig/Class}}}{in{field/Teaches{set of{sig/Class}}}{one->{sig/Teacher}{sig/Class}}}}","nextExpr":"all c:Class | lone Teacher&Teaches.c","sourceExpr":"Teaches in Person one -> Class Teaches in Teacher one -> Class","predicate":"inv9","isNewNode":true,"srcDstTED":13,"targetAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","operations":"[\"(type='Update', node=AND, value=all)\", \"(type='Update', node=one->, value=one of)\", \"(type='Move', tree='{one->{sig/Person}{sig/Class}}', parent=AND, position=0)\", \"(type='Insert', node=lone, parent=AND, position=1)\", \"(type='Update', node=sig/Person, value=var0)\", \"(type='Update', node=in, value=&)\", \"(type='Move', tree='{in{field/Teaches{set of{sig/Class}}}{one->{sig/Teacher}{sig/Class}}}', parent=lone, position=0)\", \"(type='Insert', node=., parent=in, position=0)\", \"(type='Move', tree='{sig/Teacher}', parent=in, position=1)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=., position=0)\", \"(type='Insert', node=var0/Class, parent=., position=1)\", \"(type='Delete', node=sig/Class)\", \"(type='Delete', node=one->)\", \"(type='TreeDelete', tree='{field/Teaches{set of{sig/Class}}}')\", \"(type='Delete', node=in)\"]","hint":"Keep going! Instead of using conjunction operator ('and') to combine two boolean expressions, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","totalTED":13,"challenge":"YH3ANm7Y5Qe5dSYem","time":49088200,"targetExpr":"all c:Class | lone Teacher&Teaches.c","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { no c:Class | all p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1!=p2 } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}{in{var0/Class}{.{var2/Person}{field/Teaches{set of{sig/Class}}}}}}{!={var1/Person}{var2/Person}}}}}}","nextExpr":"all c:Class , t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2","sourceExpr":"no c:Class | all p1,p2:Teacher | c in p1.Teaches and c in p2.Teaches implies p1!=p2","predicate":"inv9","isNewNode":true,"srcDstTED":10,"targetAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{={var1/Person}{var2/Person}}}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=!=, value==)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=in, position=1)\", \"(type='Insert', node=->, parent=in, position=0)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=in, position=1)\", \"(type='Insert', node=var1/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Class}', parent=->, position=1)\", \"(type='Insert', node=var2/Person, parent=->, position=0)\", \"(type='Move', tree='{var0/Class}', parent=->, position=1)\", \"(type='Delete', node=var1/Person)\", \"(type='Delete', node=.)\", \"(type='Delete', node=var2/Person)\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{all{one of{var2}{sig/Teacher}}{=>{AND{in{->{var1/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}{in{->{var2/Person}{var0/Class}}{field/Teaches{set of{sig/Class}}}}}{={var1/Person}{var2/Person}}}}}}","totalTED":10,"challenge":"YH3ANm7Y5Qe5dSYem","time":41068801,"targetExpr":"all c:Class , t1,t2:Teacher | t1->c in Teaches and t2->c in Teaches implies t1=t2","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no Teacher & Student } pred inv4 { Person = Teacher + Student } pred inv5 { some c:Class, p:Person | p in Teacher and c in p.Teaches } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t->c in Teaches } pred inv8 { all t:Teacher | lone t.Teaches } pred inv9 { lone Class->Teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{lone{->{sig/Class}{field/Teaches{set of{sig/Class}}}}}","nextExpr":"all c:Class | lone Teaches.c & Teacher","sourceExpr":"lone Class->Teaches","predicate":"inv9","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","operations":"[\"(type='Update', node=->, value=all)\", \"(type='Move', tree='{->{sig/Class}{field/Teaches{set of{sig/Class}}}}', parent=root, position=0)\", \"(type='Insert', node=one of, parent=->, position=0)\", \"(type='Insert', node=lone, parent=->, position=1)\", \"(type='Insert', node=var0, parent=one of, position=0)\", \"(type='Move', tree='{sig/Class}', parent=one of, position=1)\", \"(type='Insert', node=&, parent=lone, position=0)\", \"(type='Insert', node=., parent=&, position=0)\", \"(type='Insert', node=sig/Teacher, parent=&, position=1)\", \"(type='Move', tree='{field/Teaches{set of{sig/Class}}}', parent=., position=0)\", \"(type='Insert', node=var0/Class, parent=., position=1)\", \"(type='Delete', node=lone)\"]","hint":"Keep going! Instead of using arrow operator ('->') to map a relation, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","totalTED":9,"challenge":"YH3ANm7Y5Qe5dSYem","time":37194201,"targetExpr":"all c:Class | lone Teaches.c & Teacher","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { all p:Person | p not in Teacher } pred inv3 { all p:Person | p in Student implies p not in Teacher } pred inv4 { all p:Person | p in Student or p in Teacher } pred inv5 { some t:Teacher, c:Class | t -> c in Teaches } pred inv6 { all t:Teacher | some c:Class | t -> c in Teaches } pred inv7 { all c:Class | some t:Teacher | t -> c in Teaches } pred inv8 { all t:Teacher, c1,c2:Class | (t -> c1 in Teaches) and (t -> c2 in Teaches) implies c1 = c2 } pred inv9 { all p:Person | one p.Teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{one{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}}","nextExpr":"all c:Class | lone Teacher&Teaches.c","sourceExpr":"all p:Person | one p.Teaches","predicate":"inv9","isNewNode":true,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","operations":"[\"(type='Insert', node=lone, parent=all, position=1)\", \"(type='Update', node=sig/Person, value=sig/Class)\", \"(type='Update', node=one, value=&)\", \"(type='Move', tree='{one{.{var0/Person}{field/Teaches{set of{sig/Class}}}}}', parent=lone, position=0)\", \"(type='Insert', node=sig/Teacher, parent=one, position=1)\", \"(type='Insert', node=var0/Class, parent=., position=2)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Consider adding a lone quantifier ('lone') to specify that there is at most one element in a set. Think about how you can incorporate this within the universal quantifier ('all') expression.","nextAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","totalTED":6,"challenge":"YH3ANm7Y5Qe5dSYem","time":32896400,"targetExpr":"all c:Class | lone Teacher&Teaches.c","createdShorterPath":false}
{"mapping":"APTED","code":"sig State { trans : Event -> State } sig Init in State {} sig Event {} pred inv1 { some State.trans } pred inv2 { } pred inv3 { all y : State, e : Event | lone e.(y.trans) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { }","sourceAST":"{some{.{sig/State}{field/trans{->{sig/Event}{sig/State}}}}}","nextExpr":"all s:State | some s.trans","sourceExpr":"some State.trans","predicate":"inv1","isNewNode":false,"srcDstTED":5,"targetAST":"{all{one of{var0}{sig/State}}{some{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}","operations":"[\"(type='Insert', node=all, parent=root, position=0)\", \"(type='TreeInsert', tree='{one of{var0}{sig/State}}', parent=all, position=0)\", \"(type='Move', tree='{some{.{sig/State}{field/trans{->{sig/Event}{sig/State}}}}}', parent=all, position=1)\", \"(type='Update', node=sig/State, value=var0/State)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"State\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/State}}{some{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}","totalTED":5,"challenge":"zoEADeCW2b2suJB2k","time":97915600,"targetExpr":"all s:State | some s.trans","createdShorterPath":false}
{"mapping":"APTED","code":"sig State { trans : Event -> State } sig Init in State {} sig Event {} pred inv1 { } pred inv2 { } pred inv3 { all y : State | lone y.trans } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { }","sourceAST":"{all{one of{var0}{sig/State}}{lone{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}","nextExpr":"all s : State, e : Event | lone e.(s.trans)","sourceExpr":"all s:State | lone s.trans","predicate":"inv3","isNewNode":false,"srcDstTED":6,"targetAST":"{all{one of{var0}{sig/State}}{all{one of{var1}{sig/Event}}{lone{.{var1/Event}{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}}}","operations":"[\"(type='Insert', node=all, parent=all, position=1)\", \"(type='TreeInsert', tree='{one of{var1}{sig/Event}}', parent=all, position=0)\", \"(type='Move', tree='{lone{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}', parent=all, position=1)\", \"(type='Insert', node=., parent=lone, position=0)\", \"(type='Insert', node=var1/Event, parent=., position=0)\", \"(type='Move', tree='{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}', parent=., position=1)\"]","hint":"Keep going! You can use variables to help specify the condition. Consider introducing a new variable of type \"Event\" to your expression using the universal quantifier ('all').","nextAST":"{all{one of{var0}{sig/State}}{all{one of{var1}{sig/Event}}{lone{.{var1/Event}{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}}}","totalTED":6,"challenge":"zoEADeCW2b2suJB2k","time":123231700,"targetExpr":"all s : State, e : Event | lone e.(s.trans)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p = Student } pred inv2 { } pred inv3 { } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Person}}{={sig/Student}{var0/Person}}}","nextExpr":"all p : Person | some (p & Student)","sourceExpr":"all p:Person | p = Student","predicate":"inv1","isNewNode":true,"srcDstTED":2,"targetAST":"{all{one of{var0}{sig/Person}}{some{&{sig/Student}{var0/Person}}}}","operations":"[\"(type='Insert', node=some, parent=all, position=1)\", \"(type='Update', node==, value=&)\", \"(type='Move', tree='{={sig/Student}{var0/Person}}', parent=some, position=0)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{all{one of{var0}{sig/Person}}{some{&{sig/Student}{var0/Person}}}}","totalTED":2,"challenge":"zRAn69AocpkmxXZnW","time":145154600,"targetExpr":"all p : Person | some (p & Student)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no (Teacher + Student) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{+{sig/Student}{sig/Teacher}}}","nextExpr":"no (Teacher & Student)","sourceExpr":"no (Teacher + Student)","predicate":"inv3","isNewNode":true,"srcDstTED":1,"targetAST":"{no{&{sig/Student}{sig/Teacher}}}","operations":"[\"(type='Update', node=+, value=&)\"]","hint":"One step away from the solution! Instead of using union operator ('+') to combine two sets, try using intersection operator ('&') to find the common elements between two sets.","nextAST":"{no{&{sig/Student}{sig/Teacher}}}","totalTED":1,"challenge":"zRAn69AocpkmxXZnW","time":104293001,"targetExpr":"no (Teacher & Student)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in (Teacher + Student) } pred inv4 { } pred inv5 { } pred inv6 { } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{no{one of{var0}{sig/Person}}{in{var0/Person}{+{sig/Student}{sig/Teacher}}}}","nextExpr":"all p : Person | p not in (Student & Teacher)","sourceExpr":"no p:Person | p in (Teacher + Student)","predicate":"inv3","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Person}}{!in{var0/Person}{&{sig/Student}{sig/Teacher}}}}","operations":"[\"(type='Update', node=no, value=all)\", \"(type='Update', node=in, value=!in)\", \"(type='Update', node=+, value=&)\"]","hint":"Near a solution! Instead of using no quantifier ('no') to specify that there are no elements in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Person}}{!in{var0/Person}{&{sig/Student}{sig/Teacher}}}}","totalTED":3,"challenge":"zRAn69AocpkmxXZnW","time":60775200,"targetExpr":"all p : Person | p not in (Student & Teacher)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { some c:Class | all t:Teacher | t.Teaches = c } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | all t:Teacher | t.Teaches = c } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{={.{var1/Person}{field/Teaches{set of{sig/Class}}}}{var0/Class}}}}","nextExpr":"some c : Class, t : Teacher | c in t.Teaches","sourceExpr":"some c:Class | all t:Teacher | t.Teaches = c","predicate":"inv5","isNewNode":true,"srcDstTED":4,"targetAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var0/Class, parent==, position=0)\", \"(type='Delete', node=var0/Class)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{some{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":4,"challenge":"zRAn69AocpkmxXZnW","time":109826600,"targetExpr":"some c : Class, t : Teacher | c in t.Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { some c:Class | Teacher.Teaches = c } pred inv6 { all t:Teacher | Teacher.Teaches != none } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{some{one of{var0}{sig/Class}}{={.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{var0/Class}}}","nextExpr":"some c: Class | c in Teacher.Teaches","sourceExpr":"some c:Class | Teacher.Teaches = c","predicate":"inv5","isNewNode":true,"srcDstTED":3,"targetAST":"{some{one of{var0}{sig/Class}}{in{var0/Class}{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=var0/Class, parent==, position=0)\", \"(type='Delete', node=var0/Class)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{some{one of{var0}{sig/Class}}{in{var0/Class}{.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}}}","totalTED":3,"challenge":"zRAn69AocpkmxXZnW","time":44025400,"targetExpr":"some c: Class | c in Teacher.Teaches","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { some c:Class | Teacher.Teaches = c } pred inv6 { all t:Teacher | Teacher.Teaches != none } pred inv7 { } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Teacher}}{!={.{sig/Teacher}{field/Teaches{set of{sig/Class}}}}{none}}}","nextExpr":"all t: Teacher | t.Teaches != none","sourceExpr":"all t:Teacher | Teacher.Teaches != none","predicate":"inv6","isNewNode":true,"srcDstTED":1,"targetAST":"{all{one of{var0}{sig/Teacher}}{!={.{var0/Person}{field/Teaches{set of{sig/Class}}}}{none}}}","operations":"[\"(type='Update', node=sig/Teacher, value=var0/Person)\"]","hint":"One step away from the solution! Instead of using signature of type Teacher, try using variable of type Person to help satisfy the required property.","nextAST":"{all{one of{var0}{sig/Teacher}}{!={.{var0/Person}{field/Teaches{set of{sig/Class}}}}{none}}}","totalTED":1,"challenge":"zRAn69AocpkmxXZnW","time":83402301,"targetExpr":"all t: Teacher | t.Teaches != none","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { some c:Class | Teacher.Teaches = c } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | some t:Teacher | t.Teaches = c } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{={.{var1/Person}{field/Teaches{set of{sig/Class}}}}{var0/Class}}}}","nextExpr":"all c:Class { some t:Teacher | c in t.Teaches }","sourceExpr":"all c:Class | some t:Teacher | t.Teaches = c","predicate":"inv7","isNewNode":true,"srcDstTED":3,"targetAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node==, value=in)\", \"(type='Insert', node=var0/Class, parent==, position=0)\", \"(type='Delete', node=var0/Class)\"]","hint":"Near a solution! Instead of using equal operator ('=') to specify that the left side is equal to the right side, try using inclusion operator ('in') to specify that some element(s) belong to a set.","nextAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":3,"challenge":"zRAn69AocpkmxXZnW","time":113088900,"targetExpr":"all c:Class { some t:Teacher | c in t.Teaches }","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { some c:Class | Teacher.Teaches = c } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { all c:Class | all t:Teacher | t.Teaches = c } pred inv8 { } pred inv9 { } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{all{one of{var0}{sig/Class}}{all{one of{var1}{sig/Teacher}}{={.{var1/Person}{field/Teaches{set of{sig/Class}}}}{var0/Class}}}}","nextExpr":"all c:Class { some t:Teacher | c in t.Teaches }","sourceExpr":"all c:Class | all t:Teacher | t.Teaches = c","predicate":"inv7","isNewNode":true,"srcDstTED":4,"targetAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=all, value=some)\", \"(type='Update', node==, value=in)\", \"(type='Insert', node=var0/Class, parent==, position=0)\", \"(type='Delete', node=var0/Class)\"]","hint":"Keep going! Instead of using universal quantifier ('all') to specify that all elements in a set satisfy a condition, try using existential quantifier ('some') to specify that some elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{some{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":4,"challenge":"zRAn69AocpkmxXZnW","time":30010999,"targetExpr":"all c:Class { some t:Teacher | c in t.Teaches }","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { } pred inv8 { } pred inv9 { lone t:Teacher | t.Teaches = Class } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{lone{one of{var0}{sig/Teacher}}{={.{var0/Person}{field/Teaches{set of{sig/Class}}}}{sig/Class}}}","nextExpr":"all c : Class | lone (Teaches.c & Teacher)","sourceExpr":"lone t:Teacher | t.Teaches = Class","predicate":"inv9","isNewNode":true,"srcDstTED":7,"targetAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","operations":"[\"(type='Update', node=lone, value=all)\", \"(type='Insert', node=lone, parent=lone, position=1)\", \"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node==, value=&)\", \"(type='Move', tree='{={.{var0/Person}{field/Teaches{set of{sig/Class}}}}{sig/Class}}', parent=lone, position=0)\", \"(type='Update', node=sig/Class, value=sig/Teacher)\", \"(type='Insert', node=var0/Class, parent=., position=2)\", \"(type='Delete', node=var0/Person)\"]","hint":"Keep going! Instead of using lone quantifier ('lone') to specify that there is at most one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{lone{&{.{field/Teaches{set of{sig/Class}}}{var0/Class}}{sig/Teacher}}}}","totalTED":7,"challenge":"zRAn69AocpkmxXZnW","time":129728700,"targetExpr":"all c : Class | lone (Teaches.c & Teacher)","createdShorterPath":false}
{"mapping":"APTED","code":"sig Person { Tutors : set Person, Teaches : set Class } sig Group {} sig Class { Groups : Person -> Group } sig Teacher in Person {} sig Student in Person {} pred inv1 { all p:Person | p in Student } pred inv2 { no Teacher } pred inv3 { no p:Person | p in Teacher and p in Student } pred inv4 { no p:Person | p not in Teacher and p not in Student } pred inv5 { } pred inv6 { all t:Teacher | t.Teaches != none } pred inv7 { } pred inv8 { } pred inv9 { one t1:Teacher | one t2:Teacher| t1.Teaches != t2.Teaches } pred inv10 { } pred inv11 { } pred inv12 { } pred inv13 { } pred inv14 { } pred inv15 { }","sourceAST":"{one{one of{var0}{sig/Teacher}}{one{one of{var1}{sig/Teacher}}{!={.{var0/Person}{field/Teaches{set of{sig/Class}}}}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","nextExpr":"all c : Class { lone t : Teacher | c in t.Teaches }","sourceExpr":"one t1:Teacher | one t2:Teacher| t1.Teaches != t2.Teaches","predicate":"inv9","isNewNode":true,"srcDstTED":9,"targetAST":"{all{one of{var0}{sig/Class}}{lone{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","operations":"[\"(type='Update', node=one, value=all)\", \"(type='Update', node=one, value=lone)\", \"(type='Update', node=sig/Teacher, value=sig/Class)\", \"(type='Update', node=!=, value=in)\", \"(type='Update', node=var0/Person, value=var0/Class)\", \"(type='Move', tree='{var0/Person}', parent=!=, position=0)\", \"(type='TreeDelete', tree='{field/Teaches{set of{sig/Class}}}')\", \"(type='Delete', node=.)\"]","hint":"Keep going! Instead of using unique quantifier ('one') to specify that there is exactly one element in a set, try using universal quantifier ('all') to specify that all elements in a set satisfy a condition.","nextAST":"{all{one of{var0}{sig/Class}}{lone{one of{var1}{sig/Teacher}}{in{var0/Class}{.{var1/Person}{field/Teaches{set of{sig/Class}}}}}}}","totalTED":9,"challenge":"zRAn69AocpkmxXZnW","time":46600900,"targetExpr":"all c : Class { lone t : Teacher | c in t.Teaches }","createdShorterPath":false}

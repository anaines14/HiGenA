[{
  "_id": "dcSHE9Ps8Csq653Qx",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State | some e:Event, s3:State | s1->e->s3 in trans and s2->e->s3 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all s1:State, s2:State | some e:Event, s3:State | s1->e->s3 in trans and s2->e->s3 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{some{one of{var2}{sig/Event}}{some{one of{var3}{sig/State}}{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var0/State}{var1/State}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 11,
  "srcDstTED": 11,
  "operations": [
    "(type='Update', node=some, value=all)",
    "(type='Update', node=some, value=all)",
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Update', node=var0/State, value=var1/State)",
    "(type='Insert', node=var2/State, parent==, position=2)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var1/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Delete', node=var1/State)"
  ],
  "hint": "Keep going! Consider adding a variable of type State to help satisfy the required property. Think about how you can incorporate this within the = expression.",
  "time": "1526",
  "model_id": "e5Nk77NgbPW29iP9E"
},{
  "_id": "GNEtkGo7bjYFeX6hh",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State,  e:Event, s3:State | s1->e->s3 in trans and s2->e->s3 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all s1:State, s2:State,  e:Event, s3:State | s1->e->s3 in trans and s2->e->s3 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/Event}}{all{one of{var3}{sig/State}}{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var0/State}{var1/State}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 9,
  "srcDstTED": 9,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Update', node=var0/State, value=var1/State)",
    "(type='Insert', node=var2/State, parent==, position=2)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var1/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Delete', node=var1/State)"
  ],
  "hint": "Keep going! Consider adding a variable of type State to help satisfy the required property. Think about how you can incorporate this within the = expression.",
  "time": "255",
  "model_id": "8TyR39r4esXcZE2vR"
},{
  "_id": "BDswKAZhBr2Jun36G",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/Event}}{all{one of{var3}{sig/State}}{all{one of{var4}{sig/State}}{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var0/State}{var1/State}}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 13,
  "srcDstTED": 13,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Move', tree='{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var0/State}}}', parent=all, position=1)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Update', node=var0/State, value=var1/State)",
    "(type='Insert', node=var2/State, parent==, position=2)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var1/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var4/State, value=var2/State)",
    "(type='Delete', node=var1/State)",
    "(type='TreeDelete', tree='{one of{var4}{sig/State}}')",
    "(type='Delete', node=all)"
  ],
  "hint": "Keep going! Consider adding a variable of type State to help satisfy the required property. Think about how you can incorporate this within the = expression.",
  "time": "6865",
  "model_id": "FEDtrnRfcvxvasvH3"
},{
  "_id": "BsctvSi8tStdG272x",
  "expression": "inv5",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^trans\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\tall s:State, e:Event, s1:State, s2:State | s->e->s1 in trans and s->e->s2 in trans implies s1=s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all s:State, e:Event, s1:State, s2:State | s->e->s1 in trans and s->e->s2 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/Event}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/State}}{=>{AND{in{->{var0/State}{->{var1/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var1/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var2/State}{var3/State}}}}}}}",
  "targetExpr": "all s, m: State, e: Event | some s.trans[e] => some m.trans[e]",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/Event}}{=>{some{.{var2/Event}{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}{some{.{var2/Event}{.{var1/State}{field/trans{->{sig/Event}{sig/State}}}}}}}}}}",
  "nextExpr": "all s, m: State, e: Event | some s.trans[e] => some m.trans[e]",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/Event}}{=>{some{.{var2/Event}{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}}}{some{.{var2/Event}{.{var1/State}{field/trans{->{sig/Event}{sig/State}}}}}}}}}}",
  "totalTED": 26,
  "srcDstTED": 26,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Move', tree='{=>{AND{in{->{var0/State}{->{var1/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var1/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var2/State}{var3/State}}}', parent=all, position=1)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Insert', node=some, parent==>, position=0)",
    "(type='Insert', node=some, parent==>, position=1)",
    "(type='Insert', node=., parent=some, position=0)",
    "(type='Update', node=in, value=.)",
    "(type='Move', tree='{in{->{var0/State}{->{var1/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}', parent=some, position=0)",
    "(type='Insert', node=var2/Event, parent=., position=0)",
    "(type='Update', node=in, value=.)",
    "(type='Move', tree='{in{->{var0/State}{->{var1/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}', parent=., position=1)",
    "(type='Update', node=var0/State, value=var2/Event)",
    "(type='Move', tree='{var0/State}', parent=in, position=0)",
    "(type='Insert', node=., parent=in, position=1)",
    "(type='Move', tree='{var0/State}', parent=in, position=0)",
    "(type='Update', node=var1/Event, value=var1/State)",
    "(type='Move', tree='{var1/Event}', parent=., position=0)",
    "(type='Move', tree='{field/trans{->{sig/Event}{sig/State}}}', parent=., position=1)",
    "(type='TreeDelete', tree='{->{var1/Event}{var2/State}}')",
    "(type='Delete', node=->)",
    "(type='Delete', node=var3/State)",
    "(type='Delete', node=->)",
    "(type='Delete', node=->)",
    "(type='Delete', node=AND)",
    "(type='TreeDelete', tree='{={var2/State}{var3/State}}')",
    "(type='TreeDelete', tree='{one of{var3}{sig/State}}')",
    "(type='Delete', node=all)"
  ],
  "hint": "Keep going! You can use variables to help specify the condition. Consider introducing a new variable \".\" to your expression using the existential quantifier ('some').",
  "time": "764",
  "model_id": "s8koS9m5uC7qDvAdA"
},{
  "_id": "6fqdgADr5HQThN6RP",
  "expression": "inv5",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^trans\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\tall e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all e:Event, s1:State, s2:State | trans.s1 =  trans.s2",
  "sourceAST": "{all{one of{var0}{sig/Event}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{={.{field/trans{->{sig/Event}{sig/State}}}{var1/State}}{.{field/trans{->{sig/Event}{sig/State}}}{var2/State}}}}}}",
  "targetExpr": "all s1, s2 : State | s1.trans.State = s2.trans.State",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{={.{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}{sig/State}}{.{.{var1/State}{field/trans{->{sig/Event}{sig/State}}}}{sig/State}}}}}",
  "nextExpr": "all s1, s2 : State | s1.trans.State = s2.trans.State",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{={.{.{var0/State}{field/trans{->{sig/Event}{sig/State}}}}{sig/State}}{.{.{var1/State}{field/trans{->{sig/Event}{sig/State}}}}{sig/State}}}}}",
  "totalTED": 11,
  "srcDstTED": 11,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Move', tree='{={.{field/trans{->{sig/Event}{sig/State}}}{var1/State}}{.{field/trans{->{sig/Event}{sig/State}}}{var2/State}}}', parent=all, position=1)",
    "(type='Insert', node=., parent=., position=0)",
    "(type='Update', node=var1/State, value=sig/State)",
    "(type='Insert', node=., parent=., position=0)",
    "(type='Update', node=var2/State, value=sig/State)",
    "(type='Insert', node=var0/State, parent=., position=0)",
    "(type='Move', tree='{field/trans{->{sig/Event}{sig/State}}}', parent=., position=1)",
    "(type='Insert', node=var1/State, parent=., position=0)",
    "(type='Move', tree='{field/trans{->{sig/Event}{sig/State}}}', parent=., position=1)",
    "(type='TreeDelete', tree='{one of{var2}{sig/State}}')",
    "(type='Delete', node=all)"
  ],
  "hint": "Keep going! Consider adding a dot join operator ('.') to perform a relational join between sets or relations. Think about how you can incorporate this within the dot join operator ('.') expression.",
  "time": "204",
  "model_id": "Wb2YWjpYnveTRqkgk"
},{
  "_id": "7Z66pf3oL2Ng86PiL",
  "expression": "inv6",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\tall s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2 \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/Event}}{all{one of{var3}{sig/State}}{all{one of{var4}{sig/State}}{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var0/State}{var1/State}}}}}}}}",
  "targetExpr": "all e:Event | some s1,s2:State | s1->e->s2 in trans",
  "targetAST": "{all{one of{var0}{sig/Event}}{some{one of{var1}{sig/State}}{some{one of{var2}{sig/State}}{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}}}",
  "nextExpr": "all e:Event | some s1,s2:State | s1->e->s2 in trans",
  "nextAST": "{all{one of{var0}{sig/Event}}{some{one of{var1}{sig/State}}{some{one of{var2}{sig/State}}{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}}}",
  "totalTED": 29,
  "srcDstTED": 29,
  "operations": [
    "(type='Update', node=all, value=some)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Update', node=all, value=some)",
    "(type='Move', tree='{all{one of{var4}{sig/State}}{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var0/State}{var1/State}}}}', parent=all, position=1)",
    "(type='Move', tree='{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}', parent=all, position=1)",
    "(type='Update', node=var4, value=var2)",
    "(type='Update', node=var2/Event, value=var0/Event)",
    "(type='Update', node=var4/State, value=var2/State)",
    "(type='TreeDelete', tree='{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}')",
    "(type='Delete', node=AND)",
    "(type='TreeDelete', tree='{={var0/State}{var1/State}}')",
    "(type='Delete', node==>)",
    "(type='TreeDelete', tree='{one of{var2}{sig/Event}}')",
    "(type='TreeDelete', tree='{one of{var3}{sig/State}}')",
    "(type='Delete', node=all)",
    "(type='Delete', node=all)"
  ],
  "hint": "Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the inclusion operator ('in'). If you want to keep it, try to fix your expression another way and reach a different solution!",
  "time": "1547",
  "model_id": "v52ZpJoBo52MhknmP"
},{
  "_id": "r3x6pphXodKo3sik8",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\t \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": false,
  "createdShorterPath": false,
  "sourceExpr": "all s1:State, s2:State, e:Event, s3:State, s4:State | s1->e->s3 in trans and s2->e->s4 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/Event}}{all{one of{var3}{sig/State}}{all{one of{var4}{sig/State}}{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var0/State}{var1/State}}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 13,
  "srcDstTED": 13,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Move', tree='{=>{AND{in{->{var0/State}{->{var2/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var2/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var0/State}}}', parent=all, position=1)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Update', node=var0/State, value=var1/State)",
    "(type='Insert', node=var2/State, parent==, position=2)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var1/State)",
    "(type='Update', node=var2/Event, value=var3/Event)",
    "(type='Update', node=var4/State, value=var2/State)",
    "(type='Delete', node=var1/State)",
    "(type='TreeDelete', tree='{one of{var4}{sig/State}}')",
    "(type='Delete', node=all)"
  ],
  "hint": "Keep going! Consider adding a variable of type State to help satisfy the required property. Think about how you can incorporate this within the = expression.",
  "time": "0",
  "model_id": "tu6ZKHc73w3ThMq8q"
},{
  "_id": "rfATZPJZv4BtytFZj",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall e:Event, s:State | some s1:State, s2:State | s->e->s1 in trans and s->e->s2 in trans implies s1=s2 \n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\t \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all e:Event, s:State | some s1:State, s2:State | s->e->s1 in trans and s->e->s2 in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/Event}}{all{one of{var1}{sig/State}}{some{one of{var2}{sig/State}}{some{one of{var3}{sig/State}}{=>{AND{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var1/State}{->{var0/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var2/State}{var3/State}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 12,
  "srcDstTED": 12,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Update', node=some, value=all)",
    "(type='Update', node=some, value=all)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Insert', node=var1/State, parent==, position=0)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var2/State, value=var1/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Delete', node=var2/State)"
  ],
  "hint": "Keep going! Consider adding a variable of type State to help satisfy the required property. Think about how you can incorporate this within the = expression.",
  "time": "335",
  "model_id": "r7f4EqaJCuvJehTiG"
},{
  "_id": "344K4EL6LLwFxPXsj",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall e:Event, s:State | some s1:State, s2:State | s1->e->s in trans and s2->e->s in trans implies s1=s2 \n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\t \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all e:Event, s:State | some s1:State, s2:State | s1->e->s in trans and s2->e->s in trans implies s1=s2",
  "sourceAST": "{all{one of{var0}{sig/Event}}{all{one of{var1}{sig/State}}{some{one of{var2}{sig/State}}{some{one of{var3}{sig/State}}{=>{AND{in{->{var2/State}{->{var0/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var3/State}{->{var0/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var2/State}{var3/State}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 11,
  "srcDstTED": 11,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Update', node=some, value=all)",
    "(type='Update', node=some, value=all)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Insert', node=var1/State, parent==, position=0)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Update', node=var2/State, value=var0/State)",
    "(type='Update', node=var3/State, value=var0/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var1/State, value=var2/State)",
    "(type='Delete', node=var2/State)"
  ],
  "hint": "Keep going! Consider adding a variable of type State to help satisfy the required property. Think about how you can incorporate this within the = expression.",
  "time": "90",
  "model_id": "XiDPo59yJbDSgLnrN"
},{
  "_id": "JBNkdmkoNGTAWQJk4",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall e:Event, s1:State, s2:State | some s3:State, s4:State | s1->e->s2 in trans and s3->e->s4 in trans implies s1=s3 and s2=s4\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\t \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all e:Event, s1:State, s2:State | some s3:State, s4:State | s1->e->s2 in trans and s3->e->s4 in trans implies s1=s3 and s2=s4",
  "sourceAST": "{all{one of{var0}{sig/Event}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{some{one of{var3}{sig/State}}{some{one of{var4}{sig/State}}{=>{AND{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var3/State}{->{var0/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{AND{={var1/State}{var3/State}}{={var2/State}{var4/State}}}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 18,
  "srcDstTED": 18,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Update', node=some, value=all)",
    "(type='Move', tree='{=>{AND{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var3/State}{->{var0/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{AND{={var1/State}{var3/State}}{={var4/State}{var2/State}}}}', parent=some, position=1)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Move', tree='{={var1/State}{var3/State}}', parent==>, position=1)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var3/State, value=var0/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var2/State, value=var1/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var4/State, value=var2/State)",
    "(type='TreeDelete', tree='{={var4/State}{var2/State}}')",
    "(type='Delete', node=AND)",
    "(type='TreeDelete', tree='{one of{var4}{sig/State}}')",
    "(type='Delete', node=some)"
  ],
  "hint": "Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the =. If you want to keep it, try to fix your expression another way and reach a different solution!",
  "time": "135",
  "model_id": "ro2APYuGatpy2hg3w"
},{
  "_id": "4q3TbgubfiF69mrox",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall e:Event, s1:State, s2:State | some s3:State, s4:State | s1->e->s2 in trans and s3->e->s4 in trans implies s1=s3 \n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\t \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all e:Event, s1:State, s2:State | some s3:State, s4:State | s1->e->s2 in trans and s3->e->s4 in trans implies s1=s3",
  "sourceAST": "{all{one of{var0}{sig/Event}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{some{one of{var3}{sig/State}}{some{one of{var4}{sig/State}}{=>{AND{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var3/State}{->{var0/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var3/State}}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 14,
  "srcDstTED": 14,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Update', node=some, value=all)",
    "(type='Move', tree='{=>{AND{in{->{var1/State}{->{var0/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var3/State}{->{var0/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var3/State}}}', parent=some, position=1)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Update', node=var3/State, value=var2/State)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var3/State, value=var0/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var2/State, value=var1/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var4/State, value=var2/State)",
    "(type='TreeDelete', tree='{one of{var4}{sig/State}}')",
    "(type='Delete', node=some)"
  ],
  "hint": "Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the one of. If you want to keep it, try to fix your expression another way and reach a different solution!",
  "time": "98",
  "model_id": "7E3JhSQfuGPhTDgoN"
},{
  "_id": "efg6gCBHZtoJLPcRs",
  "expression": "inv3",
  "code": "/*\nA labeled transition system (LTS) is comprised by States, a sub-set\nof which are Initial, connected by transitions, here represented by \nEvents.\n*/\nsig State {\n        trans : Event -> State\n}\nsig Init in State {}\nsig Event {}\n\n/*\nThe LTS does not contain deadlocks, ie, each state has at least a \ntransition.\n*/\npred inv1 {\n\t all s:State | some e:Event, a1:State | s->e->a1 in trans\n}\n\n/*\nThere is a single initial state.\n*/\npred inv2 {\n\tone Init\n}\n\n/*\nThe LTS is deterministic, ie, each state has at most a transition for each event.\n*/\npred inv3 {\n\tall e:Event, s:State, s3:State, s1:State, s2:State | s->e->s1 in trans and s3->e->s2 in trans implies s1=s2 and s=s3\n}\n\n/*\nAll states are reachable from an initial state.\n*/\npred inv4 {\n\t//all s:State | s in Init.^(\n}\n\n/*\nAll the states have the same events available.\n*/\npred inv5 {\n\t//all e:Event, s1:State, s2:State | trans.s1 =  trans.s2\n}\n\n/*\nEach event is available in at least a state.\n*/\npred inv6 {\n\t \n}\n\n/*\nThe LTS is reversible, ie, from a reacheable state it is always possible \nto return to an initial state.\n*/\npred inv7 {\n\n}",
  "mapping": "APTED",
  "type": "ted",
  "isNewNode": true,
  "createdShorterPath": false,
  "sourceExpr": "all e:Event, s:State, s3:State, s1:State, s2:State | s->e->s1 in trans and s3->e->s2 in trans implies s1=s2 and s=s3",
  "sourceAST": "{all{one of{var0}{sig/Event}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/State}}{all{one of{var4}{sig/State}}{=>{AND{in{->{var1/State}{->{var0/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var2/State}{->{var0/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{AND{={var3/State}{var4/State}}{={var1/State}{var2/State}}}}}}}}}",
  "targetExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "targetAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "nextExpr": "all x, z, v : State, y : Event | x->y->z in trans and x->y->v in trans implies z=v",
  "nextAST": "{all{one of{var0}{sig/State}}{all{one of{var1}{sig/State}}{all{one of{var2}{sig/State}}{all{one of{var3}{sig/Event}}{=>{AND{in{->{var0/State}{->{var3/Event}{var1/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var0/State}{->{var3/Event}{var2/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{={var1/State}{var2/State}}}}}}}",
  "totalTED": 16,
  "srcDstTED": 16,
  "operations": [
    "(type='Update', node=sig/Event, value=sig/State)",
    "(type='Move', tree='{=>{AND{in{->{var1/State}{->{var0/Event}{var3/State}}}{field/trans{->{sig/Event}{sig/State}}}}{in{->{var2/State}{->{var0/Event}{var4/State}}}{field/trans{->{sig/Event}{sig/State}}}}}{AND{={var3/State}{var4/State}}{={var1/State}{var2/State}}}}', parent=all, position=1)",
    "(type='Update', node=sig/State, value=sig/Event)",
    "(type='Move', tree='{={var1/State}{var2/State}}', parent==>, position=1)",
    "(type='Update', node=var1/State, value=var0/State)",
    "(type='Update', node=var2/State, value=var0/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var3/State, value=var1/State)",
    "(type='Update', node=var0/Event, value=var3/Event)",
    "(type='Update', node=var4/State, value=var2/State)",
    "(type='TreeDelete', tree='{={var3/State}{var4/State}}')",
    "(type='Delete', node=AND)",
    "(type='TreeDelete', tree='{one of{var4}{sig/State}}')",
    "(type='Delete', node=all)"
  ],
  "hint": "Keep going! It seems like you have unnecessary elements in your expression. You can try simplifying your expression by deleting the =. If you want to keep it, try to fix your expression another way and reach a different solution!",
  "time": "120",
  "model_id": "MZbXzkoAFKjRSQCcR"
}]
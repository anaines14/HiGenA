Challenge;Predicate;Expression;Solution;Hint
gAeD3MTGCCv8YNTaK;weaklyConnected;all n: Node | Node in n.^adj;all v : Node | Node in v.*(adj + ~adj);Keep going! Consider adding a reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation. Think about how you can incorporate this within the dot join operator ('.') expression.
gAeD3MTGCCv8YNTaK;weaklyConnected;all n: Node | Node in n.^(adj + ~adj);all v : Node | Node in v.*(adj + ~adj);One step away from the solution! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.
gAeD3MTGCCv8YNTaK;undirected;all n : Node | n in n.adj.~adj;adj = ~adj;Keep going! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using equal operator ('=') to specify that the left side is equal to the right side.
gAeD3MTGCCv8YNTaK;undirected;adj.~adj in iden;adj = ~adj;Near a solution! Instead of using dot join operator ('.') to perform a relational join between sets or relations, try using equal operator ('=') to specify that the left side is equal to the right side.
gAeD3MTGCCv8YNTaK;stonglyConnected;all n : Node | Node in n.^adj;all n:Node | Node in n.*adj;One step away from the solution! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.
gAeD3MTGCCv8YNTaK;stonglyConnected;Node in Node.^adj;all n:Node | Node in n.*adj;Keep going! Instead of using transitive closure operator ('^') to get the transitive closure of a relation, try using reflexive-transitive closure operator ('*') to get the reflexive-transitive closure of a relation.
gAeD3MTGCCv8YNTaK;noLoops;all n : Node | n not in n.^adj;all n : Node | n not in n.adj;One step away from the solution! It seems like the field/adj is not in the right place. Try moving it to the inside of the dot join operator ('.')expression. Try moving it so that you correctly ensure the required property.
zoEADeCW2b2suJB2k;inv3;all y : State | lone y.trans;all s : State, e : Event | lone e.(s.trans);Keep going! You can use variables to help specify the condition. Consider introducing a new variable "Event" to your expression using the universal quantifier ('all').
zoEADeCW2b2suJB2k;inv3;all x : State, y : Event | lone x.trans.y;all s: State, e: Event | lone ~(s.trans).e;One step away from the solution! Consider adding a transpose operator ('~') to transpose a relation. Think about how you can incorporate this within the dot join operator ('.') expression.
zoEADeCW2b2suJB2k;inv1;some State.trans;all s : State | some s.trans;Keep going! You can use variables to help specify the condition. Consider introducing a new variable "State" to your expression using the universal quantifier ('all').